<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: white;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
    content: counter(line);
    margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","Users","yuvikachaudhary","Desktop","Semester 4","COP290","spreadsheet_rust","src","extension","backend","backend.rs"],"content":"#![allow(dead_code)]\nuse std::fs;\nconst UNDO_LIMIT: usize = 1000;\nuse crate::extension::backend::functions::*;\nuse crate::extension::backend::graph::Node;\nuse crate::extension::backend::graph::get_sequence;\nuse crate::extension::backend::graph::has_cycle;\nuse crate::extension::backend::graph::update_edges;\nuse crate::extension::common::{Operation, Value};\nuse crate::extension::parser::*;\nuse serde::{Deserialize, Serialize};\n//init_backend(r,c) -\u003e generate a grid of all nodes : returns void\n//execute(value::cell, value::oper) -\u003e update_edges(Node, value::oper), hasCycle(Box\u003c\u003e, value::cell), get_sequence(Box\u003c\u003e, value::cell), update_grid(sequence) -\u003e return status\n//update_grid(sequence) -\u003e loop assign to Node = \u003cfunctions\u003e(Box\u003c\u003e, value::oper -\u003e return bool\n//process_command(r,c, string, value::Cell) -\u003e parser, execute(value::cell, value::oper): return status\n//get_value(value::cell): returns a cell_value\n/// Control Unit for data processing and updating values in Spreadsheeet.\n/// The `Grid` struct is designed to store and manage a grid of `Cell` objects.\n///Data structure to represent sheet\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct Grid {\n    rows: usize,\n    columns: usize,\n    pub cells_vec: Vec\u003cVec\u003cNode\u003e\u003e,\n}\n///Data structure to represent status of command\n#[derive(PartialEq, Debug)]\npub enum Status {\n    Success,\n    UnrecognizedCmd,\n    CircularDependency,\n    PrintEnabled,\n    PrintDisabled,\n    ScrollTo(usize, usize),\n    Up,\n    Down,\n    Left,\n    Right,\n    Quit,\n    Web(String),\n    WebStart,\n}\n\nimpl Grid {\n    ///Function to initialize grid. Arguments are size of grid.\n    pub fn new(rows: usize, columns: usize) -\u003e Self {\n        Grid {\n            rows,\n            columns,\n            cells_vec: vec![vec![Node::new(0); columns]; rows],\n        }\n    }\n    pub fn set_node(\u0026mut self, row: usize, col: usize, node: Node) {\n        self.cells_vec[row][col] = node;\n    }\n    pub fn get_row_size(\u0026self) -\u003e usize {\n        self.rows\n    }\n    pub fn get_column_size(\u0026self) -\u003e usize {\n        self.columns\n    }\n    pub fn get_node(\u0026mut self, row: usize, column: usize) -\u003e \u0026mut Node {\n        \u0026mut self.cells_vec[row][column]\n    }\n    pub fn get_node_value(\u0026self, row: usize, column: usize) -\u003e Option\u003cisize\u003e {\n        self.cells_vec[row][column].get_node_value()\n    }\n    // pub fn get_node_mut(\u0026mut self, row: usize, column: usize) -\u003e \u0026mut Node {\n    //     \u0026mut self.cells_vec[row][column]\n    // }\n}\n\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct Valgrid {\n    pub rows: usize,\n    pub columns: usize,\n    pub cells: Vec\u003cVec\u003cOption\u003cisize\u003e\u003e\u003e,\n}\n\n///Struct that contains data structure as well as methods\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct Backend {\n    pub grid: Grid,\n    undo_stack: Vec\u003cGrid\u003e,\n    redo_stack: Vec\u003cGrid\u003e,\n}\n\nimpl Backend {\n    ///Initializes Backend\n    pub fn init_backend(rows: usize, columns: usize) -\u003e Self {\n        Backend {\n            grid: Grid::new(rows + 1, columns + 1),\n            undo_stack: Vec::new(),\n            redo_stack: Vec::new(),\n        }\n    }\n    ///Returns the value of cell\n    pub fn get_node_value(\u0026self, cell: Value) -\u003e Option\u003cisize\u003e {\n        match cell {\n            Value::Cell(row, col) =\u003e self.grid.get_node_value(row, col),\n            _ =\u003e panic!(\"Expected a Cell value\"),\n        }\n    }\n    pub fn get_valgrid(\u0026self) -\u003e Valgrid {\n        Valgrid {\n            rows: self.grid.get_row_size(),\n            columns: self.grid.get_column_size(),\n            cells: self\n                .grid\n                .cells_vec\n                .iter()\n                .map(|row| {\n                    row.iter()\n                        .map(|cell| {\n                            if cell.valid {\n                                Some(cell.node_value)\n                            } else {\n                                None\n                            }\n                        })\n                        .collect()\n                })\n                .collect(),\n        }\n    }\n    ///Iterates over the sequence of topological sort and updates values\n    fn update_grid(\u0026mut self, sequence: Vec\u003cValue\u003e) {\n        for cell in sequence {\n            if let Some(Value::Oper(_box1, _box2, oper)) =\n                self.grid.get_node(cell.row(), cell.col()).function.clone()\n            {\n                match oper {\n                    Operation::Sum =\u003e {\n                        let sum = sum_function(\u0026mut self.grid, cell.row(), cell.col());\n                        match sum {\n                            Some(val) =\u003e {\n                                self.grid.cells_vec[cell.row()][cell.col()].node_value = val;\n                                self.grid.cells_vec[cell.row()][cell.col()].valid = true;\n                            }\n                            None =\u003e {\n                                self.grid.cells_vec[cell.row()][cell.col()].valid = false;\n                            }\n                        }\n                    }\n                    Operation::Min =\u003e {\n                        let min = min_function(\u0026mut self.grid, cell.row(), cell.col());\n                        match min {\n                            Some(val) =\u003e {\n                                self.grid.cells_vec[cell.row()][cell.col()].node_value = val;\n                                self.grid.cells_vec[cell.row()][cell.col()].valid = true;\n                            }\n                            None =\u003e {\n                                self.grid.cells_vec[cell.row()][cell.col()].valid = false;\n                            }\n                        }\n                    }\n                    Operation::Max =\u003e {\n                        let max = max_function(\u0026mut self.grid, cell.row(), cell.col());\n                        match max {\n                            Some(val) =\u003e {\n                                self.grid.cells_vec[cell.row()][cell.col()].node_value = val;\n                                self.grid.cells_vec[cell.row()][cell.col()].valid = true;\n                            }\n                            None =\u003e {\n                                self.grid.cells_vec[cell.row()][cell.col()].valid = false;\n                            }\n                        }\n                    }\n                    Operation::Avg =\u003e {\n                        let avg = avg_function(\u0026mut self.grid, cell.row(), cell.col());\n                        match avg {\n                            Some(val) =\u003e {\n                                self.grid.cells_vec[cell.row()][cell.col()].node_value = val;\n                                self.grid.cells_vec[cell.row()][cell.col()].valid = true;\n                            }\n                            None =\u003e {\n                                self.grid.cells_vec[cell.row()][cell.col()].valid = false;\n                            }\n                        }\n                    }\n                    Operation::Std =\u003e {\n                        let std_dev = std_dev_function(\u0026mut self.grid, cell.row(), cell.col());\n                        match std_dev {\n                            Some(val) =\u003e {\n                                self.grid.cells_vec[cell.row()][cell.col()].node_value = val;\n                                self.grid.cells_vec[cell.row()][cell.col()].valid = true;\n                            }\n                            None =\u003e {\n                                self.grid.cells_vec[cell.row()][cell.col()].valid = false;\n                            }\n                        }\n                    }\n                    Operation::Add =\u003e {\n                        let ans = add(\u0026mut self.grid, cell.row(), cell.col());\n                        match ans {\n                            Some(val) =\u003e {\n                                self.grid.cells_vec[cell.row()][cell.col()].node_value = val;\n                                self.grid.cells_vec[cell.row()][cell.col()].valid = true;\n                            }\n                            None =\u003e {\n                                self.grid.cells_vec[cell.row()][cell.col()].valid = false;\n                            }\n                        }\n                    }\n                    Operation::Sub =\u003e {\n                        let ans = sub(\u0026mut self.grid, cell.row(), cell.col());\n                        match ans {\n                            Some(val) =\u003e {\n                                self.grid.cells_vec[cell.row()][cell.col()].node_value = val;\n                                self.grid.cells_vec[cell.row()][cell.col()].valid = true;\n                            }\n                            None =\u003e {\n                                self.grid.cells_vec[cell.row()][cell.col()].valid = false;\n                            }\n                        }\n                    }\n                    Operation::Mul =\u003e {\n                        let ans = mul(\u0026mut self.grid, cell.row(), cell.col());\n                        match ans {\n                            Some(val) =\u003e {\n                                self.grid.cells_vec[cell.row()][cell.col()].node_value = val;\n                                self.grid.cells_vec[cell.row()][cell.col()].valid = true;\n                            }\n                            None =\u003e {\n                                self.grid.cells_vec[cell.row()][cell.col()].valid = false;\n                            }\n                        }\n                    }\n                    Operation::Div =\u003e {\n                        let ans = div(\u0026mut self.grid, cell.row(), cell.col());\n                        match ans {\n                            Some(val) =\u003e {\n                                self.grid.cells_vec[cell.row()][cell.col()].node_value = val;\n                                self.grid.cells_vec[cell.row()][cell.col()].valid = true;\n                            }\n                            None =\u003e {\n                                self.grid.cells_vec[cell.row()][cell.col()].valid = false;\n                            }\n                        }\n                    }\n                    Operation::Slp =\u003e {\n                        let ans = slp(\u0026mut self.grid, cell.row(), cell.col());\n                        match ans {\n                            Some(val) =\u003e {\n                                self.grid.cells_vec[cell.row()][cell.col()].node_value = val;\n                                self.grid.cells_vec[cell.row()][cell.col()].valid = true;\n                            }\n                            None =\u003e {\n                                self.grid.cells_vec[cell.row()][cell.col()].valid = false;\n                            }\n                        }\n                    }\n                    Operation::Cons =\u003e {\n                        let ans = cons(\u0026mut self.grid, cell.row(), cell.col());\n                        match ans {\n                            Some(val) =\u003e {\n                                self.grid.cells_vec[cell.row()][cell.col()].node_value = val;\n                                self.grid.cells_vec[cell.row()][cell.col()].valid = true;\n                            }\n                            None =\u003e {\n                                self.grid.cells_vec[cell.row()][cell.col()].valid = false;\n                            }\n                        }\n                    }\n                    _ =\u003e {\n                        // Handle other operations if needed\n                    }\n                }\n            }\n        }\n    }\n\n    ///Checks for cycles and accordingly updates dependencies\n    fn execute(\u0026mut self, cell: Value, func: Option\u003cValue\u003e) -\u003e Status {\n        //I want that if func has first and second box as value::const type, then just update graph and evaluate expression by sending Operation as well\n        if let Some(Value::Oper(Some(box1), Some(box2), _oper)) = func.clone() {\n            if let (Value::Const(_val1), Value::Const(_val2)) = (*box1, *box2) {\n                update_edges(\u0026mut self.grid, cell.clone(), func.clone(), true); //debug check //add break edges\n                // change cell's parameters here\n                let node = self.grid.get_node(cell.row(), cell.col());\n                node.function = func.clone();\n                let sequence = get_sequence(\u0026mut self.grid, cell.clone());\n                self.update_grid(sequence.clone());\n            } else {\n                update_edges(\u0026mut self.grid, cell.clone(), func.clone(), true);\n                if has_cycle(\u0026mut self.grid, cell.clone()) {\n                    update_edges(\u0026mut self.grid, cell.clone(), func.clone(), false);\n                    return Status::CircularDependency;\n                }\n                // change cell's parameters here\n                let node = self.grid.get_node(cell.row(), cell.col());\n                node.function = func.clone();\n                let sequence = get_sequence(\u0026mut self.grid, cell.clone());\n                self.update_grid(sequence.clone());\n            }\n        }\n        Status::Success\n    }\n    ///Takes command from frontend, calls the Parser, and sends the decoded command to execute function\n    pub fn process_command(\u0026mut self, rows: usize, columns: usize, cmd: String) -\u003e Status {\n        match parser::validate(\u0026cmd, \u0026columns, \u0026rows) {\n            Some((None, Some(Value::Oper(None, None, op)))) =\u003e match op {\n                Operation::EnableOutput =\u003e Status::PrintEnabled,\n                Operation::DisableOutput =\u003e Status::PrintDisabled,\n                Operation::Left =\u003e Status::Left,\n                Operation::Right =\u003e Status::Right,\n                Operation::Up =\u003e Status::Up,\n                Operation::Down =\u003e Status::Down,\n                Operation::Quit =\u003e Status::Quit,\n                Operation::Web(path) =\u003e Status::Web(path),\n                Operation::WebStart =\u003e Status::WebStart,\n                Operation::Save(path) =\u003e {\n                    if self.serial(\u0026path).is_err() {\n                        return Status::UnrecognizedCmd;\n                    }\n                    Status::Success\n                }\n                Operation::Undo =\u003e {\n                    if let Some(prev_grid) = self.undo_stack.pop() {\n                        self.redo_stack.push(self.grid.clone());\n                        self.grid = prev_grid;\n                        Status::Success\n                    } else {\n                        Status::UnrecognizedCmd\n                    }\n                }\n                Operation::Redo =\u003e {\n                    if let Some(next_grid) = self.redo_stack.pop() {\n                        self.undo_stack.push(self.grid.clone());\n                        if self.undo_stack.len() \u003e UNDO_LIMIT {\n                            self.undo_stack.remove(0); // drop oldest\n                        }\n                        self.grid = next_grid;\n                        Status::Success\n                    } else {\n                        Status::UnrecognizedCmd\n                    }\n                }\n                _ =\u003e Status::UnrecognizedCmd,\n            },\n            Some((\n                Some(Value::Cell(col, row)),\n                Some(Value::Oper(None, None, Operation::ScrollTo)),\n            )) =\u003e Status::ScrollTo(col, row),\n            Some((Some(Value::Cell(col, row)), Some(Value::Oper(box1, box2, op)))) =\u003e {\n                // change here\n                // either have to change parser or change the inside parts of box1 and box2\n                self.undo_stack.push(self.grid.clone());\n                if self.undo_stack.len() \u003e UNDO_LIMIT {\n                    self.undo_stack.remove(0);\n                }\n                self.redo_stack.clear(); // clear redo stack on new action\n                self.execute(Value::Cell(col, row), Some(Value::Oper(box1, box2, op)))\n            }\n            _ =\u003e Status::UnrecognizedCmd,\n        }\n    }\n\n    pub fn get_grid(\u0026self) -\u003e \u0026Grid {\n        \u0026self.grid\n    }\n\n    pub fn serial(\u0026self, path: \u0026str) -\u003e Result\u003c(), String\u003e {\n        let json = serde_json::to_string_pretty(self)\n            .map_err(|e| format!(\"Serialization error: {}\", e))?;\n        std::fs::write(path, json).map_err(|e| format!(\"File write error: {}\", e))\n    }\n\n    pub fn deserial(path: \u0026str) -\u003e Result\u003cSelf, String\u003e {\n        let json = fs::read_to_string(path).map_err(|e| format!(\"File read error: {}\", e))?;\n        serde_json::from_str(\u0026json).map_err(|e| format!(\"Deserialization error: {}\", e))\n    }\n\n    pub fn deserial_text(text: String) -\u003e Result\u003cSelf, String\u003e {\n        serde_json::from_str(\u0026text).map_err(|e| format!(\"Deserialization error: {}\", e))\n    }\n}\n","traces":[{"line":46,"address":[],"length":0,"stats":{"Line":85}},{"line":50,"address":[],"length":0,"stats":{"Line":85}},{"line":53,"address":[],"length":0,"stats":{"Line":1369}},{"line":54,"address":[],"length":0,"stats":{"Line":1369}},{"line":56,"address":[],"length":0,"stats":{"Line":6}},{"line":57,"address":[],"length":0,"stats":{"Line":6}},{"line":59,"address":[],"length":0,"stats":{"Line":6}},{"line":60,"address":[],"length":0,"stats":{"Line":6}},{"line":62,"address":[],"length":0,"stats":{"Line":906}},{"line":63,"address":[],"length":0,"stats":{"Line":906}},{"line":65,"address":[],"length":0,"stats":{"Line":1424}},{"line":66,"address":[],"length":0,"stats":{"Line":1424}},{"line":90,"address":[],"length":0,"stats":{"Line":31}},{"line":92,"address":[],"length":0,"stats":{"Line":31}},{"line":93,"address":[],"length":0,"stats":{"Line":31}},{"line":94,"address":[],"length":0,"stats":{"Line":31}},{"line":98,"address":[],"length":0,"stats":{"Line":24}},{"line":99,"address":[],"length":0,"stats":{"Line":24}},{"line":100,"address":[],"length":0,"stats":{"Line":23}},{"line":101,"address":[],"length":0,"stats":{"Line":1}},{"line":104,"address":[],"length":0,"stats":{"Line":1}},{"line":106,"address":[],"length":0,"stats":{"Line":1}},{"line":107,"address":[],"length":0,"stats":{"Line":1}},{"line":108,"address":[],"length":0,"stats":{"Line":1}},{"line":127,"address":[],"length":0,"stats":{"Line":56}},{"line":128,"address":[],"length":0,"stats":{"Line":168}},{"line":129,"address":[],"length":0,"stats":{"Line":56}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":56}},{"line":134,"address":[],"length":0,"stats":{"Line":2}},{"line":135,"address":[],"length":0,"stats":{"Line":2}},{"line":136,"address":[],"length":0,"stats":{"Line":1}},{"line":137,"address":[],"length":0,"stats":{"Line":1}},{"line":138,"address":[],"length":0,"stats":{"Line":1}},{"line":140,"address":[],"length":0,"stats":{"Line":1}},{"line":141,"address":[],"length":0,"stats":{"Line":1}},{"line":146,"address":[],"length":0,"stats":{"Line":1}},{"line":147,"address":[],"length":0,"stats":{"Line":1}},{"line":148,"address":[],"length":0,"stats":{"Line":1}},{"line":149,"address":[],"length":0,"stats":{"Line":1}},{"line":150,"address":[],"length":0,"stats":{"Line":1}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":1}},{"line":159,"address":[],"length":0,"stats":{"Line":1}},{"line":160,"address":[],"length":0,"stats":{"Line":1}},{"line":161,"address":[],"length":0,"stats":{"Line":1}},{"line":162,"address":[],"length":0,"stats":{"Line":1}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":2}},{"line":171,"address":[],"length":0,"stats":{"Line":2}},{"line":172,"address":[],"length":0,"stats":{"Line":1}},{"line":173,"address":[],"length":0,"stats":{"Line":1}},{"line":174,"address":[],"length":0,"stats":{"Line":1}},{"line":176,"address":[],"length":0,"stats":{"Line":1}},{"line":177,"address":[],"length":0,"stats":{"Line":1}},{"line":182,"address":[],"length":0,"stats":{"Line":2}},{"line":183,"address":[],"length":0,"stats":{"Line":2}},{"line":184,"address":[],"length":0,"stats":{"Line":1}},{"line":185,"address":[],"length":0,"stats":{"Line":1}},{"line":186,"address":[],"length":0,"stats":{"Line":1}},{"line":188,"address":[],"length":0,"stats":{"Line":1}},{"line":189,"address":[],"length":0,"stats":{"Line":1}},{"line":194,"address":[],"length":0,"stats":{"Line":3}},{"line":195,"address":[],"length":0,"stats":{"Line":3}},{"line":196,"address":[],"length":0,"stats":{"Line":2}},{"line":197,"address":[],"length":0,"stats":{"Line":2}},{"line":198,"address":[],"length":0,"stats":{"Line":2}},{"line":200,"address":[],"length":0,"stats":{"Line":1}},{"line":201,"address":[],"length":0,"stats":{"Line":1}},{"line":206,"address":[],"length":0,"stats":{"Line":2}},{"line":207,"address":[],"length":0,"stats":{"Line":2}},{"line":208,"address":[],"length":0,"stats":{"Line":1}},{"line":209,"address":[],"length":0,"stats":{"Line":1}},{"line":210,"address":[],"length":0,"stats":{"Line":1}},{"line":212,"address":[],"length":0,"stats":{"Line":1}},{"line":213,"address":[],"length":0,"stats":{"Line":1}},{"line":218,"address":[],"length":0,"stats":{"Line":2}},{"line":219,"address":[],"length":0,"stats":{"Line":2}},{"line":220,"address":[],"length":0,"stats":{"Line":1}},{"line":221,"address":[],"length":0,"stats":{"Line":1}},{"line":222,"address":[],"length":0,"stats":{"Line":1}},{"line":224,"address":[],"length":0,"stats":{"Line":1}},{"line":225,"address":[],"length":0,"stats":{"Line":1}},{"line":230,"address":[],"length":0,"stats":{"Line":2}},{"line":231,"address":[],"length":0,"stats":{"Line":2}},{"line":232,"address":[],"length":0,"stats":{"Line":1}},{"line":233,"address":[],"length":0,"stats":{"Line":1}},{"line":234,"address":[],"length":0,"stats":{"Line":1}},{"line":236,"address":[],"length":0,"stats":{"Line":1}},{"line":237,"address":[],"length":0,"stats":{"Line":1}},{"line":242,"address":[],"length":0,"stats":{"Line":2}},{"line":243,"address":[],"length":0,"stats":{"Line":2}},{"line":244,"address":[],"length":0,"stats":{"Line":1}},{"line":245,"address":[],"length":0,"stats":{"Line":1}},{"line":246,"address":[],"length":0,"stats":{"Line":1}},{"line":248,"address":[],"length":0,"stats":{"Line":1}},{"line":249,"address":[],"length":0,"stats":{"Line":1}},{"line":254,"address":[],"length":0,"stats":{"Line":37}},{"line":255,"address":[],"length":0,"stats":{"Line":37}},{"line":256,"address":[],"length":0,"stats":{"Line":37}},{"line":257,"address":[],"length":0,"stats":{"Line":37}},{"line":258,"address":[],"length":0,"stats":{"Line":37}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":57}},{"line":276,"address":[],"length":0,"stats":{"Line":114}},{"line":277,"address":[],"length":0,"stats":{"Line":131}},{"line":278,"address":[],"length":0,"stats":{"Line":37}},{"line":280,"address":[],"length":0,"stats":{"Line":37}},{"line":281,"address":[],"length":0,"stats":{"Line":37}},{"line":282,"address":[],"length":0,"stats":{"Line":37}},{"line":283,"address":[],"length":0,"stats":{"Line":37}},{"line":285,"address":[],"length":0,"stats":{"Line":20}},{"line":286,"address":[],"length":0,"stats":{"Line":20}},{"line":287,"address":[],"length":0,"stats":{"Line":1}},{"line":288,"address":[],"length":0,"stats":{"Line":1}},{"line":291,"address":[],"length":0,"stats":{"Line":19}},{"line":292,"address":[],"length":0,"stats":{"Line":19}},{"line":293,"address":[],"length":0,"stats":{"Line":19}},{"line":294,"address":[],"length":0,"stats":{"Line":19}},{"line":297,"address":[],"length":0,"stats":{"Line":56}},{"line":300,"address":[],"length":0,"stats":{"Line":61}},{"line":301,"address":[],"length":0,"stats":{"Line":61}},{"line":302,"address":[],"length":0,"stats":{"Line":2}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":2}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":2}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":57}},{"line":348,"address":[],"length":0,"stats":{"Line":57}},{"line":349,"address":[],"length":0,"stats":{"Line":57}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":2}},{"line":359,"address":[],"length":0,"stats":{"Line":1403}},{"line":360,"address":[],"length":0,"stats":{"Line":1403}},{"line":363,"address":[],"length":0,"stats":{"Line":1}},{"line":364,"address":[],"length":0,"stats":{"Line":2}},{"line":365,"address":[],"length":0,"stats":{"Line":2}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":2}},{"line":370,"address":[],"length":0,"stats":{"Line":6}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}}],"covered":132,"coverable":174},{"path":["/","Users","yuvikachaudhary","Desktop","Semester 4","COP290","spreadsheet_rust","src","extension","backend","functions.rs"],"content":"use crate::extension::backend::backend::Grid;\nuse crate::extension::common::*;\n\n/// Functions module for the spreadsheet extension backend.\n/// This provides the core computational functions used in cell formulas.\n/// Finds the maximum value in a range of cells.\n///\n/// # Arguments\n///\n/// * `grid` - A mutable reference to the spreadsheet grid containing all cells\n/// * `row` - The row index of the cell containing this function\n/// * `col` - The column index of the cell containing this function\n///\n/// # Returns\n///\n/// * `Some(isize)` - The maximum value found in the specified range if all cells are valid\n/// * `None` - If any cell in the range is invalid or has an error\n///\n/// # Details\n///\n/// Iterates through all cells in the range specified by the cell's function parameters\n/// (which should be Value::Cell coordinates for the top-left and bottom-right corners)\n/// and returns the maximum value. If any cell in the range is invalid, returns None.\npub fn max_function(grid: \u0026mut Grid, row: usize, col: usize) -\u003e Option\u003cisize\u003e {\n    let mut max_val = isize::MIN;\n    let node = grid.get_node(row, col);\n    if let Some(Value::Oper(Some(box1), Some(box2), _oper)) = node.function.clone() {\n        if let (Value::Cell(row1, col1), Value::Cell(row2, col2)) = (*box1, *box2) {\n            for i in row1..=row2 {\n                for j in col1..=col2 {\n                    let current_node = grid.get_node(i, j);\n                    if !current_node.valid {\n                        return None;\n                    } else if current_node.node_value \u003e max_val {\n                        max_val = current_node.node_value;\n                    }\n                }\n            }\n        }\n    }\n    Some(max_val)\n}\n\n/// Finds the minimum value in a range of cells.\n///\n/// # Arguments\n///\n/// * `grid` - A mutable reference to the spreadsheet grid containing all cells\n/// * `row` - The row index of the cell containing this function\n/// * `col` - The column index of the cell containing this function\n///\n/// # Returns\n///\n/// * `Some(isize)` - The minimum value found in the specified range if all cells are valid\n/// * `None` - If any cell in the range is invalid or has an error\n///\n/// # Details\n///\n/// Iterates through all cells in the range specified by the cell's function parameters\n/// (which should be Value::Cell coordinates for the top-left and bottom-right corners)\n/// and returns the minimum value. If any cell in the range is invalid, returns None.\npub fn min_function(grid: \u0026mut Grid, row: usize, col: usize) -\u003e Option\u003cisize\u003e {\n    let mut min_val = isize::MAX;\n    let node = grid.get_node(row, col);\n    if let Some(Value::Oper(Some(box1), Some(box2), _oper)) = node.function.clone() {\n        if let (Value::Cell(row1, col1), Value::Cell(row2, col2)) = (*box1, *box2) {\n            for i in row1..=row2 {\n                for j in col1..=col2 {\n                    let current_node = grid.get_node(i, j);\n                    if !current_node.valid {\n                        return None;\n                    } else if current_node.node_value \u003c min_val {\n                        min_val = current_node.node_value;\n                    }\n                }\n            }\n        }\n    }\n    Some(min_val)\n}\n\n/// Calculates the sum of all values in a range of cells.\n///\n/// # Arguments\n///\n/// * `grid` - A mutable reference to the spreadsheet grid containing all cells\n/// * `row` - The row index of the cell containing this function\n/// * `col` - The column index of the cell containing this function\n///\n/// # Returns\n///\n/// * `Some(isize)` - The sum of all values in the specified range if all cells are valid\n/// * `None` - If any cell in the range is invalid or has an error\n///\n/// # Details\n///\n/// Iterates through all cells in the range specified by the cell's function parameters\n/// (which should be Value::Cell coordinates for the top-left and bottom-right corners)\n/// and adds their values. If any cell in the range is invalid, returns None.\npub fn sum_function(grid: \u0026mut Grid, row: usize, col: usize) -\u003e Option\u003cisize\u003e {\n    let mut sum_val = 0;\n    let node = grid.get_node(row, col);\n    if let Some(Value::Oper(Some(box1), Some(box2), _oper)) = node.function.clone() {\n        if let (Value::Cell(row1, col1), Value::Cell(row2, col2)) = (*box1, *box2) {\n            for i in row1..=row2 {\n                for j in col1..=col2 {\n                    let current_node = grid.get_node(i, j);\n                    if !current_node.valid {\n                        return None;\n                    } else {\n                        sum_val += current_node.node_value;\n                    }\n                }\n            }\n        }\n    }\n    Some(sum_val)\n}\n\n/// Calculates the average (mean) of all values in a range of cells.\n///\n/// # Arguments\n///\n/// * `grid` - A mutable reference to the spreadsheet grid containing all cells\n/// * `row` - The row index of the cell containing this function\n/// * `col` - The column index of the cell containing this function\n///\n/// # Returns\n///\n/// * `Some(isize)` - The average of all values in the specified range if all cells are valid\n/// * `None` - If any cell in the range is invalid or if the range is empty\n///\n/// # Details\n///\n/// Iterates through all cells in the range, adds their values, and divides by the count.\n/// Returns None if any cell is invalid or if the range is empty (to prevent division by zero).\n/// The result is truncated to an integer (as it returns isize).\npub fn avg_function(grid: \u0026mut Grid, row: usize, col: usize) -\u003e Option\u003cisize\u003e {\n    let mut sum_val = 0;\n    let mut count = 0;\n    let node = grid.get_node(row, col);\n    if let Some(Value::Oper(Some(box1), Some(box2), _oper)) = node.function.clone() {\n        if let (Value::Cell(row1, col1), Value::Cell(row2, col2)) = (*box1, *box2) {\n            for i in row1..=row2 {\n                for j in col1..=col2 {\n                    let current_node = grid.get_node(i, j);\n                    if !current_node.valid {\n                        return None;\n                    }\n                    sum_val += current_node.node_value;\n                    count += 1;\n                }\n            }\n        }\n    }\n    if count == 0 {\n        None\n    } else {\n        Some(sum_val / count)\n    }\n}\n\n/// Calculates the standard deviation of values in a range of cells.\n///\n/// # Arguments\n///\n/// * `grid` - A mutable reference to the spreadsheet grid containing all cells\n/// * `row` - The row index of the cell containing this function\n/// * `col` - The column index of the cell containing this function\n///\n/// # Returns\n///\n/// * `Some(isize)` - The standard deviation of values in the specified range if all cells are valid\n/// * `None` - If any cell in the range is invalid or the calculation cannot be performed\n/// * `Some(0)` - If the range is empty\n///\n/// # Details\n///\n/// Uses a two-pass algorithm:\n/// 1. First pass: Calculate the mean of all values\n/// 2. Second pass: Calculate the sum of squared differences from the mean\n///\n/// Then divides the sum of squared differences by the count to get the variance,\n/// takes the square root, and rounds to the nearest integer.\npub fn std_dev_function(grid: \u0026mut Grid, row: usize, col: usize) -\u003e Option\u003cisize\u003e {\n    let node = grid.get_node(row, col);\n    if let Some(Value::Oper(Some(box1), Some(box2), _)) = node.function.clone() {\n        if let (Value::Cell(row1, col1), Value::Cell(row2, col2)) = (*box1, *box2) {\n            let mut sum = 0f64;\n            let mut count = 0;\n\n            // First pass: sum and count valid nodes\n            for i in row1..=row2 {\n                for j in col1..=col2 {\n                    let node_ref = grid.get_node(i, j);\n                    if node_ref.valid {\n                        sum += node_ref.node_value as f64;\n                        count += 1;\n                    } else {\n                        return None;\n                    }\n                }\n            }\n\n            if count == 0 {\n                return Some(0);\n            }\n\n            let mean = sum / count as f64;\n\n            // Second pass: compute variance\n            let mut variance = 0f64;\n            for i in row1..=row2 {\n                for j in col1..=col2 {\n                    let node_ref = grid.get_node(i, j);\n                    if !node_ref.valid {\n                        return None;\n                    }\n                    let val = node_ref.node_value as f64;\n                    variance += (val - mean) * (val - mean);\n                }\n            }\n\n            let stdev = (variance / count as f64).sqrt().round() as isize;\n            return Some(stdev);\n        }\n    }\n    None\n}\n\n/// Performs addition of two values.\n///\n/// # Arguments\n///\n/// * `grid` - A mutable reference to the spreadsheet grid containing all cells\n/// * `row` - The row index of the cell containing this function\n/// * `col` - The column index of the cell containing this function\n///\n/// # Returns\n///\n/// * `Some(isize)` - The result of adding the two values if both are valid\n/// * `None` - If either value is invalid or an error occurs\n///\n/// # Details\n///\n/// Extracts the two operands from the cell's function (which can be cell references or constants),\n/// verifies they are valid, and returns their sum.\npub fn add(grid: \u0026mut Grid, row: usize, col: usize) -\u003e Option\u003cisize\u003e {\n    let node = grid.get_node(row, col);\n    if let Some(Value::Oper(Some(box1), Some(box2), _oper)) = node.function.clone() {\n        let val1 = match *box1 {\n            Value::Cell(row, col) =\u003e {\n                let node = grid.get_node(row, col);\n                if !node.valid {\n                    return None;\n                }\n                node.node_value\n            }\n            Value::Const(c) =\u003e c,\n            _ =\u003e return None,\n        };\n\n        let val2 = match *box2 {\n            Value::Cell(row, col) =\u003e {\n                let node = grid.get_node(row, col);\n                if !node.valid {\n                    return None;\n                }\n                node.node_value\n            }\n            Value::Const(c) =\u003e c,\n            _ =\u003e return None,\n        };\n\n        Some(val1 + val2)\n    } else {\n        None\n    }\n}\n\n/// Performs subtraction of two values.\n///\n/// # Arguments\n///\n/// * `grid` - A mutable reference to the spreadsheet grid containing all cells\n/// * `row` - The row index of the cell containing this function\n/// * `col` - The column index of the cell containing this function\n///\n/// # Returns\n///\n/// * `Some(isize)` - The result of subtracting the second value from the first if both are valid\n/// * `None` - If either value is invalid or an error occurs\n///\n/// # Details\n///\n/// Extracts the two operands from the cell's function (which can be cell references or constants),\n/// verifies they are valid, and returns the result of subtracting the second from the first.\npub fn sub(grid: \u0026mut Grid, row: usize, col: usize) -\u003e Option\u003cisize\u003e {\n    let node = grid.get_node(row, col);\n    if let Some(Value::Oper(Some(box1), Some(box2), _oper)) = node.function.clone() {\n        let val1 = match *box1 {\n            Value::Cell(row, col) =\u003e {\n                let node = grid.get_node(row, col);\n                if !node.valid {\n                    return None;\n                }\n                node.node_value\n            }\n            Value::Const(c) =\u003e c,\n            _ =\u003e return None,\n        };\n\n        let val2 = match *box2 {\n            Value::Cell(row, col) =\u003e {\n                let node = grid.get_node(row, col);\n                if !node.valid {\n                    return None;\n                }\n                node.node_value\n            }\n            Value::Const(c) =\u003e c,\n            _ =\u003e return None,\n        };\n\n        Some(val1 - val2)\n    } else {\n        None\n    }\n}\n\n/// Performs multiplication of two values.\n///\n/// # Arguments\n///\n/// * `grid` - A mutable reference to the spreadsheet grid containing all cells\n/// * `row` - The row index of the cell containing this function\n/// * `col` - The column index of the cell containing this function\n///\n/// # Returns\n///\n/// * `Some(isize)` - The result of multiplying the two values if both are valid\n/// * `None` - If either value is invalid or an error occurs\n///\n/// # Details\n///\n/// Extracts the two operands from the cell's function (which can be cell references or constants),\n/// verifies they are valid, and returns their product.\npub fn mul(grid: \u0026mut Grid, row: usize, col: usize) -\u003e Option\u003cisize\u003e {\n    let node = grid.get_node(row, col);\n    if let Some(Value::Oper(Some(box1), Some(box2), _oper)) = node.function.clone() {\n        let val1 = match *box1 {\n            Value::Cell(row, col) =\u003e {\n                let node = grid.get_node(row, col);\n                if !node.valid {\n                    return None;\n                }\n                node.node_value\n            }\n            Value::Const(c) =\u003e c,\n            _ =\u003e return None,\n        };\n\n        let val2 = match *box2 {\n            Value::Cell(row, col) =\u003e {\n                let node = grid.get_node(row, col);\n                if !node.valid {\n                    return None;\n                }\n                node.node_value\n            }\n            Value::Const(c) =\u003e c,\n            _ =\u003e return None,\n        };\n\n        Some(val1 * val2)\n    } else {\n        None\n    }\n}\n\n/// Performs division of two values.\n///\n/// # Arguments\n///\n/// * `grid` - A mutable reference to the spreadsheet grid containing all cells\n/// * `row` - The row index of the cell containing this function\n/// * `col` - The column index of the cell containing this function\n///\n/// # Returns\n///\n/// * `Some(isize)` - The result of dividing the first value by the second if both are valid\n/// * `None` - If either value is invalid, the divisor is zero, or another error occurs\n///\n/// # Details\n///\n/// Extracts the two operands from the cell's function (which can be cell references or constants),\n/// verifies they are valid, checks that the divisor is not zero, and returns the result of\n/// dividing the first value by the second.\npub fn div(grid: \u0026mut Grid, row: usize, col: usize) -\u003e Option\u003cisize\u003e {\n    let node = grid.get_node(row, col);\n    if let Some(Value::Oper(Some(box1), Some(box2), _oper)) = node.function.clone() {\n        let val1 = match *box1 {\n            Value::Cell(row, col) =\u003e {\n                let node = grid.get_node(row, col);\n                if !node.valid {\n                    return None;\n                }\n                node.node_value\n            }\n            Value::Const(c) =\u003e c,\n            _ =\u003e return None,\n        };\n\n        let val2 = match *box2 {\n            Value::Cell(row, col) =\u003e {\n                let node = grid.get_node(row, col);\n                if !node.valid {\n                    return None;\n                }\n                node.node_value\n            }\n            Value::Const(c) =\u003e c,\n            _ =\u003e return None,\n        };\n\n        if val2 != 0 {\n            Some(val1 / val2)\n        } else {\n            None // only this case possible\n        }\n    } else {\n        None\n    }\n}\n\n/// Performs a sleep operation, pausing execution for a specified number of seconds.\n///\n/// # Arguments\n///\n/// * `grid` - A mutable reference to the spreadsheet grid containing all cells\n/// * `row` - The row index of the cell containing this function\n/// * `col` - The column index of the cell containing this function\n///\n/// # Returns\n///\n/// * `Some(isize)` - The value that was slept for (in seconds) if valid\n/// * `None` - If the sleep value is invalid or an error occurs\n///\n/// # Details\n///\n/// Extracts the sleep duration from the cell's function (which can be a cell reference or constant),\n/// verifies it is valid, sleeps for that many seconds, and then returns the same value.\npub fn slp(grid: \u0026mut Grid, row: usize, col: usize) -\u003e Option\u003cisize\u003e {\n    let node = grid.get_node(row, col);\n    if let Some(Value::Oper(Some(box1), Some(_box2), _oper)) = node.function.clone() {\n        // check value1\n        let val1 = match *box1 {\n            Value::Cell(row, col) =\u003e {\n                let node = grid.get_node(row, col);\n                if !node.valid {\n                    return None;\n                }\n                node.node_value\n            }\n            Value::Const(c) =\u003e c,\n            _ =\u003e return None,\n        };\n        // sleep for that amount of time\n        std::thread::sleep(std::time::Duration::from_secs(val1 as u64));\n        // return value to be set to the cell\n        Some(val1)\n    } else {\n        None\n    }\n}\n\n/// Sets a constant value in a cell.\n///\n/// # Arguments\n///\n/// * `grid` - A mutable reference to the spreadsheet grid containing all cells\n/// * `row` - The row index of the cell containing this function\n/// * `col` - The column index of the cell containing this function\n///\n/// # Returns\n///\n/// * `Some(isize)` - The constant value if valid\n/// * `None` - If the value is invalid or an error occurs\n///\n/// # Details\n///\n/// Extracts the constant value from the cell's function (which can be a cell reference or constant),\n/// verifies it is valid, and returns the value to be assigned to the cell.\npub fn cons(grid: \u0026mut Grid, row: usize, col: usize) -\u003e Option\u003cisize\u003e {\n    // let sleep_time = 0;\n    // sleep_time\n    let node = grid.get_node(row, col);\n    if let Some(Value::Oper(Some(box1), Some(_box2), _oper)) = node.function.clone() {\n        // check value1\n        let val1 = match *box1 {\n            Value::Cell(row, col) =\u003e {\n                let node = grid.get_node(row, col);\n                if !node.valid {\n                    return None;\n                }\n                node.node_value\n            }\n            Value::Const(c) =\u003e c,\n            _ =\u003e return None,\n        };\n        // return value to be set to the cell\n        Some(val1)\n    } else {\n        None\n    }\n}\n// slp and cons -\u003e left\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":5}},{"line":25,"address":[],"length":0,"stats":{"Line":5}},{"line":26,"address":[],"length":0,"stats":{"Line":5}},{"line":27,"address":[],"length":0,"stats":{"Line":9}},{"line":28,"address":[],"length":0,"stats":{"Line":8}},{"line":29,"address":[],"length":0,"stats":{"Line":13}},{"line":30,"address":[],"length":0,"stats":{"Line":27}},{"line":31,"address":[],"length":0,"stats":{"Line":18}},{"line":32,"address":[],"length":0,"stats":{"Line":18}},{"line":33,"address":[],"length":0,"stats":{"Line":1}},{"line":34,"address":[],"length":0,"stats":{"Line":33}},{"line":35,"address":[],"length":0,"stats":{"Line":16}},{"line":41,"address":[],"length":0,"stats":{"Line":4}},{"line":62,"address":[],"length":0,"stats":{"Line":4}},{"line":63,"address":[],"length":0,"stats":{"Line":4}},{"line":64,"address":[],"length":0,"stats":{"Line":4}},{"line":65,"address":[],"length":0,"stats":{"Line":8}},{"line":66,"address":[],"length":0,"stats":{"Line":8}},{"line":67,"address":[],"length":0,"stats":{"Line":13}},{"line":68,"address":[],"length":0,"stats":{"Line":27}},{"line":69,"address":[],"length":0,"stats":{"Line":18}},{"line":70,"address":[],"length":0,"stats":{"Line":18}},{"line":71,"address":[],"length":0,"stats":{"Line":1}},{"line":72,"address":[],"length":0,"stats":{"Line":21}},{"line":73,"address":[],"length":0,"stats":{"Line":4}},{"line":79,"address":[],"length":0,"stats":{"Line":3}},{"line":100,"address":[],"length":0,"stats":{"Line":5}},{"line":101,"address":[],"length":0,"stats":{"Line":5}},{"line":102,"address":[],"length":0,"stats":{"Line":5}},{"line":103,"address":[],"length":0,"stats":{"Line":10}},{"line":104,"address":[],"length":0,"stats":{"Line":10}},{"line":105,"address":[],"length":0,"stats":{"Line":14}},{"line":106,"address":[],"length":0,"stats":{"Line":27}},{"line":107,"address":[],"length":0,"stats":{"Line":18}},{"line":108,"address":[],"length":0,"stats":{"Line":18}},{"line":109,"address":[],"length":0,"stats":{"Line":2}},{"line":111,"address":[],"length":0,"stats":{"Line":16}},{"line":117,"address":[],"length":0,"stats":{"Line":3}},{"line":138,"address":[],"length":0,"stats":{"Line":5}},{"line":139,"address":[],"length":0,"stats":{"Line":5}},{"line":140,"address":[],"length":0,"stats":{"Line":5}},{"line":141,"address":[],"length":0,"stats":{"Line":5}},{"line":142,"address":[],"length":0,"stats":{"Line":10}},{"line":143,"address":[],"length":0,"stats":{"Line":10}},{"line":144,"address":[],"length":0,"stats":{"Line":14}},{"line":145,"address":[],"length":0,"stats":{"Line":27}},{"line":146,"address":[],"length":0,"stats":{"Line":18}},{"line":147,"address":[],"length":0,"stats":{"Line":18}},{"line":148,"address":[],"length":0,"stats":{"Line":2}},{"line":150,"address":[],"length":0,"stats":{"Line":16}},{"line":151,"address":[],"length":0,"stats":{"Line":16}},{"line":156,"address":[],"length":0,"stats":{"Line":3}},{"line":157,"address":[],"length":0,"stats":{"Line":1}},{"line":159,"address":[],"length":0,"stats":{"Line":2}},{"line":185,"address":[],"length":0,"stats":{"Line":5}},{"line":186,"address":[],"length":0,"stats":{"Line":5}},{"line":187,"address":[],"length":0,"stats":{"Line":10}},{"line":188,"address":[],"length":0,"stats":{"Line":10}},{"line":189,"address":[],"length":0,"stats":{"Line":5}},{"line":190,"address":[],"length":0,"stats":{"Line":5}},{"line":193,"address":[],"length":0,"stats":{"Line":14}},{"line":194,"address":[],"length":0,"stats":{"Line":27}},{"line":195,"address":[],"length":0,"stats":{"Line":18}},{"line":196,"address":[],"length":0,"stats":{"Line":34}},{"line":197,"address":[],"length":0,"stats":{"Line":16}},{"line":198,"address":[],"length":0,"stats":{"Line":16}},{"line":200,"address":[],"length":0,"stats":{"Line":2}},{"line":205,"address":[],"length":0,"stats":{"Line":3}},{"line":206,"address":[],"length":0,"stats":{"Line":1}},{"line":209,"address":[],"length":0,"stats":{"Line":2}},{"line":212,"address":[],"length":0,"stats":{"Line":2}},{"line":213,"address":[],"length":0,"stats":{"Line":6}},{"line":214,"address":[],"length":0,"stats":{"Line":18}},{"line":215,"address":[],"length":0,"stats":{"Line":12}},{"line":216,"address":[],"length":0,"stats":{"Line":12}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":12}},{"line":220,"address":[],"length":0,"stats":{"Line":12}},{"line":224,"address":[],"length":0,"stats":{"Line":2}},{"line":225,"address":[],"length":0,"stats":{"Line":2}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":12}},{"line":249,"address":[],"length":0,"stats":{"Line":12}},{"line":250,"address":[],"length":0,"stats":{"Line":20}},{"line":251,"address":[],"length":0,"stats":{"Line":13}},{"line":252,"address":[],"length":0,"stats":{"Line":6}},{"line":253,"address":[],"length":0,"stats":{"Line":6}},{"line":254,"address":[],"length":0,"stats":{"Line":6}},{"line":255,"address":[],"length":0,"stats":{"Line":2}},{"line":257,"address":[],"length":0,"stats":{"Line":4}},{"line":259,"address":[],"length":0,"stats":{"Line":1}},{"line":260,"address":[],"length":0,"stats":{"Line":1}},{"line":263,"address":[],"length":0,"stats":{"Line":5}},{"line":264,"address":[],"length":0,"stats":{"Line":2}},{"line":265,"address":[],"length":0,"stats":{"Line":2}},{"line":266,"address":[],"length":0,"stats":{"Line":2}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":2}},{"line":271,"address":[],"length":0,"stats":{"Line":3}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":4}},{"line":298,"address":[],"length":0,"stats":{"Line":6}},{"line":299,"address":[],"length":0,"stats":{"Line":6}},{"line":300,"address":[],"length":0,"stats":{"Line":12}},{"line":301,"address":[],"length":0,"stats":{"Line":12}},{"line":302,"address":[],"length":0,"stats":{"Line":5}},{"line":303,"address":[],"length":0,"stats":{"Line":5}},{"line":304,"address":[],"length":0,"stats":{"Line":5}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":5}},{"line":309,"address":[],"length":0,"stats":{"Line":1}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":4}},{"line":314,"address":[],"length":0,"stats":{"Line":4}},{"line":315,"address":[],"length":0,"stats":{"Line":4}},{"line":316,"address":[],"length":0,"stats":{"Line":4}},{"line":317,"address":[],"length":0,"stats":{"Line":2}},{"line":319,"address":[],"length":0,"stats":{"Line":2}},{"line":321,"address":[],"length":0,"stats":{"Line":2}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":6}},{"line":349,"address":[],"length":0,"stats":{"Line":6}},{"line":350,"address":[],"length":0,"stats":{"Line":12}},{"line":351,"address":[],"length":0,"stats":{"Line":10}},{"line":352,"address":[],"length":0,"stats":{"Line":5}},{"line":353,"address":[],"length":0,"stats":{"Line":5}},{"line":354,"address":[],"length":0,"stats":{"Line":5}},{"line":355,"address":[],"length":0,"stats":{"Line":2}},{"line":357,"address":[],"length":0,"stats":{"Line":3}},{"line":359,"address":[],"length":0,"stats":{"Line":1}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":4}},{"line":364,"address":[],"length":0,"stats":{"Line":2}},{"line":365,"address":[],"length":0,"stats":{"Line":2}},{"line":366,"address":[],"length":0,"stats":{"Line":2}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":2}},{"line":371,"address":[],"length":0,"stats":{"Line":2}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":7}},{"line":400,"address":[],"length":0,"stats":{"Line":7}},{"line":401,"address":[],"length":0,"stats":{"Line":14}},{"line":402,"address":[],"length":0,"stats":{"Line":14}},{"line":403,"address":[],"length":0,"stats":{"Line":6}},{"line":404,"address":[],"length":0,"stats":{"Line":6}},{"line":405,"address":[],"length":0,"stats":{"Line":6}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":6}},{"line":410,"address":[],"length":0,"stats":{"Line":1}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":5}},{"line":415,"address":[],"length":0,"stats":{"Line":4}},{"line":416,"address":[],"length":0,"stats":{"Line":4}},{"line":417,"address":[],"length":0,"stats":{"Line":4}},{"line":418,"address":[],"length":0,"stats":{"Line":2}},{"line":420,"address":[],"length":0,"stats":{"Line":2}},{"line":422,"address":[],"length":0,"stats":{"Line":3}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":4}},{"line":429,"address":[],"length":0,"stats":{"Line":1}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":453,"address":[],"length":0,"stats":{"Line":5}},{"line":454,"address":[],"length":0,"stats":{"Line":5}},{"line":455,"address":[],"length":0,"stats":{"Line":10}},{"line":457,"address":[],"length":0,"stats":{"Line":8}},{"line":458,"address":[],"length":0,"stats":{"Line":4}},{"line":459,"address":[],"length":0,"stats":{"Line":4}},{"line":460,"address":[],"length":0,"stats":{"Line":4}},{"line":461,"address":[],"length":0,"stats":{"Line":2}},{"line":463,"address":[],"length":0,"stats":{"Line":2}},{"line":465,"address":[],"length":0,"stats":{"Line":1}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":471,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":494,"address":[],"length":0,"stats":{"Line":40}},{"line":497,"address":[],"length":0,"stats":{"Line":40}},{"line":498,"address":[],"length":0,"stats":{"Line":80}},{"line":500,"address":[],"length":0,"stats":{"Line":79}},{"line":501,"address":[],"length":0,"stats":{"Line":2}},{"line":502,"address":[],"length":0,"stats":{"Line":2}},{"line":503,"address":[],"length":0,"stats":{"Line":2}},{"line":504,"address":[],"length":0,"stats":{"Line":1}},{"line":506,"address":[],"length":0,"stats":{"Line":1}},{"line":508,"address":[],"length":0,"stats":{"Line":38}},{"line":509,"address":[],"length":0,"stats":{"Line":0}},{"line":512,"address":[],"length":0,"stats":{"Line":0}},{"line":514,"address":[],"length":0,"stats":{"Line":0}}],"covered":167,"coverable":194},{"path":["/","Users","yuvikachaudhary","Desktop","Semester 4","COP290","spreadsheet_rust","src","extension","backend","graph.rs"],"content":"#![allow(dead_code)]\n//topo sort\n//node\n//adding\n//breaking\n//cycle\n//reset\nuse crate::extension::backend::backend::Grid;\nuse crate::extension::common::Operation;\nuse crate::extension::common::Value;\nuse serde::{Deserialize, Serialize};\n///Data structure for strong data of each cell\n/// Contains Dependency list, value, function and a few booleans\n/// `Node` struct represents a cell in the spreadsheet with its dependencies\n///\n/// Stores the cell's value, function, and dependency information\n///\n/// # Fields\n///\n/// * `dependents` - Vector of cells that depend on this cell\n/// * `node_value` - Current value of the cell\n/// * `function` - Function/operation assigned to this cell\n/// * `visited` - Flag used during graph traversal algorithms\n/// * `valid` - Flag indicating whether the cell value is valid\n\n#[derive(Serialize, Deserialize, Debug, Clone)]\n//clone trait used due to vec![vec![Cell::new(0); columns]; rows]\npub struct Node {\n    pub dependents: Vec\u003cValue\u003e,\n    pub node_value: isize,\n    pub function: Option\u003cValue\u003e,\n    pub visited: bool,\n    pub valid: bool,\n}\n\nimpl Node {\n    ///Initialises a Node\n    pub fn new(val: isize) -\u003e Self {\n        Node {\n            dependents: Vec::new(),\n            node_value: val,\n            function: None,\n            visited: false,\n            valid: true,\n        }\n    }\n    pub fn get_node_value(\u0026self) -\u003e Option\u003cisize\u003e {\n        if self.valid {\n            Some(self.node_value)\n        } else {\n            None\n        }\n    }\n    pub fn remove_dep(\u0026mut self, cell: Value) {\n        self.dependents.retain(|x| x != \u0026cell);\n    }\n    pub fn add_dep(\u0026mut self, cell: Value) {\n        if !self.dependents.contains(\u0026cell) {\n            self.dependents.push(cell);\n        }\n    }\n    pub fn set_dependents(\u0026mut self, dependents: Vec\u003cValue\u003e) {\n        self.dependents = dependents;\n    }\n}\n\n// update_edges\n// has_cycle\n// get_sequence\n\n// flag -\u003e true: break previous dependencies\n/// Function to break edges concerned with target cell in the graph depending on flag\npub fn break_edges(grid: \u0026mut Grid, target: Value, func: Option\u003cValue\u003e, flag: bool) {\n    // break edges\n    let old_func: Option\u003cValue\u003e = if flag {\n        // break old dependencies (stored in grid)\n        grid.get_node(target.row(), target.col()).function.clone()\n    } else {\n        func\n    };\n    if let Some(Value::Oper(box1, box2, oper)) = old_func {\n        match oper {\n            Operation::Sum | Operation::Avg | Operation::Max | Operation::Min =\u003e {\n                if let Some(Value::Cell(row1, col1)) = box1.as_deref() {\n                    if let Some(Value::Cell(row2, col2)) = box2.as_deref() {\n                        for i in *row1..=*row2 {\n                            for j in *col1..=*col2 {\n                                let node = grid.get_node(i, j);\n                                node.remove_dep(target.clone());\n                            }\n                        }\n                    }\n                }\n            }\n            Operation::Add | Operation::Sub | Operation::Mul | Operation::Div =\u003e {\n                if let Some(boxed_val) = box1 {\n                    if let Value::Cell(row1, col1) = \u0026*boxed_val {\n                        let node1 = grid.get_node(*row1, *col1);\n                        node1.remove_dep(target.clone());\n                    }\n                }\n                if let Some(boxed_val) = box2 {\n                    if let Value::Cell(row1, col1) = \u0026*boxed_val {\n                        let node1 = grid.get_node(*row1, *col1);\n                        node1.remove_dep(target.clone());\n                    }\n                }\n            }\n            Operation::Cons | Operation::Slp =\u003e {\n                // C\n                if let Some(Value::Cell(row1, col1)) = box1.as_deref() {\n                    let node1 = grid.get_node(*row1, *col1);\n                    node1.remove_dep(target.clone());\n                }\n                // V -\u003e do nothing\n            }\n            _ =\u003e {}\n        }\n    }\n}\n\n// flag -\u003e true: add new dependencies\n/// Function to add edges concerned with target cell in the graph depending on flag\npub fn add_edges(grid: \u0026mut Grid, target: Value, func: Option\u003cValue\u003e, flag: bool) {\n    // add edges\n    let old_func: Option\u003cValue\u003e = if flag {\n        // add new dependencies\n        func\n    } else {\n        grid.get_node(target.row(), target.col()).function.clone()\n    };\n\n    if let Some(Value::Oper(box1, box2, oper)) = old_func {\n        match oper {\n            Operation::Sum | Operation::Avg | Operation::Max | Operation::Min =\u003e {\n                if let Some(Value::Cell(row1, col1)) = box1.as_deref() {\n                    if let Some(Value::Cell(row2, col2)) = box2.as_deref() {\n                        for i in *row1..=*row2 {\n                            for j in *col1..=*col2 {\n                                let node = grid.get_node(i, j);\n                                node.add_dep(target.clone());\n                            }\n                        }\n                    }\n                }\n            }\n            Operation::Add | Operation::Sub | Operation::Mul | Operation::Div =\u003e {\n                if let Some(boxed_val) = box1 {\n                    if let Value::Cell(row1, col1) = \u0026*boxed_val {\n                        let node1 = grid.get_node(*row1, *col1);\n                        node1.add_dep(target.clone());\n                    }\n                }\n                if let Some(boxed_val) = box2 {\n                    if let Value::Cell(row1, col1) = \u0026*boxed_val {\n                        let node1 = grid.get_node(*row1, *col1);\n                        node1.add_dep(target.clone());\n                    }\n                }\n            }\n            Operation::Cons | Operation::Slp =\u003e {\n                // C\n                if let Some(Value::Cell(row1, col1)) = box1.as_deref() {\n                    let node1 = grid.get_node(*row1, *col1);\n                    node1.add_dep(target.clone());\n                }\n                // V -\u003e do nothing\n            }\n            _ =\u003e {}\n        }\n    }\n}\n\n/// Updates the edges of the graph based on target and function values.\n/// flag is true when previous dependencies are to be broken and new dependecies are to be added\n/// flag is false when only new dependencies are to be added and previous dependencies are to be broken (Circular dependency case)\npub fn update_edges(grid: \u0026mut Grid, target: Value, func: Option\u003cValue\u003e, flag: bool) {\n    // so here in update edges -\u003e func will contain the 3 value tuple (new)\n    // target will always be a cell\n    if let Value::Cell(_, _) = target {\n        if let Some(Value::Oper(ref _box1, ref _box2, ref _oper)) = func {\n            // passing target row col to access the node in functions\n            break_edges(grid, target.clone(), func.clone(), flag);\n            add_edges(grid, target.clone(), func.clone(), flag);\n        }\n    }\n}\n\n/// Checks for circular dependency in graph using DFS\npub fn has_cycle(grid: \u0026mut Grid, target: Value) -\u003e bool {\n    let mut stack = vec![target.clone()];\n    let node = grid.get_node(target.row(), target.col());\n    node.visited = true;\n    while let Some(Value::Cell(row, col)) = stack.pop() {\n        let dependents = grid.get_node(row, col).dependents.clone();\n        for dep in dependents {\n            if let Value::Cell(dep_r, dep_c) = dep {\n                let dep_node = grid.get_node(dep_r, dep_c);\n                if dep_node.visited {\n                    // cycle detected\n                    reset_visited(grid, target.clone());\n                    return true;\n                } else {\n                    dep_node.visited = true;\n                    stack.push(dep);\n                }\n            }\n        }\n    }\n    reset_visited(grid, target.clone());\n    false\n}\n\n/// This function does dfs in order to efficiently reset visited flags to false\npub fn reset_visited(grid: \u0026mut Grid, start: Value) {\n    if let Value::Cell(row, col) = start {\n        let mut stack = vec![start];\n        grid.get_node(row, col).visited = false;\n\n        while let Some(Value::Cell(r, c)) = stack.pop() {\n            let dependents = grid.get_node(r, c).dependents.clone();\n\n            for dep in dependents {\n                if let Value::Cell(dep_r, dep_c) = dep {\n                    let dep_node = grid.get_node(dep_r, dep_c);\n                    if dep_node.visited {\n                        dep_node.visited = false;\n                        stack.push(dep);\n                    }\n                }\n            }\n        }\n    }\n}\n\n/// Returns the sequence of topological sort starting from target cell\npub fn get_sequence(grid: \u0026mut Grid, target: Value) -\u003e Vec\u003cValue\u003e {\n    let mut stack = Vec::new();\n    topological_sort(grid, target.clone(), \u0026mut stack);\n    stack.reverse();\n    reset_visited(grid, target.clone());\n    stack\n}\n\npub fn topological_sort(grid: \u0026mut Grid, target: Value, stack: \u0026mut Vec\u003cValue\u003e) {\n    if let Value::Cell(row, col) = target {\n        let node = grid.get_node(row, col);\n        if node.visited {\n            return;\n        }\n        node.visited = true;\n\n        for dep in node.dependents.clone() {\n            topological_sort(grid, dep, stack);\n            // if let Value::Cell(dep_row, dep_col) = dep {\n            //     topological_sort(grid, Value::Cell(dep_row, dep_col), stack);\n            // }\n        }\n        stack.push(target);\n    }\n}\n","traces":[{"line":38,"address":[],"length":0,"stats":{"Line":1459}},{"line":40,"address":[],"length":0,"stats":{"Line":1459}},{"line":47,"address":[],"length":0,"stats":{"Line":1427}},{"line":48,"address":[],"length":0,"stats":{"Line":1427}},{"line":49,"address":[],"length":0,"stats":{"Line":1417}},{"line":51,"address":[],"length":0,"stats":{"Line":10}},{"line":54,"address":[],"length":0,"stats":{"Line":17}},{"line":55,"address":[],"length":0,"stats":{"Line":47}},{"line":57,"address":[],"length":0,"stats":{"Line":75}},{"line":58,"address":[],"length":0,"stats":{"Line":149}},{"line":59,"address":[],"length":0,"stats":{"Line":74}},{"line":62,"address":[],"length":0,"stats":{"Line":2}},{"line":63,"address":[],"length":0,"stats":{"Line":2}},{"line":73,"address":[],"length":0,"stats":{"Line":65}},{"line":75,"address":[],"length":0,"stats":{"Line":130}},{"line":77,"address":[],"length":0,"stats":{"Line":62}},{"line":79,"address":[],"length":0,"stats":{"Line":3}},{"line":81,"address":[],"length":0,"stats":{"Line":20}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":2}},{"line":85,"address":[],"length":0,"stats":{"Line":2}},{"line":86,"address":[],"length":0,"stats":{"Line":3}},{"line":87,"address":[],"length":0,"stats":{"Line":10}},{"line":88,"address":[],"length":0,"stats":{"Line":4}},{"line":89,"address":[],"length":0,"stats":{"Line":4}},{"line":96,"address":[],"length":0,"stats":{"Line":14}},{"line":97,"address":[],"length":0,"stats":{"Line":7}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":14}},{"line":103,"address":[],"length":0,"stats":{"Line":4}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":2}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":67}},{"line":126,"address":[],"length":0,"stats":{"Line":134}},{"line":128,"address":[],"length":0,"stats":{"Line":66}},{"line":130,"address":[],"length":0,"stats":{"Line":1}},{"line":133,"address":[],"length":0,"stats":{"Line":134}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":16}},{"line":137,"address":[],"length":0,"stats":{"Line":16}},{"line":138,"address":[],"length":0,"stats":{"Line":32}},{"line":139,"address":[],"length":0,"stats":{"Line":80}},{"line":140,"address":[],"length":0,"stats":{"Line":28}},{"line":141,"address":[],"length":0,"stats":{"Line":28}},{"line":148,"address":[],"length":0,"stats":{"Line":34}},{"line":149,"address":[],"length":0,"stats":{"Line":17}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":34}},{"line":155,"address":[],"length":0,"stats":{"Line":13}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":44}},{"line":164,"address":[],"length":0,"stats":{"Line":2}},{"line":165,"address":[],"length":0,"stats":{"Line":2}},{"line":169,"address":[],"length":0,"stats":{"Line":2}},{"line":177,"address":[],"length":0,"stats":{"Line":62}},{"line":180,"address":[],"length":0,"stats":{"Line":62}},{"line":181,"address":[],"length":0,"stats":{"Line":124}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":28}},{"line":191,"address":[],"length":0,"stats":{"Line":28}},{"line":192,"address":[],"length":0,"stats":{"Line":28}},{"line":193,"address":[],"length":0,"stats":{"Line":28}},{"line":194,"address":[],"length":0,"stats":{"Line":97}},{"line":195,"address":[],"length":0,"stats":{"Line":36}},{"line":196,"address":[],"length":0,"stats":{"Line":55}},{"line":197,"address":[],"length":0,"stats":{"Line":11}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":3}},{"line":202,"address":[],"length":0,"stats":{"Line":3}},{"line":204,"address":[],"length":0,"stats":{"Line":8}},{"line":205,"address":[],"length":0,"stats":{"Line":8}},{"line":210,"address":[],"length":0,"stats":{"Line":25}},{"line":211,"address":[],"length":0,"stats":{"Line":25}},{"line":215,"address":[],"length":0,"stats":{"Line":87}},{"line":216,"address":[],"length":0,"stats":{"Line":174}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":287}},{"line":221,"address":[],"length":0,"stats":{"Line":100}},{"line":223,"address":[],"length":0,"stats":{"Line":132}},{"line":224,"address":[],"length":0,"stats":{"Line":16}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":13}},{"line":227,"address":[],"length":0,"stats":{"Line":13}},{"line":228,"address":[],"length":0,"stats":{"Line":13}},{"line":237,"address":[],"length":0,"stats":{"Line":58}},{"line":238,"address":[],"length":0,"stats":{"Line":58}},{"line":239,"address":[],"length":0,"stats":{"Line":58}},{"line":240,"address":[],"length":0,"stats":{"Line":58}},{"line":241,"address":[],"length":0,"stats":{"Line":58}},{"line":242,"address":[],"length":0,"stats":{"Line":58}},{"line":245,"address":[],"length":0,"stats":{"Line":64}},{"line":246,"address":[],"length":0,"stats":{"Line":128}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":64}},{"line":253,"address":[],"length":0,"stats":{"Line":10}},{"line":254,"address":[],"length":0,"stats":{"Line":5}},{"line":259,"address":[],"length":0,"stats":{"Line":64}}],"covered":86,"coverable":109},{"path":["/","Users","yuvikachaudhary","Desktop","Semester 4","COP290","spreadsheet_rust","src","extension","backend","mod.rs"],"content":"#![allow(clippy::module_inception)]\npub mod backend;\npub mod functions;\npub mod graph;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","yuvikachaudhary","Desktop","Semester 4","COP290","spreadsheet_rust","src","extension","common.rs"],"content":"use serde::{Deserialize, Serialize};\n\n/// Represents a value that can appear in a spreadsheet.\n//Clone required for `Vec\u003cValue\u003e`(in graph.rs) to implement `Clone`\n#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]\npub enum Value {\n    Cell(usize, usize),\n    Const(isize),\n    Oper(Option\u003cBox\u003cValue\u003e\u003e, Option\u003cBox\u003cValue\u003e\u003e, Operation), //value1 and value2, and the operation or command, respectively\n}\n\nimpl Value {\n    /// return row of Cell\n    pub fn row(\u0026self) -\u003e usize {\n        match self {\n            Value::Cell(row, _) =\u003e *row,\n            _ =\u003e 0,\n        }\n    }\n    /// return column of Cell\n    pub fn col(\u0026self) -\u003e usize {\n        match self {\n            Value::Cell(_, col) =\u003e *col,\n            _ =\u003e 0,\n        }\n    }\n\n    pub fn assign_row(\u0026mut self, new_row: usize) {\n        if let Value::Cell(row, _) = self {\n            *row = new_row;\n        }\n    }\n\n    pub fn assign_col(\u0026mut self, new_col: usize) {\n        if let Value::Cell(_, col) = self {\n            *col = new_col;\n        }\n    }\n}\n\n#[derive(Debug, Clone, PartialEq)]\n//Needed as Value has implemented a clone\n//Oper(Box\u003cValue\u003e, Box\u003cValue\u003e, Operation), //value1 and value2, and the operation or command, respectively\n//   |                                  ^^^^^^^^^ the trait `Clone` is not implemented for `Operation`\n#[derive(Serialize, Deserialize)]\npub enum Operation {\n    Cons,\n    Add,\n    Sub,\n    Mul,\n    Div,\n    Min,\n    Max,\n    Avg,\n    Sum,\n    Std,\n    Slp,\n    EnableOutput,\n    DisableOutput,\n    ScrollTo,\n    Left,\n    Right,\n    Up,\n    Down,\n    Quit,\n    Web(String),\n    Save(String),\n    Undo,\n    Redo,\n    WebStart,\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":379}},{"line":15,"address":[],"length":0,"stats":{"Line":379}},{"line":16,"address":[],"length":0,"stats":{"Line":378}},{"line":17,"address":[],"length":0,"stats":{"Line":1}},{"line":21,"address":[],"length":0,"stats":{"Line":379}},{"line":22,"address":[],"length":0,"stats":{"Line":379}},{"line":23,"address":[],"length":0,"stats":{"Line":378}},{"line":24,"address":[],"length":0,"stats":{"Line":1}},{"line":28,"address":[],"length":0,"stats":{"Line":10}},{"line":29,"address":[],"length":0,"stats":{"Line":19}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":10}},{"line":35,"address":[],"length":0,"stats":{"Line":19}},{"line":36,"address":[],"length":0,"stats":{"Line":0}}],"covered":12,"coverable":14},{"path":["/","Users","yuvikachaudhary","Desktop","Semester 4","COP290","spreadsheet_rust","src","extension","frontend","mod.rs"],"content":"pub mod terminal;\npub mod web;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","yuvikachaudhary","Desktop","Semester 4","COP290","spreadsheet_rust","src","extension","frontend","terminal.rs"],"content":"#![allow(dead_code)]\nuse crate::extension::common::Value;\nuse std::cmp;\nuse std::fs;\nuse std::io;\nuse std::io::Write;\nuse std::process::Command;\n\n//init_frontend(r, c) -\u003e init_backend(r, c), Print_grid(), run_counter(): returns void\n//print grid() -\u003e get_value(value::cell) : returns void\n//run_counter -\u003e while loop for argument, process_command(r,c, string), Print_grid() : return void\n//display_status\nuse crate::extension::backend::backend::*;\nuse std::time::{Duration, Instant};\n\n/// Terminal interface for the spreadsheet application.\n///\n/// This struct manages the user interface for the terminal version\n/// of the spreadsheet, handling display, user input, and interaction\n/// with the backend.\npub struct Frontend {\n    pub start: Value,\n    pub dimension: Value,\n    pub backend: Backend,\n    pub print_enabled: bool,\n}\n\n/// Converts a column number to an Excel-style column label.\n///\n/// # Arguments\n///\n/// * `j` - The column number (1-based index) to convert\n///\n/// # Returns\n///\n/// A String representation of the column (e.g., 1 -\u003e \"A\", 27 -\u003e \"AA\")\npub fn column_decoder(mut j: usize) -\u003e String {\n    let mut cc = Vec::new();\n    while j \u003e 0 {\n        j -= 1;\n        cc.push((b'A' + (j % 26) as u8) as char);\n        j /= 26;\n    }\n    cc.reverse();\n    cc.into_iter().collect()\n}\n\nimpl Frontend {\n    /// Displays the grid in a tabular format.\n    ///\n    /// Shows the current viewable area of the spreadsheet with row and column headers.\n    /// If print_enabled is set to false, this function returns without printing the grid.\n    pub fn print_grid(\u0026self) {\n        if !self.print_enabled {\n            return;\n        }\n        let location = self.start.clone();\n        let dimension = self.dimension.clone();\n        if let (Value::Cell(start_x, start_y), Value::Cell(rows, cols)) = (location, dimension) {\n            let max_x = cmp::min(9 + start_x, rows);\n            let max_y = cmp::min(9 + start_y, cols);\n            for i in start_x - 1..=max_x {\n                for j in start_y - 1..=max_y {\n                    if i == start_x - 1 \u0026\u0026 j == start_y - 1 {\n                        print!(\"{:\u003e12}\", \" \");\n                    } else if i == start_x - 1 {\n                        print!(\"{:\u003e12}\", column_decoder(j));\n                    } else if j == start_y - 1 {\n                        print!(\"{:\u003e12}\", i);\n                    } else {\n                        match self.backend.get_grid().get_node_value(i, j) {\n                            Some(value) =\u003e print!(\"{:\u003e12}\", value),\n                            None =\u003e print!(\"{:\u003e12}\", \"ERR\"),\n                        }\n                    }\n                }\n                println!();\n            }\n        } else {\n            eprintln!(\"Invalid location or dimension values provided.\");\n        }\n    }\n\n    pub fn init_frontend(rows: usize, columns: usize, path: \u0026str) -\u003e Self {\n        if path.is_empty() {\n            let backend = Backend::init_backend(rows, columns);\n            Frontend {\n                start: Value::Cell(1, 1),\n                dimension: Value::Cell(rows, columns),\n                backend,\n                print_enabled: true,\n            }\n        } else {\n            let backend = match Backend::deserial(path) {\n                Ok(backend) =\u003e backend,\n                Err(e) =\u003e {\n                    eprintln!(\"Failed to deserialize backend: {}\", e);\n                    Backend::init_backend(rows, columns)\n                }\n            };\n            let rows = backend.get_grid().get_row_size() - 1;\n            let columns = backend.get_grid().get_column_size() - 1;\n            Frontend {\n                start: Value::Cell(1, 1),\n                dimension: Value::Cell(rows, columns),\n                backend,\n                print_enabled: true,\n            }\n        }\n    }\n\n    /// Starts the frontend interface.\n    ///\n    /// Initializes the display with a success status and starts the command input loop.\n    pub fn run_frontend(\u0026mut self) {\n        // self.display(Status::Success, Duration::from_secs(0).as_secs_f64());\n        self.run_counter();\n    }\n\n    /// Executes actions based on status returned from the backend.\n    ///\n    /// # Arguments\n    ///\n    /// * `status` - The status returned from processing a command\n    ///\n    /// Handles navigation commands (up, down, left, right), display settings,\n    /// and custom commands like ScrollTo and Web.\n    pub fn execute_status(\u0026mut self, status: \u0026Status) {\n        match status {\n            Status::Left =\u003e {\n                if self.start.col() \u003e 10 {\n                    self.start.assign_col(self.start.col() - 10);\n                } else {\n                    self.start.assign_col(1);\n                }\n            }\n            Status::Right =\u003e {\n                if (self.start.col() as isize) \u003c (self.dimension.col() as isize) - 10 {\n                    self.start.assign_col(self.start.col() + 10);\n                } else {\n                    self.start.assign_col(self.dimension.col() - 9); //debug\n                }\n            }\n            Status::Up =\u003e {\n                if self.start.row() \u003e 10 {\n                    self.start.assign_row(self.start.row() - 10);\n                } else {\n                    self.start.assign_row(1);\n                }\n            }\n            Status::Down =\u003e {\n                if (self.start.row() as isize) \u003c (self.dimension.row() as isize) - 10 {\n                    self.start.assign_row(self.start.row() + 10);\n                } else {\n                    self.start.assign_row(self.dimension.row() - 9);\n                }\n            }\n            Status::PrintDisabled =\u003e {\n                self.print_enabled = false;\n            }\n            Status::PrintEnabled =\u003e {\n                self.print_enabled = true;\n            }\n            Status::ScrollTo(row, col) =\u003e {\n                self.start.assign_row(*row);\n                self.start.assign_col(*col);\n            }\n            Status::Web(path) =\u003e {\n                println!(\"Web path: {}\", path);\n                let contents = fs::read_to_string(path).expect(\"Failed to read file\");\n                fs::write(\"mysheet.json\", contents).expect(\"Failed to write to file\");\n                Command::new(\"trunk\")\n                    .arg(\"serve\")\n                    .arg(\"--open\")\n                    .arg(\"--port\")\n                    .arg(\"8000\")\n                    .env(\"LOAD\", \"1\")\n                    .spawn()\n                    .expect(\"Failed to start trunk\")\n                    .wait()\n                    .expect(\"Failed to wait for trunk process\");\n            }\n            Status::WebStart =\u003e {\n                let path = \"mysheet.json\";\n                if let Err(e) = self.backend.serial(path) {\n                    eprintln!(\"Failed to save backend: {}\", e);\n                } else {\n                    println!(\"Backend state saved to '{}'\", path);\n                }\n\n                // Now launch the web app\n                Command::new(\"trunk\")\n                    .arg(\"serve\")\n                    .arg(\"--open\")\n                    .arg(\"--port\")\n                    .arg(\"8000\")\n                    .env(\"LOAD\", \"1\") // Your web.rs already reads this\n                    .spawn()\n                    .expect(\"Failed to start trunk\")\n                    .wait()\n                    .expect(\"Failed to wait for trunk process\");\n            }\n            _ =\u003e (),\n        }\n    }\n\n    /// Displays the grid and status message with execution time.\n    ///\n    /// # Arguments\n    ///\n    /// * `status` - The status to display\n    /// * `elapsed_time` - Time taken to execute the command in seconds\n    ///\n    /// Prints the grid (if enabled) followed by a status message and prompt.\n    pub fn display(\u0026self, status: Status, elapsed_time: f64) {\n        self.print_grid();\n        match status {\n            Status::Success =\u003e print!(\"[{:.2}] (ok) \u003e \", elapsed_time),\n            Status::UnrecognizedCmd =\u003e print!(\"[{:.2}] (unrecognized command) \u003e \", elapsed_time),\n            Status::CircularDependency =\u003e print!(\"[{:.2}] (cycle not allowed) \u003e \", elapsed_time),\n            Status::PrintEnabled =\u003e print!(\"[{:.2}] (ok) \u003e \", elapsed_time),\n            Status::PrintDisabled =\u003e print!(\"[{:.2}] (ok) \u003e \", elapsed_time),\n            Status::ScrollTo(_, _) =\u003e print!(\"[{:.2}] (ok) \u003e \", elapsed_time),\n            Status::Up =\u003e print!(\"[{:.2}] (ok) \u003e \", elapsed_time),\n            Status::Down =\u003e print!(\"[{:.2}] (ok) \u003e \", elapsed_time),\n            Status::Left =\u003e print!(\"[{:.2}] (ok) \u003e \", elapsed_time),\n            Status::Right =\u003e print!(\"[{:.2}] (ok) \u003e \", elapsed_time),\n            _ =\u003e (),\n        }\n        io::stdout().flush().unwrap();\n    }\n\n    /// Main input loop for the terminal interface.\n    ///\n    /// Continuously reads commands from stdin, processes them through the backend,\n    /// updates the display based on status, and measures execution time.\n    /// Loop exits when a Quit status is received.\n    pub fn run_counter(\u0026mut self) {\n        let mut input = String::new();\n        let stdin = std::io::stdin();\n\n        loop {\n            input.clear();\n\n            if stdin.read_line(\u0026mut input).is_err() {\n                self.display(\n                    Status::UnrecognizedCmd,\n                    Duration::from_secs(0).as_secs_f64(),\n                );\n                continue;\n            }\n            let start_time = Instant::now();\n            let command = input.trim().to_string();\n            // let status = Status::Success;\n            // if command == (\"save\".to_string()) {\n            //     self.backend.serial(\"tester.json\").expect(\"Failed to save file\");\n\n            // } else {\n            let status =\n                self.backend\n                    .process_command(self.dimension.row(), self.dimension.col(), command);\n            // }\n            if status == Status::Quit {\n                break;\n            }\n            self.execute_status(\u0026status);\n            let elapsed_time = start_time.elapsed();\n            self.display(status, elapsed_time.as_secs_f64());\n        }\n    }\n}\n","traces":[{"line":37,"address":[],"length":0,"stats":{"Line":152}},{"line":38,"address":[],"length":0,"stats":{"Line":152}},{"line":39,"address":[],"length":0,"stats":{"Line":476}},{"line":40,"address":[],"length":0,"stats":{"Line":162}},{"line":41,"address":[],"length":0,"stats":{"Line":162}},{"line":42,"address":[],"length":0,"stats":{"Line":162}},{"line":44,"address":[],"length":0,"stats":{"Line":152}},{"line":45,"address":[],"length":0,"stats":{"Line":152}},{"line":53,"address":[],"length":0,"stats":{"Line":16}},{"line":54,"address":[],"length":0,"stats":{"Line":16}},{"line":55,"address":[],"length":0,"stats":{"Line":1}},{"line":57,"address":[],"length":0,"stats":{"Line":15}},{"line":58,"address":[],"length":0,"stats":{"Line":15}},{"line":59,"address":[],"length":0,"stats":{"Line":29}},{"line":60,"address":[],"length":0,"stats":{"Line":14}},{"line":61,"address":[],"length":0,"stats":{"Line":14}},{"line":62,"address":[],"length":0,"stats":{"Line":168}},{"line":63,"address":[],"length":0,"stats":{"Line":1848}},{"line":64,"address":[],"length":0,"stats":{"Line":1862}},{"line":65,"address":[],"length":0,"stats":{"Line":14}},{"line":66,"address":[],"length":0,"stats":{"Line":1834}},{"line":67,"address":[],"length":0,"stats":{"Line":140}},{"line":68,"address":[],"length":0,"stats":{"Line":1820}},{"line":69,"address":[],"length":0,"stats":{"Line":140}},{"line":71,"address":[],"length":0,"stats":{"Line":1400}},{"line":72,"address":[],"length":0,"stats":{"Line":1398}},{"line":73,"address":[],"length":0,"stats":{"Line":2}},{"line":77,"address":[],"length":0,"stats":{"Line":154}},{"line":80,"address":[],"length":0,"stats":{"Line":1}},{"line":84,"address":[],"length":0,"stats":{"Line":12}},{"line":85,"address":[],"length":0,"stats":{"Line":12}},{"line":86,"address":[],"length":0,"stats":{"Line":11}},{"line":88,"address":[],"length":0,"stats":{"Line":11}},{"line":89,"address":[],"length":0,"stats":{"Line":11}},{"line":94,"address":[],"length":0,"stats":{"Line":1}},{"line":95,"address":[],"length":0,"stats":{"Line":1}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":19}},{"line":129,"address":[],"length":0,"stats":{"Line":19}},{"line":131,"address":[],"length":0,"stats":{"Line":5}},{"line":132,"address":[],"length":0,"stats":{"Line":2}},{"line":134,"address":[],"length":0,"stats":{"Line":1}},{"line":138,"address":[],"length":0,"stats":{"Line":5}},{"line":139,"address":[],"length":0,"stats":{"Line":2}},{"line":141,"address":[],"length":0,"stats":{"Line":1}},{"line":145,"address":[],"length":0,"stats":{"Line":5}},{"line":146,"address":[],"length":0,"stats":{"Line":2}},{"line":148,"address":[],"length":0,"stats":{"Line":1}},{"line":152,"address":[],"length":0,"stats":{"Line":5}},{"line":153,"address":[],"length":0,"stats":{"Line":2}},{"line":155,"address":[],"length":0,"stats":{"Line":1}},{"line":158,"address":[],"length":0,"stats":{"Line":2}},{"line":159,"address":[],"length":0,"stats":{"Line":2}},{"line":161,"address":[],"length":0,"stats":{"Line":2}},{"line":162,"address":[],"length":0,"stats":{"Line":2}},{"line":164,"address":[],"length":0,"stats":{"Line":3}},{"line":165,"address":[],"length":0,"stats":{"Line":3}},{"line":166,"address":[],"length":0,"stats":{"Line":3}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":10}},{"line":216,"address":[],"length":0,"stats":{"Line":10}},{"line":217,"address":[],"length":0,"stats":{"Line":10}},{"line":218,"address":[],"length":0,"stats":{"Line":1}},{"line":219,"address":[],"length":0,"stats":{"Line":1}},{"line":220,"address":[],"length":0,"stats":{"Line":1}},{"line":221,"address":[],"length":0,"stats":{"Line":1}},{"line":222,"address":[],"length":0,"stats":{"Line":1}},{"line":223,"address":[],"length":0,"stats":{"Line":1}},{"line":224,"address":[],"length":0,"stats":{"Line":1}},{"line":225,"address":[],"length":0,"stats":{"Line":1}},{"line":226,"address":[],"length":0,"stats":{"Line":1}},{"line":227,"address":[],"length":0,"stats":{"Line":1}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":10}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}}],"covered":71,"coverable":111},{"path":["/","Users","yuvikachaudhary","Desktop","Semester 4","COP290","spreadsheet_rust","src","extension","frontend","web.rs"],"content":"use crate::extension::backend::backend::Backend;\n#[allow(unused_imports)]\nuse crate::extension::backend::backend::Valgrid;\n#[allow(unused_imports)]\nuse gloo_net::http::Request;\n#[allow(unused_imports)]\nuse serde_json;\n#[allow(unused_imports)]\nuse std::fs;\n#[allow(unused_imports)]\nuse std::ops::Range;\nuse std::rc::Rc;\nuse wasm_bindgen::closure::Closure;\n#[allow(unused_imports)]\nuse wasm_bindgen_futures::spawn_local;\nuse web_sys::HtmlSelectElement;\nuse yew::prelude::*;\n#[allow(unused_imports)]\nuse yew_chart::{\n    axis::{Axis, Orientation, Scale},\n    linear_axis_scale::LinearScale,\n    series::{BarType, Labeller, Series, Type},\n};\n// use yew::use_effect_with_deps;\nuse gloo::utils::document;\nuse plotters::prelude::*;\nuse plotters_canvas::CanvasBackend;\nuse wasm_bindgen::JsCast;\nuse web_sys::HtmlCanvasElement;\n#[allow(unused_imports)]\nuse web_sys::console::log_1;\n\n#[derive(Properties, PartialEq)]\npub struct CanvasChartProps {\n    pub data: Vec\u003c(f32, f32)\u003e,\n    pub chart_type: String,\n}\n\n#[function_component(CanvasChart)]\npub fn canvas_chart(props: \u0026CanvasChartProps) -\u003e Html {\n    let data = props.data.clone();\n    let chart_type = props.chart_type.clone();\n\n    use_effect(move || {\n        let canvas = document()\n            .get_element_by_id(\"plotters-canvas\")\n            .unwrap()\n            .dyn_into::\u003cHtmlCanvasElement\u003e()\n            .unwrap();\n\n        let backend = CanvasBackend::with_canvas_object(canvas).unwrap();\n        let drawing_area = backend.into_drawing_area();\n        drawing_area.fill(\u0026WHITE).unwrap();\n\n        // let y_range = data.iter().map(|(_, y)| *y);\n        // let y_min = y_range.clone().fold(f32::MAX, f32::min);\n        // let y_max = y_range.clone().fold(f32::MIN, f32::max);\n        // let y_max = if (y_max - y_min).abs() \u003c f32::EPSILON { y_max + 1.0 } else { y_max };\n\n        let mut y_min = 0.0;\n        let actual_min = data.iter().map(|(_, y)| *y).fold(f32::MAX, f32::min);\n        if actual_min \u003c 0.0 {\n            y_min = actual_min;\n        }\n\n        let mut y_max = data.iter().map(|(_, y)| *y).fold(f32::MIN, f32::max);\n\n        if (y_max - y_min).abs() \u003c f32::EPSILON {\n            y_max += 1.0;\n            y_min -= 1.0;\n        }\n\n        let mut chart = ChartBuilder::on(\u0026drawing_area)\n            .caption(\"Spreadsheet Chart\", (\"sans-serif\", 30).into_font())\n            .margin(20)\n            .set_label_area_size(LabelAreaPosition::Left, 40)\n            .set_label_area_size(LabelAreaPosition::Bottom, 40)\n            .build_cartesian_2d(0f32..(data.len() as f32), y_min..y_max)\n            .unwrap();\n\n        // for zero reference lines\n\n        // chart\n        //     .draw_series(LineSeries::new(\n        //         vec![(0.0, 0.0), (data.len() as f32, 0.0)],\n        //         \u0026BLACK,\n        //     ))\n        //     .unwrap();\n\n        chart\n            .configure_mesh()\n            .x_desc(\"Row Index\")\n            .y_desc(\"Value\")\n            .draw()\n            .unwrap();\n\n        // for drawing the line at bottom\n        chart\n            .draw_series(LineSeries::new(\n                vec![(0.0, 0.0), (data.len() as f32, 0.0)],\n                \u0026BLACK,\n            ))\n            .unwrap();\n\n        match chart_type.as_str() {\n            \"line\" =\u003e {\n                chart\n                    .draw_series(LineSeries::new(data.clone(), \u0026RED))\n                    .unwrap();\n            }\n            \"bar\" =\u003e {\n                chart\n                    .draw_series(data.iter().map(|(x, y)| {\n                        let (start, end) = if *y \u003e= 0.0 {\n                            ((*x, 0.0), (*x + 0.8, *y))\n                        } else {\n                            ((*x, *y), (*x + 0.8, 0.0))\n                        };\n                        Rectangle::new([start, end], RED.filled())\n                    }))\n                    .unwrap();\n            }\n\n            _ =\u003e {}\n        }\n\n        || ()\n    });\n\n    html! {\n        \u003ccanvas id=\"plotters-canvas\" width=\"800\" height=\"500\" style=\"border: 1px solid #ccc;\" /\u003e\n    }\n}\nfn number_to_column_label(num: usize) -\u003e String {\n    if num == 0 {\n        return String::new();\n    }\n\n    let mut result = String::new();\n    let mut n = num;\n\n    while n \u003e 0 {\n        n -= 1;\n        let c = ((n % 26) as u8 + b'A') as char;\n        result.insert(0, c);\n        n /= 26;\n    }\n\n    result\n}\nfn number_to_rgb(n: u32) -\u003e (u8, u8, u8) {\n    let r = (n \u003e\u003e 16) \u0026 0xFF;\n    let g = (n \u003e\u003e 8) \u0026 0xFF;\n    let b = n \u0026 0xFF;\n    (r as u8, g as u8, b as u8)\n}\n\n#[derive(Clone, PartialEq)]\nstruct SelectedCell {\n    row: usize,\n    col: usize,\n}\n\n#[derive(Clone, PartialEq)]\nstruct CellRange {\n    start: SelectedCell,\n    end: SelectedCell,\n}\n\n#[function_component(App)]\npub fn app() -\u003e Html {\n    let formula_input_ref = use_node_ref();\n    // let backend = Backend::init_backend(30, 182);\n    // let table = backend.get_valgrid();\n\n    // let table: Valgrid = {\n    //     let path = std::env::current_dir()\n    //         .map(|p| p.join(\"grid.json\"))\n    //         .unwrap_or_else(|_| \"grid.json\".into());\n    //     match fs::read_to_string(path) {\n    //         Ok(json) =\u003e match serde_json::from_str(\u0026json) {\n    //             Ok(grid) =\u003e grid,\n    //             Err(e) =\u003e {\n    //                 web_sys::console::error_1(\u0026format!(\"Failed to parse grid.json: {}\", e).into());\n    //                 // Return a default grid as fallback\n    //                 Valgrid {\n    //                     cells: vec![vec![0; 20]; 20],\n    //                     rows: 20,\n    //                     columns: 20\n    //                 }\n    //             }\n    //         },\n    //         Err(e) =\u003e {\n    //             web_sys::console::error_1(\u0026format!(\"Failed to read grid.json: {}\", e).into());\n    //             // Return a default grid as fallback\n    //             Valgrid {\n    //                 cells: vec![vec![0; 20]; 20],\n    //                 rows: 20,\n    //                 columns: 20\n    //             }\n    //         }\n    //     }\n    // };\n\n    // initialize backend table here\n\n    let max_rows: usize = option_env!(\"MY_ROWS\").unwrap_or(\"20\").parse().unwrap();\n    let max_cols: usize = option_env!(\"MY_COLS\").unwrap_or(\"20\").parse().unwrap();\n\n    let load_from_json: bool = option_env!(\"LOAD\")\n        .map(|v| v == \"1\" || v.eq_ignore_ascii_case(\"true\"))\n        .unwrap_or(false);\n    let backend = use_mut_ref(|| Backend::init_backend(max_rows, max_cols)); // debug i dont know the desired dimensions\n    // let table = backend.borrow().get_valgrid();\n\n    if load_from_json {\n        const CONTEXT: \u0026str = include_str!(\"../../../mysheet.json\");\n        web_sys::console::log_1(\u0026format!(\"Context: {}\", CONTEXT).into());\n\n        if let Ok(deserialized) = Backend::deserial_text(CONTEXT.to_string()) {\n            let backend = backend.clone();\n            *backend.borrow_mut() = deserialized;\n        } else {\n            web_sys::console::error_1(\u0026\"Failed to deserialize backend from context\".into());\n        }\n    }\n\n    let table = use_state(|| backend.borrow().get_valgrid());\n    let is_formula_building = use_state(|| false);\n    // let update_table = {\n    //     let backend = backend.clone();\n    //     let table = table.clone();\n    //     Callback::from(move |_| {\n    //         table.set(backend.borrow().get_valgrid());\n    //     })\n    // };\n\n    let rows1 = use_state(|| 1usize);\n    let rows2 = use_state(|| 10usize);\n    let cols1 = use_state(|| 1usize);\n    let cols2 = use_state(|| 10usize);\n    let row_range = *rows1..=(*rows2).min(table.rows - 1);\n    let col_range = *cols1..=(*cols2).min(table.columns - 1);\n    let selected_cell = use_state(|| None::\u003cSelectedCell\u003e);\n    let selected_range = use_state(|| None::\u003cCellRange\u003e);\n    let click_anchor = use_state(|| None::\u003cSelectedCell\u003e);\n    let selected_column_for_chart = use_state(|| None::\u003cusize\u003e);\n    let chart_type = use_state(|| \"line\".to_string());\n    let show_full_table = use_state(|| false);\n    let was_inside_table = use_mut_ref(|| false);\n\n    let was_inside_table_click = was_inside_table.clone(); // for on_cell_click\n    let was_inside_table_effect = was_inside_table.clone(); // for use_effect\n\n    let selected_range_label = {\n        if let Some(range) = \u0026*selected_range {\n            let start = \u0026range.start;\n            let end = \u0026range.end;\n            let label = format!(\n                \"{}{}:{}{}\",\n                number_to_column_label(start.col),\n                start.row,\n                number_to_column_label(end.col),\n                end.row\n            );\n            Some(label)\n        } else {\n            None\n        }\n    };\n\n    // i am not calling backend here because it needs a target cell to function\n    let selected_range_stats = if let Some(range) = \u0026*selected_range {\n        let (start_row, end_row) = if range.start.row \u003c= range.end.row {\n            (range.start.row, range.end.row)\n        } else {\n            (range.end.row, range.start.row)\n        };\n        let (start_col, end_col) = if range.start.col \u003c= range.end.col {\n            (range.start.col, range.end.col)\n        } else {\n            (range.end.col, range.start.col)\n        };\n\n        let mut values = vec![];\n\n        for r in start_row..=end_row {\n            for c in start_col..=end_col {\n                if let Some(Some(val)) = table.cells.get(r).and_then(|row| row.get(c)) {\n                    values.push(*val);\n                }\n            }\n        }\n\n        if !values.is_empty() {\n            let sum: isize = values.iter().sum();\n            let min = *values.iter().min().unwrap();\n            let max = *values.iter().max().unwrap();\n            let avg = sum as f64 / values.len() as f64;\n            let stdev = {\n                let mean = avg;\n                let variance: f64 = values\n                    .iter()\n                    .map(|v| {\n                        let diff = *v as f64 - mean;\n                        diff * diff\n                    })\n                    .sum::\u003cf64\u003e()\n                    / values.len() as f64;\n                variance.sqrt()\n            };\n\n            Some((sum, min, max, avg, stdev))\n        } else {\n            None\n        }\n    } else {\n        None\n    };\n\n    let status_message = use_state(|| \"\".to_string());\n    let formula_input = use_state(|| \"\".to_string());\n    let on_formula_input = {\n        let formula_input = formula_input.clone();\n        Callback::from(move |e: InputEvent| {\n            let input = e.target_unchecked_into::\u003cweb_sys::HtmlInputElement\u003e();\n            formula_input.set(input.value());\n        })\n    };\n\n    let on_submit_formula = {\n        let selected_cell = selected_cell.clone();\n        let formula_input = formula_input.clone();\n        let backend = backend.clone();\n        let table = table.clone(); // 🟢 \u003c- add this\n        let status_message = status_message.clone();\n\n        let is_formula_building = is_formula_building.clone();\n        Callback::from(move |_| {\n            if let Some(cell) = \u0026*selected_cell {\n                let col_label = number_to_column_label(cell.col);\n                let row_number = (cell.row).to_string();\n                let target_cell = format!(\"{}{}\", col_label, row_number);\n                let formula = (*formula_input).clone();\n                let command = format!(\"{}={}\", target_cell, formula);\n\n                let mut backend_ref = backend.borrow_mut();\n                //web_sys::console::log_1(\u0026format!(\"Selected cell row={}, col={} =\u003e {}\", cell.row, cell.col, target_cell).into());\n                // web_sys::console::log_1(\u0026format!(\"Command sent to process_command: {}\", command).into());\n                let status = backend_ref.process_command(100_usize, 100_usize, command.clone());\n                match status {\n                    crate::extension::backend::backend::Status::Success =\u003e {\n                        status_message.set(format!(\"{} updated successfully\", target_cell));\n                        table.set(backend_ref.get_valgrid());\n                    }\n                    crate::extension::backend::backend::Status::CircularDependency =\u003e {\n                        status_message\n                            .set(format!(\"Cycle detected in formula for {}\", target_cell));\n                    }\n                    crate::extension::backend::backend::Status::UnrecognizedCmd =\u003e {\n                        status_message.set((\"Unrecognized command\").to_string());\n                    }\n                    _ =\u003e {\n                        // Optional: silently ignore other statuses\n                        status_message.set(\"No update performed.\".to_string());\n                    }\n                }\n                // debug\n                // table.set(backend_ref.get_valgrid());\n\n                let updated_table = backend_ref.get_valgrid();\n\n                // TEMP DEBUG LOG\n                let row_idx = cell.row;\n                let col_idx = cell.col;\n                if row_idx \u003c updated_table.cells.len()\n                    \u0026\u0026 col_idx \u003c updated_table.cells[row_idx].len()\n                {\n                    let val = updated_table.cells[row_idx][col_idx];\n                    web_sys::console::log_1(\n                        \u0026format!(\"DEBUG: cell[{}, {}] = {:?}\", row_idx, col_idx, val).into(),\n                    );\n                } else {\n                    web_sys::console::log_1(\u0026\"DEBUG: selected cell out of bounds\".into());\n                }\n\n                table.set(updated_table);\n\n                formula_input.set(\"\".to_string());\n                is_formula_building.set(false);\n            }\n        })\n    };\n\n    let on_undo = {\n        let backend = backend.clone();\n        let table = table.clone();\n        let status_message = status_message.clone();\n\n        Callback::from(move |_| {\n            let mut backend_ref = backend.borrow_mut();\n            let status = backend_ref.process_command(100, 100, \"undo\".to_string());\n            if let crate::extension::backend::backend::Status::Success = status {\n                table.set(backend_ref.get_valgrid());\n                status_message.set(\"Undo successful\".to_string());\n            } else {\n                status_message.set(\"Nothing to undo\".to_string());\n            }\n        })\n    };\n\n    let on_redo = {\n        let backend = backend.clone();\n        let table = table.clone();\n        let status_message = status_message.clone();\n\n        Callback::from(move |_| {\n            let mut backend_ref = backend.borrow_mut();\n            let status = backend_ref.process_command(100, 100, \"redo\".to_string());\n            if let crate::extension::backend::backend::Status::Success = status {\n                table.set(backend_ref.get_valgrid());\n                status_message.set(\"Redo successful\".to_string());\n            } else {\n                status_message.set(\"Nothing to redo\".to_string());\n            }\n        })\n    };\n\n    let on_rows1_change = {\n        let rows1 = rows1.clone();\n        Callback::from(move |e: InputEvent| {\n            let input = e.target_unchecked_into::\u003cweb_sys::HtmlInputElement\u003e();\n            if let Ok(value) = input.value().parse::\u003cusize\u003e() {\n                rows1.set(value);\n            }\n        })\n    };\n\n    let on_rows2_change = {\n        let rows2 = rows2.clone();\n        Callback::from(move |e: InputEvent| {\n            let input = e.target_unchecked_into::\u003cweb_sys::HtmlInputElement\u003e();\n            if let Ok(value) = input.value().parse::\u003cusize\u003e() {\n                rows2.set(value);\n            }\n        })\n    };\n\n    let on_cols1_change = {\n        let cols1 = cols1.clone();\n        Callback::from(move |e: InputEvent| {\n            let input = e.target_unchecked_into::\u003cweb_sys::HtmlInputElement\u003e();\n            if let Ok(value) = input.value().parse::\u003cusize\u003e() {\n                cols1.set(value);\n            }\n        })\n    };\n\n    let on_cols2_change = {\n        let cols2 = cols2.clone();\n        Callback::from(move |e: InputEvent| {\n            let input = e.target_unchecked_into::\u003cweb_sys::HtmlInputElement\u003e();\n            if let Ok(value) = input.value().parse::\u003cusize\u003e() {\n                cols2.set(value);\n            }\n        })\n    };\n\n    let on_cell_click = {\n        let was_inside_table = was_inside_table_click.clone(); // capture clone\n        let formula_input = formula_input.clone();\n        let selected_cell = selected_cell.clone();\n        let selected_range = selected_range.clone();\n        let click_anchor = click_anchor.clone();\n        let is_formula_building = is_formula_building.clone();\n        let input_ref = formula_input_ref.clone();\n\n        Callback::from(move |cell: SelectedCell| {\n            if *is_formula_building {\n                let label = format!(\"{}{}\", number_to_column_label(cell.col), cell.row);\n\n                if let Some(input) = input_ref.cast::\u003cweb_sys::HtmlInputElement\u003e() {\n                    let mut current = (*formula_input).clone();\n                    let start = input\n                        .selection_start()\n                        .unwrap_or(None)\n                        .unwrap_or(current.len() as u32) as usize;\n                    let end = input\n                        .selection_end()\n                        .unwrap_or(None)\n                        .unwrap_or(current.len() as u32) as usize;\n\n                    current.replace_range(start..end, \u0026label);\n                    formula_input.set(current);\n\n                    let new_pos = (start + label.len()) as u32;\n                    input.set_selection_start(Some(new_pos)).ok();\n                    input.set_selection_end(Some(new_pos)).ok();\n                    input.focus().ok();\n                }\n            } else {\n                match click_anchor.as_ref() {\n                    None =\u003e {\n                        was_inside_table.borrow_mut().clone_from(\u0026true);\n                        selected_cell.set(Some(cell.clone()));\n                        selected_range.set(None);\n                        click_anchor.set(Some(cell));\n                    }\n                    Some(anchor) =\u003e {\n                        was_inside_table.borrow_mut().clone_from(\u0026true);\n                        selected_cell.set(Some(cell.clone()));\n                        selected_range.set(Some(CellRange {\n                            start: anchor.clone(),\n                            end: cell,\n                        }));\n                        click_anchor.set(None);\n                    }\n                }\n            }\n        })\n    };\n\n    #[allow(clippy::type_complexity)]\n    let get_column_data = {\n        let table = table.clone();\n        move |col: usize| -\u003e Vec\u003c(f32, f32, Option\u003cRc\u003cdyn Labeller\u003e\u003e)\u003e {\n            // Collect and normalize data\n            let mut values: Vec\u003c(f32, f32, Option\u003cRc\u003cdyn Labeller\u003e\u003e)\u003e = table\n                .cells\n                .iter()\n                .enumerate()\n                .take(20)\n                .map(|(i, row)| {\n                    let val = row.get(col).and_then(|v| *v).unwrap_or(0) as f32;\n                    (i as f32, val, None) // Ensure positive values\n                })\n                .collect();\n\n            // Handle edge case\n            if values.is_empty() {\n                values = vec![(0.0, 1.0, None)];\n            }\n            let debug_values: Vec\u003c(f32, f32)\u003e = values.iter().map(|(x, y, _)| (*x, *y)).collect();\n            web_sys::console::log_1(\u0026format!(\"chart data = {:?}\", debug_values).into());\n\n            values\n        }\n    };\n\n    let on_chart_column_select = {\n        let selected_column_for_chart = selected_column_for_chart.clone();\n        Callback::from(move |col: usize| {\n            selected_column_for_chart.set(if Some(col) == *selected_column_for_chart {\n                None // Deselect if same column is clicked\n            } else {\n                Some(col) // Select if new column is clicked\n            });\n        })\n    };\n\n    let on_chart_type_change = {\n        let chart_type = chart_type.clone();\n        Callback::from(move |e: Event| {\n            let input = e.target_unchecked_into::\u003cHtmlSelectElement\u003e();\n            chart_type.set(input.value());\n        })\n    };\n\n    fn is_cell_in_range(row: usize, col: usize, range: \u0026CellRange) -\u003e bool {\n        let (start_row, end_row) = if range.start.row \u003c= range.end.row {\n            (range.start.row, range.end.row)\n        } else {\n            (range.end.row, range.start.row)\n        };\n        let (start_col, end_col) = if range.start.col \u003c= range.end.col {\n            (range.start.col, range.end.col)\n        } else {\n            (range.end.col, range.start.col)\n        };\n        row \u003e= start_row \u0026\u0026 row \u003c= end_row \u0026\u0026 col \u003e= start_col \u0026\u0026 col \u003c= end_col\n    }\n\n    {\n        let selected_cell = selected_cell.clone();\n        let selected_range = selected_range.clone();\n        let click_anchor = click_anchor.clone();\n\n        use_effect(move || {\n            let was_inside_table = was_inside_table_effect.clone(); // use this clone\n            let closure =\n                Closure::\u003cdyn FnMut(_)\u003e::wrap(Box::new(move |event: web_sys::MouseEvent| {\n                    if let Some(target) = event.target() {\n                        let tag = target.dyn_ref::\u003cweb_sys::Element\u003e().map(|e| e.tag_name());\n                        let tag_name = tag.as_deref().unwrap_or(\"\");\n\n                        let is_table_cell = tag_name == \"TD\";\n                        let is_input = tag_name == \"INPUT\";\n                        let is_button = tag_name == \"BUTTON\";\n\n                        let clicked_inside = is_table_cell || is_input || is_button;\n\n                        web_sys::console::log_1(\n                            \u0026format!(\"tag = {}, clicked_inside = {}\", tag_name, clicked_inside)\n                                .into(),\n                        );\n\n                        if !clicked_inside \u0026\u0026 !*was_inside_table.borrow() {\n                            selected_cell.set(None);\n                            selected_range.set(None);\n                            click_anchor.set(None);\n                        }\n\n                        *was_inside_table.borrow_mut() = false;\n                    }\n                }) as Box\u003cdyn FnMut(_)\u003e);\n\n            let window = web_sys::window().unwrap();\n            window\n                .add_event_listener_with_callback(\"mousedown\", closure.as_ref().unchecked_ref())\n                .unwrap();\n\n            let closure_ref = closure.as_ref().clone();\n            let boxed = Box::new(closure);\n            move || {\n                window\n                    .remove_event_listener_with_callback(\"mousedown\", closure_ref.unchecked_ref())\n                    .unwrap();\n                drop(boxed);\n            }\n        });\n    }\n\n    use_effect(move || {\n        if let Some(window) = web_sys::window() {\n            if let Some(document) = window.document() {\n                if let Some(body) = document.body() {\n                    let element: \u0026web_sys::Element = body.dyn_ref().unwrap();\n                    if !element.class_name().contains(\"theme-\") {\n                        element.set_class_name(\"theme-dark\");\n                    }\n                }\n            }\n        }\n        || ()\n    });\n\n    html! {\n        \u003cdiv\u003e\n            // \u003cdiv\u003e\n            //     \u003ch2\u003e{\"Chart Section (using plotters)\"}\u003c/h2\u003e\n            //     \u003cCanvasChart data={data.iter().map(|(x, y, _)| (*x, *y)).collect()} chart_type={(*chart_type).clone()} /\u003e\n            // \u003c/div\u003e\n            \u003cstyle\u003e\n            {\"\n                :root {\n                /* Light theme variables */\n                --primary-color-light: #1d4ed8;\n                --primary-hover-light: #1e40af;\n                --background-color-light: #ffffff;\n                --text-color-light: #333333;\n                --border-color-light: #dddddd;\n                --header-bg-light: #f5f5f5;\n                --selected-cell-light: #ffeeba;\n                --selected-border-light: #ff9900;\n                --range-selected-light: #d0f0fd;\n                --range-border-light: #00aaff;\n                --formula-bar-bg-light: #ffffff;\n\n                /* Dark theme variables */\n                --primary-color-dark: #1d4ed8;\n                --primary-hover-dark: #1e40af;\n                --background-color-dark: #1e293b;\n                --text-color-dark: #e2e8f0;\n                --border-color-dark: #334155;\n                --header-bg-dark: #0f172a;\n                --selected-cell-dark: #854d0e;\n                --selected-border-dark: #d97706;\n                --range-selected-dark: #0c4a6e;\n                --range-border-dark: #0284c7;\n                --formula-bar-bg-dark: #1e293b;\n            }\n\n            .theme-light {\n                --primary-color: var(--primary-color-light);\n                --primary-hover: var(--primary-hover-light);\n                --background-color: var(--background-color-light);\n                --text-color: var(--text-color-light);\n                --border-color: var(--border-color-light);\n                --header-bg: var(--header-bg-light);\n                --selected-cell: var(--selected-cell-light);\n                --selected-border: var(--selected-border-light);\n                --range-selected: var(--range-selected-light);\n                --range-border: var(--range-border-light);\n                --formula-bar-bg: var(--formula-bar-bg-light);\n            }\n\n            .theme-dark {\n                --primary-color: var(--primary-color-dark);\n                --primary-hover: var(--primary-hover-dark);\n                --background-color: var(--background-color-dark);\n                --text-color: var(--text-color-dark);\n                --border-color: var(--border-color-dark);\n                --header-bg: var(--header-bg-dark);\n                --selected-cell: var(--selected-cell-dark);\n                --selected-border: var(--selected-border-dark);\n                --range-selected: var(--range-selected-dark);\n                --range-border: var(--range-border-dark);\n                --formula-bar-bg: var(--formula-bar-bg-dark);\n            }\n\n            /* ...existing code... */\n                .selected {\n                    background-color: #ffeeba;\n                    border: 2px solid #ff9900;\n                }\n                .range-selected {\n                    background-color: #d0f0fd;\n                    border: 1px solid #00aaff;\n                }\n                .highlight-column {\n                    background-color: pink;\n                }\n                .status-bar p {\n                    font-weight: bold;\n                    margin: 10px;\n                    color: #333;\n                }\n                .table-container {\n                    margin: 20px 0;\n                    padding: 10px;\n                    border-radius: 4px;\n                    background: white;\n                }\n                .table-container h3 {\n                    color: #333;\n                    margin-bottom: 15px;\n                }\n                table {\n                    width: 100%;\n                    border-collapse: collapse;\n                    margin-bottom: 20px;\n                }\n                th, td {\n                    border: 1px solid #ddd;\n                    padding: 8px;\n                    text-align: center;\n                }\n                th {\n                    background-color: #f5f5f5;\n                }\n                /* Specific styles for the complete table */\n                .complete-table {\n                    border: none;\n                    max-width: 100%;\n                    overflow-x: auto;\n                    display: block;\n                }\n                .complete-table td {\n                    border: none;\n                    padding: 0;\n                    width: 10px;\n                    height: 10px;\n                    min-width: 10px;\n                    min-height: 10px;\n                }\n                .complete-table tr:hover {\n                    background: none;\n                }\n            \"}\n            \u003c/style\u003e\n            \u003cdiv class=\"formula-bar\"\u003e\n                \u003cinput\n                    ref={formula_input_ref.clone()}\n                    type=\"text\"\n                    value={(*formula_input).clone()}\n                    oninput={on_formula_input}\n                    onfocus={Callback::from({\n                        let is_formula_building = is_formula_building.clone();\n                        let input_ref = formula_input_ref.clone();\n                        move |_| {\n                            is_formula_building.set(true);\n                            if let Some(input) = input_ref.cast::\u003cweb_sys::HtmlInputElement\u003e() {\n                                input.focus().ok(); // Reinforce focus\n                            }\n                        }\n                    })}\n                    // onblur={Callback::from({\n                    //     let is_formula_building = is_formula_building.clone();\n                    //     move |_| is_formula_building.set(false)\n                    // })}\n                    placeholder=\"Enter formula eg. SUM(B1:B10)\"\n                /\u003e\n                \u003cbutton style=\"margin-right: 10px;\" onclick={on_submit_formula}\u003e{\"Apply\"}\u003c/button\u003e\n                \u003cbutton style=\"margin-right: 10px;\" onclick={on_undo}\u003e{\"Undo\"}\u003c/button\u003e\n                \u003cbutton onclick={on_redo}\u003e{\"Redo\"}\u003c/button\u003e\n\n            \u003c/div\u003e\n            \u003cdiv class=\"status-bar\"\u003e\n                \u003cp\u003e{ (*status_message).clone() }\u003c/p\u003e\n            \u003c/div\u003e\n            \u003cdiv class=\"controls\"\u003e\n                \u003cdiv\u003e\n                    \u003clabel\u003e{\"Rows: \"}\u003c/label\u003e\n                    \u003cinput type=\"number\" value={(*rows1).to_string()} oninput={on_rows1_change} min=\"1\" max=\"100\"/\u003e\n                    {\" to \"}\n                    \u003cinput type=\"number\" value={(*rows2).to_string()} oninput={on_rows2_change} min=\"1\" max=\"100\"/\u003e\n                \u003c/div\u003e\n                \u003cdiv\u003e\n                    \u003clabel\u003e{\"Columns: \"}\u003c/label\u003e\n                    \u003cinput type=\"number\" value={(*cols1).to_string()} oninput={on_cols1_change} min=\"1\" max=\"100\"/\u003e\n                    {\" to \"}\n                    \u003cinput type=\"number\" value={(*cols2).to_string()} oninput={on_cols2_change} min=\"1\" max=\"100\"/\u003e\n                \u003c/div\u003e\n                \u003cdiv style=\"margin-left: 20px;\"\u003e\n                    \u003clabel\u003e{\"Chart: \"}\u003c/label\u003e\n                    \u003cselect value={(*chart_type).clone()} onchange={on_chart_type_change}\u003e\n                        \u003coption value=\"bar\"\u003e{\"Bar\"}\u003c/option\u003e\n                        \u003coption value=\"line\"\u003e{\"Line\"}\u003c/option\u003e\n                    \u003c/select\u003e\n                \u003c/div\u003e\n                \u003cdiv\u003e\n                    \u003cbutton onclick={\n                        Callback::from(move |_| {\n                            if let Some(window) = web_sys::window() {\n                                if let Some(document) = window.document() {\n                                    if let Some(body) = document.body() {\n                                        let element: \u0026web_sys::Element = body.dyn_ref().unwrap();\n                                        if element.class_name().contains(\"theme-light\") {\n                                            element.set_class_name(\"theme-dark\");\n                                        } else {\n                                            element.set_class_name(\"theme-light\");\n                                        }\n                                    }\n                                }\n                            }\n                        })\n                    }\u003e\n                        {\"Toggle Theme\"}\n                    \u003c/button\u003e\n                \u003c/div\u003e\n                \u003cdiv\u003e\n                    \u003cbutton onclick={\n                        let show_full_table = show_full_table.clone();\n                        Callback::from(move |_| {\n                            show_full_table.set(!*show_full_table);\n                        })\n                    }\u003e\n                        {if *show_full_table { \"Hide Image\" } else { \"Generate Image\" }}\n                    \u003c/button\u003e\n                \u003c/div\u003e\n            \u003c/div\u003e\n\n            {if let Some(col) = *selected_column_for_chart {\n                let data = get_column_data(col);\n\n                html! {\n                    \u003cdiv\u003e\n                        \u003ch2\u003e{ format!(\"Chart for Column {}\", number_to_column_label(col)) }\u003c/h2\u003e\n                        \u003cCanvasChart\n                            data={data.iter().map(|(x, y, _)| (*x, *y)).collect::\u003cVec\u003c(f32, f32)\u003e\u003e()}\n                            chart_type={(*chart_type).clone()}\n                        /\u003e\n\n                    \u003c/div\u003e\n                }\n            } else {\n                html! {}\n            }}\n\n            { if let Some(label) = \u0026selected_range_label {\n                html! {\n                    \u003cdiv style=\"margin: 8px 0; font-weight: bold;\"\u003e\n                        { format!(\"Selected Range: {}\", label) }\n                        \u003cbr/\u003e\n                        {\n                            if let Some((sum, min, max, avg, stdev)) = \u0026selected_range_stats {\n                                html! {\n                                    \u003cdiv style=\"font-weight: normal; margin-top: 4px;\"\u003e\n                                        { format!(\"Sum = {sum}, Min = {min}, Max = {max}, Avg = {:.2}, Stdev = {:.2}\", avg, stdev) }\n                                    \u003c/div\u003e\n                                }\n                            } else {\n                                html! {}\n                            }\n                        }\n                    \u003c/div\u003e\n                }\n            } else {\n                html! {}\n            } }\n\n            \u003cdiv class=\"table-container\"\u003e\n                \u003ctable\u003e\n                    \u003cthead\u003e\n                        \u003ctr\u003e\n                            \u003cth\u003e\u003c/th\u003e\n                            { for (*cols1..=(*cols2).min(table.columns - 1)).map(|column| {\n                                let onclick = {\n                                    let on_chart_column_select = on_chart_column_select.clone();\n                                    Callback::from(move |_| on_chart_column_select.emit(column))\n                                };\n                                let is_col_selected = Some(column) == *selected_column_for_chart;\n                                html! {\n                                    \u003cth\n                                        onclick={onclick}\n                                        class={if is_col_selected { \"highlight-column\" } else { \"\" }}\n                                    \u003e\n                                        { number_to_column_label(column) }\n                                    \u003c/th\u003e\n                                }\n                            }) }\n                        \u003c/tr\u003e\n                    \u003c/thead\u003e\n                    \u003ctbody\u003e\n                        { for row_range.clone().map(|row| {\n                            html! {\n                                \u003ctr\u003e\n                                    \u003cth\u003e{ row }\u003c/th\u003e\n                                    { for col_range.clone().map(|col| {\n                                        // let cell_value = table.cells[row - 1][col - 1].to_string();\n                                        let cell_value = table.cells\n                                            .get(row)\n                                            .and_then(|r| r.get(col))\n                                            .map(|v| v.map_or(\"ERR\".to_string(), |n| n.to_string()))\n                                            .unwrap_or_else(|| \"ERR\".to_string());\n\n                                        let is_selected = selected_cell.as_ref()\n                                            .map(|sc| sc.row == row \u0026\u0026 sc.col == col)\n                                            .unwrap_or(false);\n\n                                        let in_range = selected_range.as_ref()\n                                            .map(|range| is_cell_in_range(row, col, range))\n                                            .unwrap_or(false);\n\n                                        let is_in_selected_col = Some(col) == *selected_column_for_chart;\n\n                                        let onclick = {\n                                            let on_cell_click = on_cell_click.clone();\n                                            Callback::from(move |_| {\n                                                on_cell_click.emit(SelectedCell { row, col });\n                                            })\n                                        };\n                                        html! {\n                                            \u003ctd\n                                                onclick={onclick}\n                                                class={\n                                                    if is_selected {\n                                                        \"selected\"\n                                                    } else if in_range {\n                                                        \"range-selected\"\n                                                    } else if is_in_selected_col {\n                                                        \"highlight-column\"\n                                                    } else {\n                                                        \"\"\n                                                    }\n                                                }\n                                            \u003e\n                                                { cell_value }\n                                            \u003c/td\u003e\n                                        }\n                                    }) }\n                                \u003c/tr\u003e\n                            }\n                        }) }\n                    \u003c/tbody\u003e\n                \u003c/table\u003e\n            \u003c/div\u003e\n\n            {if *show_full_table {\n                html! {\n                    \u003cdiv class=\"table-container\"\u003e\n                        \u003ch3\u003e{\"Image View\"}\u003c/h3\u003e\n                        \u003ctable class=\"complete-table\"\u003e\n                            \u003ctbody\u003e\n                                { for (1..=table.rows).map(|row| {\n                                    html! {\n                                        \u003ctr\u003e\n                                            { for (1..=table.columns).map(|col| {\n                                                let cell_value = table.cells\n                                                    .get(row)\n                                                    .and_then(|r| r.get(col))\n                                                    .map(|v| v.map_or(\"ERR\".to_string(), |n| n.to_string()))\n                                                    .unwrap_or_else(|| \"\".to_string());\n\n                                                let bg_color = if let Ok(num) = cell_value.parse::\u003cu32\u003e() {\n                                                    let (r, g, b) = number_to_rgb(num);\n                                                    format!(\"rgb({}, {}, {})\", r, g, b)\n                                                } else {\n                                                    \"white\".to_string()\n                                                };\n\n                                                html! {\n                                                    \u003ctd style={format!(\"background-color: {}\", bg_color)}\u003e\n                                                        { \" \" }\n                                                    \u003c/td\u003e\n                                                }\n                                            }) }\n                                        \u003c/tr\u003e\n                                    }\n                                }) }\n                            \u003c/tbody\u003e\n                        \u003c/table\u003e\n                    \u003c/div\u003e\n                }\n            } else {\n                html! {}\n            }}\n        \u003c/div\u003e\n    }\n}\n\n#[allow(dead_code)]\npub fn start_web_app() {\n    println!(\"Starting web PP----------------------------------------------\");\n    yew::Renderer::\u003cApp\u003e::new().render();\n}\n","traces":[{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":401,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":418,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":441,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":0}},{"line":453,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":0}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":462,"address":[],"length":0,"stats":{"Line":0}},{"line":463,"address":[],"length":0,"stats":{"Line":0}},{"line":464,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":479,"address":[],"length":0,"stats":{"Line":0}},{"line":480,"address":[],"length":0,"stats":{"Line":0}},{"line":482,"address":[],"length":0,"stats":{"Line":0}},{"line":483,"address":[],"length":0,"stats":{"Line":0}},{"line":484,"address":[],"length":0,"stats":{"Line":0}},{"line":485,"address":[],"length":0,"stats":{"Line":0}},{"line":486,"address":[],"length":0,"stats":{"Line":0}},{"line":487,"address":[],"length":0,"stats":{"Line":0}},{"line":488,"address":[],"length":0,"stats":{"Line":0}},{"line":489,"address":[],"length":0,"stats":{"Line":0}},{"line":490,"address":[],"length":0,"stats":{"Line":0}},{"line":491,"address":[],"length":0,"stats":{"Line":0}},{"line":493,"address":[],"length":0,"stats":{"Line":0}},{"line":494,"address":[],"length":0,"stats":{"Line":0}},{"line":496,"address":[],"length":0,"stats":{"Line":0}},{"line":497,"address":[],"length":0,"stats":{"Line":0}},{"line":498,"address":[],"length":0,"stats":{"Line":0}},{"line":499,"address":[],"length":0,"stats":{"Line":0}},{"line":502,"address":[],"length":0,"stats":{"Line":0}},{"line":503,"address":[],"length":0,"stats":{"Line":0}},{"line":504,"address":[],"length":0,"stats":{"Line":0}},{"line":505,"address":[],"length":0,"stats":{"Line":0}},{"line":506,"address":[],"length":0,"stats":{"Line":0}},{"line":507,"address":[],"length":0,"stats":{"Line":0}},{"line":509,"address":[],"length":0,"stats":{"Line":0}},{"line":510,"address":[],"length":0,"stats":{"Line":0}},{"line":511,"address":[],"length":0,"stats":{"Line":0}},{"line":512,"address":[],"length":0,"stats":{"Line":0}},{"line":513,"address":[],"length":0,"stats":{"Line":0}},{"line":514,"address":[],"length":0,"stats":{"Line":0}},{"line":516,"address":[],"length":0,"stats":{"Line":0}},{"line":526,"address":[],"length":0,"stats":{"Line":0}},{"line":528,"address":[],"length":0,"stats":{"Line":0}},{"line":529,"address":[],"length":0,"stats":{"Line":0}},{"line":533,"address":[],"length":0,"stats":{"Line":0}},{"line":534,"address":[],"length":0,"stats":{"Line":0}},{"line":535,"address":[],"length":0,"stats":{"Line":0}},{"line":540,"address":[],"length":0,"stats":{"Line":0}},{"line":541,"address":[],"length":0,"stats":{"Line":0}},{"line":543,"address":[],"length":0,"stats":{"Line":0}},{"line":544,"address":[],"length":0,"stats":{"Line":0}},{"line":546,"address":[],"length":0,"stats":{"Line":0}},{"line":552,"address":[],"length":0,"stats":{"Line":0}},{"line":553,"address":[],"length":0,"stats":{"Line":0}},{"line":554,"address":[],"length":0,"stats":{"Line":0}},{"line":556,"address":[],"length":0,"stats":{"Line":0}},{"line":563,"address":[],"length":0,"stats":{"Line":0}},{"line":564,"address":[],"length":0,"stats":{"Line":0}},{"line":565,"address":[],"length":0,"stats":{"Line":0}},{"line":569,"address":[],"length":0,"stats":{"Line":0}},{"line":570,"address":[],"length":0,"stats":{"Line":0}},{"line":571,"address":[],"length":0,"stats":{"Line":0}},{"line":573,"address":[],"length":0,"stats":{"Line":0}},{"line":575,"address":[],"length":0,"stats":{"Line":0}},{"line":576,"address":[],"length":0,"stats":{"Line":0}},{"line":578,"address":[],"length":0,"stats":{"Line":0}},{"line":580,"address":[],"length":0,"stats":{"Line":0}},{"line":588,"address":[],"length":0,"stats":{"Line":0}},{"line":589,"address":[],"length":0,"stats":{"Line":0}},{"line":590,"address":[],"length":0,"stats":{"Line":0}},{"line":591,"address":[],"length":0,"stats":{"Line":0}},{"line":592,"address":[],"length":0,"stats":{"Line":0}},{"line":593,"address":[],"length":0,"stats":{"Line":0}},{"line":594,"address":[],"length":0,"stats":{"Line":0}},{"line":596,"address":[],"length":0,"stats":{"Line":0}},{"line":597,"address":[],"length":0,"stats":{"Line":0}},{"line":598,"address":[],"length":0,"stats":{"Line":0}},{"line":600,"address":[],"length":0,"stats":{"Line":0}},{"line":602,"address":[],"length":0,"stats":{"Line":0}},{"line":603,"address":[],"length":0,"stats":{"Line":0}},{"line":604,"address":[],"length":0,"stats":{"Line":0}},{"line":607,"address":[],"length":0,"stats":{"Line":0}},{"line":608,"address":[],"length":0,"stats":{"Line":0}},{"line":609,"address":[],"length":0,"stats":{"Line":0}},{"line":610,"address":[],"length":0,"stats":{"Line":0}},{"line":613,"address":[],"length":0,"stats":{"Line":0}},{"line":615,"address":[],"length":0,"stats":{"Line":0}},{"line":617,"address":[],"length":0,"stats":{"Line":0}},{"line":618,"address":[],"length":0,"stats":{"Line":0}},{"line":619,"address":[],"length":0,"stats":{"Line":0}},{"line":620,"address":[],"length":0,"stats":{"Line":0}},{"line":622,"address":[],"length":0,"stats":{"Line":0}},{"line":623,"address":[],"length":0,"stats":{"Line":0}},{"line":624,"address":[],"length":0,"stats":{"Line":0}},{"line":625,"address":[],"length":0,"stats":{"Line":0}},{"line":626,"address":[],"length":0,"stats":{"Line":0}},{"line":627,"address":[],"length":0,"stats":{"Line":0}},{"line":628,"address":[],"length":0,"stats":{"Line":0}},{"line":633,"address":[],"length":0,"stats":{"Line":0}},{"line":634,"address":[],"length":0,"stats":{"Line":0}},{"line":635,"address":[],"length":0,"stats":{"Line":0}},{"line":636,"address":[],"length":0,"stats":{"Line":0}},{"line":637,"address":[],"length":0,"stats":{"Line":0}},{"line":638,"address":[],"length":0,"stats":{"Line":0}},{"line":639,"address":[],"length":0,"stats":{"Line":0}},{"line":644,"address":[],"length":0,"stats":{"Line":0}},{"line":647,"address":[],"length":0,"stats":{"Line":0}},{"line":648,"address":[],"length":0,"stats":{"Line":0}},{"line":653,"address":[],"length":0,"stats":{"Line":0}},{"line":654,"address":[],"length":0,"stats":{"Line":0}},{"line":655,"address":[],"length":0,"stats":{"Line":0}},{"line":656,"address":[],"length":0,"stats":{"Line":0}},{"line":657,"address":[],"length":0,"stats":{"Line":0}},{"line":658,"address":[],"length":0,"stats":{"Line":0}},{"line":659,"address":[],"length":0,"stats":{"Line":0}},{"line":660,"address":[],"length":0,"stats":{"Line":0}},{"line":661,"address":[],"length":0,"stats":{"Line":0}},{"line":662,"address":[],"length":0,"stats":{"Line":0}},{"line":663,"address":[],"length":0,"stats":{"Line":0}},{"line":664,"address":[],"length":0,"stats":{"Line":0}},{"line":665,"address":[],"length":0,"stats":{"Line":0}},{"line":666,"address":[],"length":0,"stats":{"Line":0}},{"line":667,"address":[],"length":0,"stats":{"Line":0}},{"line":669,"address":[],"length":0,"stats":{"Line":0}},{"line":670,"address":[],"length":0,"stats":{"Line":0}},{"line":671,"address":[],"length":0,"stats":{"Line":0}},{"line":672,"address":[],"length":0,"stats":{"Line":0}},{"line":673,"address":[],"length":0,"stats":{"Line":0}},{"line":674,"address":[],"length":0,"stats":{"Line":0}},{"line":675,"address":[],"length":0,"stats":{"Line":0}},{"line":676,"address":[],"length":0,"stats":{"Line":0}},{"line":677,"address":[],"length":0,"stats":{"Line":0}},{"line":678,"address":[],"length":0,"stats":{"Line":0}},{"line":679,"address":[],"length":0,"stats":{"Line":0}},{"line":680,"address":[],"length":0,"stats":{"Line":0}},{"line":683,"address":[],"length":0,"stats":{"Line":0}},{"line":684,"address":[],"length":0,"stats":{"Line":0}},{"line":685,"address":[],"length":0,"stats":{"Line":0}},{"line":686,"address":[],"length":0,"stats":{"Line":0}},{"line":687,"address":[],"length":0,"stats":{"Line":0}},{"line":688,"address":[],"length":0,"stats":{"Line":0}},{"line":689,"address":[],"length":0,"stats":{"Line":0}},{"line":690,"address":[],"length":0,"stats":{"Line":0}},{"line":691,"address":[],"length":0,"stats":{"Line":0}},{"line":692,"address":[],"length":0,"stats":{"Line":0}},{"line":693,"address":[],"length":0,"stats":{"Line":0}},{"line":694,"address":[],"length":0,"stats":{"Line":0}},{"line":697,"address":[],"length":0,"stats":{"Line":0}},{"line":698,"address":[],"length":0,"stats":{"Line":0}},{"line":699,"address":[],"length":0,"stats":{"Line":0}},{"line":700,"address":[],"length":0,"stats":{"Line":0}},{"line":701,"address":[],"length":0,"stats":{"Line":0}},{"line":702,"address":[],"length":0,"stats":{"Line":0}},{"line":703,"address":[],"length":0,"stats":{"Line":0}},{"line":704,"address":[],"length":0,"stats":{"Line":0}},{"line":705,"address":[],"length":0,"stats":{"Line":0}},{"line":706,"address":[],"length":0,"stats":{"Line":0}},{"line":707,"address":[],"length":0,"stats":{"Line":0}},{"line":708,"address":[],"length":0,"stats":{"Line":0}},{"line":711,"address":[],"length":0,"stats":{"Line":0}},{"line":712,"address":[],"length":0,"stats":{"Line":0}},{"line":713,"address":[],"length":0,"stats":{"Line":0}},{"line":714,"address":[],"length":0,"stats":{"Line":0}},{"line":716,"address":[],"length":0,"stats":{"Line":0}},{"line":717,"address":[],"length":0,"stats":{"Line":0}},{"line":718,"address":[],"length":0,"stats":{"Line":0}},{"line":720,"address":[],"length":0,"stats":{"Line":0}},{"line":721,"address":[],"length":0,"stats":{"Line":0}},{"line":723,"address":[],"length":0,"stats":{"Line":0}},{"line":724,"address":[],"length":0,"stats":{"Line":0}},{"line":725,"address":[],"length":0,"stats":{"Line":0}},{"line":726,"address":[],"length":0,"stats":{"Line":0}},{"line":728,"address":[],"length":0,"stats":{"Line":0}},{"line":729,"address":[],"length":0,"stats":{"Line":0}},{"line":730,"address":[],"length":0,"stats":{"Line":0}},{"line":731,"address":[],"length":0,"stats":{"Line":0}},{"line":732,"address":[],"length":0,"stats":{"Line":0}},{"line":734,"address":[],"length":0,"stats":{"Line":0}},{"line":735,"address":[],"length":0,"stats":{"Line":0}},{"line":736,"address":[],"length":0,"stats":{"Line":0}},{"line":738,"address":[],"length":0,"stats":{"Line":0}},{"line":739,"address":[],"length":0,"stats":{"Line":0}},{"line":740,"address":[],"length":0,"stats":{"Line":0}},{"line":741,"address":[],"length":0,"stats":{"Line":0}},{"line":743,"address":[],"length":0,"stats":{"Line":0}},{"line":744,"address":[],"length":0,"stats":{"Line":0}},{"line":745,"address":[],"length":0,"stats":{"Line":0}},{"line":746,"address":[],"length":0,"stats":{"Line":0}},{"line":748,"address":[],"length":0,"stats":{"Line":0}},{"line":749,"address":[],"length":0,"stats":{"Line":0}},{"line":751,"address":[],"length":0,"stats":{"Line":0}},{"line":752,"address":[],"length":0,"stats":{"Line":0}},{"line":753,"address":[],"length":0,"stats":{"Line":0}},{"line":754,"address":[],"length":0,"stats":{"Line":0}},{"line":755,"address":[],"length":0,"stats":{"Line":0}},{"line":756,"address":[],"length":0,"stats":{"Line":0}},{"line":758,"address":[],"length":0,"stats":{"Line":0}},{"line":759,"address":[],"length":0,"stats":{"Line":0}},{"line":760,"address":[],"length":0,"stats":{"Line":0}},{"line":761,"address":[],"length":0,"stats":{"Line":0}},{"line":762,"address":[],"length":0,"stats":{"Line":0}},{"line":763,"address":[],"length":0,"stats":{"Line":0}},{"line":764,"address":[],"length":0,"stats":{"Line":0}},{"line":766,"address":[],"length":0,"stats":{"Line":0}},{"line":767,"address":[],"length":0,"stats":{"Line":0}},{"line":769,"address":[],"length":0,"stats":{"Line":0}},{"line":770,"address":[],"length":0,"stats":{"Line":0}},{"line":771,"address":[],"length":0,"stats":{"Line":0}},{"line":772,"address":[],"length":0,"stats":{"Line":0}},{"line":773,"address":[],"length":0,"stats":{"Line":0}},{"line":774,"address":[],"length":0,"stats":{"Line":0}},{"line":775,"address":[],"length":0,"stats":{"Line":0}},{"line":776,"address":[],"length":0,"stats":{"Line":0}},{"line":777,"address":[],"length":0,"stats":{"Line":0}},{"line":778,"address":[],"length":0,"stats":{"Line":0}},{"line":779,"address":[],"length":0,"stats":{"Line":0}},{"line":780,"address":[],"length":0,"stats":{"Line":0}},{"line":781,"address":[],"length":0,"stats":{"Line":0}},{"line":782,"address":[],"length":0,"stats":{"Line":0}},{"line":783,"address":[],"length":0,"stats":{"Line":0}},{"line":791,"address":[],"length":0,"stats":{"Line":0}},{"line":792,"address":[],"length":0,"stats":{"Line":0}},{"line":793,"address":[],"length":0,"stats":{"Line":0}},{"line":794,"address":[],"length":0,"stats":{"Line":0}},{"line":795,"address":[],"length":0,"stats":{"Line":0}},{"line":797,"address":[],"length":0,"stats":{"Line":0}},{"line":798,"address":[],"length":0,"stats":{"Line":0}},{"line":799,"address":[],"length":0,"stats":{"Line":0}},{"line":800,"address":[],"length":0,"stats":{"Line":0}},{"line":801,"address":[],"length":0,"stats":{"Line":0}},{"line":802,"address":[],"length":0,"stats":{"Line":0}},{"line":803,"address":[],"length":0,"stats":{"Line":0}},{"line":804,"address":[],"length":0,"stats":{"Line":0}},{"line":805,"address":[],"length":0,"stats":{"Line":0}},{"line":806,"address":[],"length":0,"stats":{"Line":0}},{"line":807,"address":[],"length":0,"stats":{"Line":0}},{"line":808,"address":[],"length":0,"stats":{"Line":0}},{"line":809,"address":[],"length":0,"stats":{"Line":0}},{"line":810,"address":[],"length":0,"stats":{"Line":0}},{"line":811,"address":[],"length":0,"stats":{"Line":0}},{"line":812,"address":[],"length":0,"stats":{"Line":0}},{"line":813,"address":[],"length":0,"stats":{"Line":0}},{"line":814,"address":[],"length":0,"stats":{"Line":0}},{"line":815,"address":[],"length":0,"stats":{"Line":0}},{"line":816,"address":[],"length":0,"stats":{"Line":0}},{"line":817,"address":[],"length":0,"stats":{"Line":0}},{"line":818,"address":[],"length":0,"stats":{"Line":0}},{"line":819,"address":[],"length":0,"stats":{"Line":0}},{"line":820,"address":[],"length":0,"stats":{"Line":0}},{"line":821,"address":[],"length":0,"stats":{"Line":0}},{"line":822,"address":[],"length":0,"stats":{"Line":0}},{"line":823,"address":[],"length":0,"stats":{"Line":0}},{"line":824,"address":[],"length":0,"stats":{"Line":0}},{"line":825,"address":[],"length":0,"stats":{"Line":0}},{"line":826,"address":[],"length":0,"stats":{"Line":0}},{"line":827,"address":[],"length":0,"stats":{"Line":0}},{"line":828,"address":[],"length":0,"stats":{"Line":0}},{"line":829,"address":[],"length":0,"stats":{"Line":0}},{"line":831,"address":[],"length":0,"stats":{"Line":0}},{"line":837,"address":[],"length":0,"stats":{"Line":0}},{"line":838,"address":[],"length":0,"stats":{"Line":0}},{"line":839,"address":[],"length":0,"stats":{"Line":0}},{"line":840,"address":[],"length":0,"stats":{"Line":0}},{"line":841,"address":[],"length":0,"stats":{"Line":0}},{"line":842,"address":[],"length":0,"stats":{"Line":0}},{"line":843,"address":[],"length":0,"stats":{"Line":0}},{"line":844,"address":[],"length":0,"stats":{"Line":0}},{"line":845,"address":[],"length":0,"stats":{"Line":0}},{"line":847,"address":[],"length":0,"stats":{"Line":0}},{"line":848,"address":[],"length":0,"stats":{"Line":0}},{"line":849,"address":[],"length":0,"stats":{"Line":0}},{"line":850,"address":[],"length":0,"stats":{"Line":0}},{"line":851,"address":[],"length":0,"stats":{"Line":0}},{"line":853,"address":[],"length":0,"stats":{"Line":0}},{"line":854,"address":[],"length":0,"stats":{"Line":0}},{"line":856,"address":[],"length":0,"stats":{"Line":0}},{"line":857,"address":[],"length":0,"stats":{"Line":0}},{"line":858,"address":[],"length":0,"stats":{"Line":0}},{"line":859,"address":[],"length":0,"stats":{"Line":0}},{"line":860,"address":[],"length":0,"stats":{"Line":0}},{"line":861,"address":[],"length":0,"stats":{"Line":0}},{"line":862,"address":[],"length":0,"stats":{"Line":0}},{"line":864,"address":[],"length":0,"stats":{"Line":0}},{"line":867,"address":[],"length":0,"stats":{"Line":0}},{"line":870,"address":[],"length":0,"stats":{"Line":0}},{"line":871,"address":[],"length":0,"stats":{"Line":0}},{"line":872,"address":[],"length":0,"stats":{"Line":0}},{"line":873,"address":[],"length":0,"stats":{"Line":0}},{"line":874,"address":[],"length":0,"stats":{"Line":0}},{"line":876,"address":[],"length":0,"stats":{"Line":0}},{"line":877,"address":[],"length":0,"stats":{"Line":0}},{"line":878,"address":[],"length":0,"stats":{"Line":0}},{"line":879,"address":[],"length":0,"stats":{"Line":0}},{"line":880,"address":[],"length":0,"stats":{"Line":0}},{"line":883,"address":[],"length":0,"stats":{"Line":0}},{"line":886,"address":[],"length":0,"stats":{"Line":0}},{"line":889,"address":[],"length":0,"stats":{"Line":0}},{"line":892,"address":[],"length":0,"stats":{"Line":0}},{"line":893,"address":[],"length":0,"stats":{"Line":0}},{"line":894,"address":[],"length":0,"stats":{"Line":0}},{"line":895,"address":[],"length":0,"stats":{"Line":0}},{"line":896,"address":[],"length":0,"stats":{"Line":0}},{"line":897,"address":[],"length":0,"stats":{"Line":0}},{"line":898,"address":[],"length":0,"stats":{"Line":0}},{"line":899,"address":[],"length":0,"stats":{"Line":0}},{"line":900,"address":[],"length":0,"stats":{"Line":0}},{"line":902,"address":[],"length":0,"stats":{"Line":0}},{"line":903,"address":[],"length":0,"stats":{"Line":0}},{"line":904,"address":[],"length":0,"stats":{"Line":0}},{"line":905,"address":[],"length":0,"stats":{"Line":0}},{"line":906,"address":[],"length":0,"stats":{"Line":0}},{"line":907,"address":[],"length":0,"stats":{"Line":0}},{"line":908,"address":[],"length":0,"stats":{"Line":0}},{"line":909,"address":[],"length":0,"stats":{"Line":0}},{"line":912,"address":[],"length":0,"stats":{"Line":0}},{"line":913,"address":[],"length":0,"stats":{"Line":0}},{"line":914,"address":[],"length":0,"stats":{"Line":0}},{"line":915,"address":[],"length":0,"stats":{"Line":0}},{"line":916,"address":[],"length":0,"stats":{"Line":0}},{"line":917,"address":[],"length":0,"stats":{"Line":0}},{"line":918,"address":[],"length":0,"stats":{"Line":0}},{"line":919,"address":[],"length":0,"stats":{"Line":0}},{"line":921,"address":[],"length":0,"stats":{"Line":0}},{"line":922,"address":[],"length":0,"stats":{"Line":0}},{"line":923,"address":[],"length":0,"stats":{"Line":0}},{"line":924,"address":[],"length":0,"stats":{"Line":0}},{"line":925,"address":[],"length":0,"stats":{"Line":0}},{"line":927,"address":[],"length":0,"stats":{"Line":0}},{"line":928,"address":[],"length":0,"stats":{"Line":0}},{"line":929,"address":[],"length":0,"stats":{"Line":0}},{"line":931,"address":[],"length":0,"stats":{"Line":0}},{"line":932,"address":[],"length":0,"stats":{"Line":0}},{"line":933,"address":[],"length":0,"stats":{"Line":0}},{"line":935,"address":[],"length":0,"stats":{"Line":0}},{"line":937,"address":[],"length":0,"stats":{"Line":0}},{"line":938,"address":[],"length":0,"stats":{"Line":0}},{"line":939,"address":[],"length":0,"stats":{"Line":0}},{"line":940,"address":[],"length":0,"stats":{"Line":0}},{"line":943,"address":[],"length":0,"stats":{"Line":0}},{"line":944,"address":[],"length":0,"stats":{"Line":0}},{"line":945,"address":[],"length":0,"stats":{"Line":0}},{"line":946,"address":[],"length":0,"stats":{"Line":0}},{"line":947,"address":[],"length":0,"stats":{"Line":0}},{"line":948,"address":[],"length":0,"stats":{"Line":0}},{"line":949,"address":[],"length":0,"stats":{"Line":0}},{"line":950,"address":[],"length":0,"stats":{"Line":0}},{"line":951,"address":[],"length":0,"stats":{"Line":0}},{"line":952,"address":[],"length":0,"stats":{"Line":0}},{"line":954,"address":[],"length":0,"stats":{"Line":0}},{"line":957,"address":[],"length":0,"stats":{"Line":0}},{"line":958,"address":[],"length":0,"stats":{"Line":0}},{"line":959,"address":[],"length":0,"stats":{"Line":0}},{"line":962,"address":[],"length":0,"stats":{"Line":0}},{"line":965,"address":[],"length":0,"stats":{"Line":0}},{"line":966,"address":[],"length":0,"stats":{"Line":0}},{"line":967,"address":[],"length":0,"stats":{"Line":0}},{"line":969,"address":[],"length":0,"stats":{"Line":0}},{"line":970,"address":[],"length":0,"stats":{"Line":0}},{"line":971,"address":[],"length":0,"stats":{"Line":0}},{"line":972,"address":[],"length":0,"stats":{"Line":0}},{"line":973,"address":[],"length":0,"stats":{"Line":0}},{"line":974,"address":[],"length":0,"stats":{"Line":0}},{"line":975,"address":[],"length":0,"stats":{"Line":0}},{"line":976,"address":[],"length":0,"stats":{"Line":0}},{"line":977,"address":[],"length":0,"stats":{"Line":0}},{"line":978,"address":[],"length":0,"stats":{"Line":0}},{"line":979,"address":[],"length":0,"stats":{"Line":0}},{"line":980,"address":[],"length":0,"stats":{"Line":0}},{"line":981,"address":[],"length":0,"stats":{"Line":0}},{"line":982,"address":[],"length":0,"stats":{"Line":0}},{"line":983,"address":[],"length":0,"stats":{"Line":0}},{"line":985,"address":[],"length":0,"stats":{"Line":0}},{"line":986,"address":[],"length":0,"stats":{"Line":0}},{"line":987,"address":[],"length":0,"stats":{"Line":0}},{"line":989,"address":[],"length":0,"stats":{"Line":0}},{"line":992,"address":[],"length":0,"stats":{"Line":0}},{"line":993,"address":[],"length":0,"stats":{"Line":0}},{"line":994,"address":[],"length":0,"stats":{"Line":0}},{"line":995,"address":[],"length":0,"stats":{"Line":0}},{"line":998,"address":[],"length":0,"stats":{"Line":0}},{"line":1001,"address":[],"length":0,"stats":{"Line":0}},{"line":1002,"address":[],"length":0,"stats":{"Line":0}},{"line":1003,"address":[],"length":0,"stats":{"Line":0}},{"line":1006,"address":[],"length":0,"stats":{"Line":0}},{"line":1008,"address":[],"length":0,"stats":{"Line":0}},{"line":1013,"address":[],"length":0,"stats":{"Line":0}},{"line":1014,"address":[],"length":0,"stats":{"Line":0}},{"line":1015,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":531},{"path":["/","Users","yuvikachaudhary","Desktop","Semester 4","COP290","spreadsheet_rust","src","extension","mod.rs"],"content":"pub mod backend;\npub mod common;\npub mod frontend;\npub mod parser;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","yuvikachaudhary","Desktop","Semester 4","COP290","spreadsheet_rust","src","extension","parser","mod.rs"],"content":"#![allow(clippy::module_inception)]\npub mod parser;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","yuvikachaudhary","Desktop","Semester 4","COP290","spreadsheet_rust","src","extension","parser","parser.rs"],"content":"#![allow(dead_code)]\n/// Module responsible for validating and parsing commands given to the spreadsheet.\n///\n/// This includes:\n/// - Recognizing valid cell identifiers\n/// - Parsing constants and expressions\n/// - Constructing a `Value` AST representing operations or values\n/// - Supporting arithmetic, sleep, and range-based operations like SUM, AVG, etc.\nuse crate::extension::common::Operation;\nuse crate::extension::common::Value;\n\nfn is_cell(exp: \u0026str, columns: \u0026usize, rows: \u0026usize) -\u003e Option\u003cValue\u003e {\n    let mut col = 0;\n    let mut row = 0;\n\n    let chars: Vec\u003cchar\u003e = exp.chars().collect();\n    let mut i = 0;\n    while i \u003c 3 {\n        if chars[i].is_alphabetic() {\n            col = col * 26 + (chars[i] as u8 - b'A') as usize + 1;\n        } else {\n            break;\n        }\n        i += 1;\n    }\n    if exp.chars().count() - i \u003e 3 || i == 0 {\n        return None;\n    }\n    while i \u003c exp.chars().count() {\n        if chars[i].is_numeric() {\n            row = row * 10 + (chars[i] as u8 - b'0') as usize;\n        } else {\n            return None;\n        }\n        i += 1;\n    }\n    if row \u003e *rows || col \u003e *columns {\n        return None;\n    }\n    Some(Value::Cell(row, col))\n}\n\nfn is_const(exp: \u0026str) -\u003e Option\u003cValue\u003e {\n    // let mut ans = 0;\n    // for c in exp.chars() {\n    //     if c.is_numeric() {\n    //         ans = ans*10 + (c as u8 - '0' as u8) as usize;\n    //     } else {\n    //         return None;\n    //     }\n    // }\n    // return Some(Value::Const(ans));\n    match exp.parse::\u003cisize\u003e() {\n        Ok(ans) =\u003e Some(Value::Const(ans)),\n        Err(_) =\u003e None,\n    }\n}\n\nfn is_cell_or_const(exp: \u0026str, rows: \u0026usize, columns: \u0026usize) -\u003e Option\u003cValue\u003e {\n    if let Some(constant) = is_const(exp) {\n        Some(constant)\n    } else if let Some(cell) = is_cell(exp, rows, columns) {\n        return Some(cell);\n    } else {\n        return None;\n    }\n}\n\npub fn validate(\n    cmd: \u0026str,\n    rows: \u0026usize,\n    columns: \u0026usize,\n) -\u003e Option\u003c(Option\u003cValue\u003e, Option\u003cValue\u003e)\u003e {\n    match cmd.trim() {\n        \"undo\" =\u003e return Some((None, Some(Value::Oper(None, None, Operation::Undo)))),\n        \"redo\" =\u003e return Some((None, Some(Value::Oper(None, None, Operation::Redo)))),\n        \"web_start\" =\u003e return Some((None, Some(Value::Oper(None, None, Operation::WebStart)))),\n        \"enable_output\" =\u003e {\n            return Some((None, Some(Value::Oper(None, None, Operation::EnableOutput))));\n        }\n        \"disable_output\" =\u003e {\n            return Some((\n                None,\n                Some(Value::Oper(None, None, Operation::DisableOutput)),\n            ));\n        }\n        \"w\" =\u003e {\n            return Some((None, Some(Value::Oper(None, None, Operation::Up))));\n        }\n        \"s\" =\u003e {\n            return Some((None, Some(Value::Oper(None, None, Operation::Down))));\n        }\n        \"a\" =\u003e {\n            return Some((None, Some(Value::Oper(None, None, Operation::Left))));\n        }\n        \"d\" =\u003e {\n            return Some((None, Some(Value::Oper(None, None, Operation::Right))));\n        }\n        \"q\" =\u003e {\n            return Some((None, Some(Value::Oper(None, None, Operation::Quit))));\n        }\n        _ =\u003e {} // Continue with the regular parsing for other commands\n    }\n\n    if cmd.trim().starts_with(\"scroll_to \") {\n        let cell_name = cmd.trim()[\"scroll_to \".len()..].trim().to_string();\n        let cell = is_cell(\u0026cell_name, rows, columns);\n        if let Some(cell) = cell {\n            return Some((\n                Some(cell),\n                Some(Value::Oper(None, None, Operation::ScrollTo)),\n            ));\n        } else {\n            // println!(\"Invalid cell name\");\n            return None;\n        }\n    }\n\n    if cmd.trim().starts_with(\"save \") {\n        let file_name = cmd.trim()[\"save \".len()..].trim().to_string();\n        return Some((\n            None,\n            Some(Value::Oper(None, None, Operation::Save(file_name))),\n        ));\n    }\n\n    if cmd.trim().starts_with(\"web \") {\n        let file_name = cmd.trim()[\"web \".len()..].trim().to_string();\n        return Some((\n            None,\n            Some(Value::Oper(None, None, Operation::Web(file_name))),\n        ));\n    }\n\n    let Some((cell, exp)) = cmd.split_once('=') else {\n        // eprintln!(\"Could not find a valid exp being assigned to a valid cell\");\n        return None;\n    };\n\n    let cell = String::from(cell).trim().to_string();\n    let cell = is_cell(\u0026cell, rows, columns);\n\n    let Some((operation, range)) = exp.split_once('(') else {\n        // basic math operations or constant (0-4)\n        let val = (String::from(exp)).trim().to_string();\n        let operators = [\"+\", \"-\", \"*\", \"/\"];\n        for (i, c) in val.chars().enumerate() {\n            if i == 0 \u0026\u0026 c == '-' {\n                continue;\n            }\n            if operators.contains(\u0026c.to_string().as_str()) {\n                let op1_str = val[..i].trim();\n                let op2_str = val[i + 1..].trim();\n                let op1 = is_cell_or_const(op1_str, rows, columns)?;\n                let op2 = is_cell_or_const(op2_str, rows, columns)?;\n\n                match c {\n                    '+' =\u003e {\n                        return Some((\n                            cell,\n                            Some(Value::Oper(\n                                Some(Box::new(op1)),\n                                Some(Box::new(op2)),\n                                Operation::Add,\n                            )),\n                        ));\n                    }\n                    '-' =\u003e {\n                        return Some((\n                            cell,\n                            Some(Value::Oper(\n                                Some(Box::new(op1)),\n                                Some(Box::new(op2)),\n                                Operation::Sub,\n                            )),\n                        ));\n                    }\n                    '*' =\u003e {\n                        return Some((\n                            cell,\n                            Some(Value::Oper(\n                                Some(Box::new(op1)),\n                                Some(Box::new(op2)),\n                                Operation::Mul,\n                            )),\n                        ));\n                    }\n                    '/' =\u003e {\n                        return Some((\n                            cell,\n                            Some(Value::Oper(\n                                Some(Box::new(op1)),\n                                Some(Box::new(op2)),\n                                Operation::Div,\n                            )),\n                        ));\n                    }\n                    _ =\u003e {\n                        // eprintln!(\"Invalid operation\");\n                        return None;\n                    } //This case is not possible, just for compilation\n                }\n            }\n        }\n\n        let val = is_cell_or_const(\u0026val, rows, columns)?; //for the moment, assuming the RHS to be a constant or cell\n        // println!(\"{} {}\", cmd, cmd); //---------------debugger\n        return Some((\n            cell,\n            Some(Value::Oper(\n                Some(Box::new(val)),\n                Some(Box::new(Value::Const(0))),\n                Operation::Cons,\n            )),\n        ));\n    };\n    let range = range.strip_suffix(')')?.to_string(); //removing the closing bracket\n\n    let Some((start, end)) = range.split_once(':') else {\n        // SLEEP (the keyword 'SLEEP' is not checked for, it is taken fro granted)\n        let val = range;\n        let val = is_cell_or_const(\u0026val, rows, columns);\n        if let Some(val) = val {\n            return Some((\n                cell,\n                Some(Value::Oper(\n                    Some(Box::new(val)),\n                    Some(Box::new(Value::Const(0))),\n                    Operation::Slp,\n                )),\n            ));\n        }\n        return Some((cell, None));\n    };\n    let start = String::from(start);\n    let end = String::from(end);\n    let start = is_cell(\u0026start, rows, columns)?;\n    let end = is_cell(\u0026end, rows, columns)?;\n    if let (Value::Cell(r, c), Value::Cell(r2, c2)) = (\u0026start, \u0026end) {\n        if r \u003e r2 || c \u003e c2 {\n            // eprintln!(\"Invalid range, start is greater than end\");\n            return None;\n        }\n    } else {\n        return None;\n    }\n    match operation {\n        \"SUM\" =\u003e Some((\n            cell,\n            Some(Value::Oper(\n                Some(Box::new(start)),\n                Some(Box::new(end)),\n                Operation::Sum,\n            )),\n        )),\n        \"AVG\" =\u003e Some((\n            cell,\n            Some(Value::Oper(\n                Some(Box::new(start)),\n                Some(Box::new(end)),\n                Operation::Avg,\n            )),\n        )),\n        \"STDEV\" =\u003e Some((\n            cell,\n            Some(Value::Oper(\n                Some(Box::new(start)),\n                Some(Box::new(end)),\n                Operation::Std,\n            )),\n        )),\n        \"MIN\" =\u003e Some((\n            cell,\n            Some(Value::Oper(\n                Some(Box::new(start)),\n                Some(Box::new(end)),\n                Operation::Min,\n            )),\n        )),\n        \"MAX\" =\u003e Some((\n            cell,\n            Some(Value::Oper(\n                Some(Box::new(start)),\n                Some(Box::new(end)),\n                Operation::Max,\n            )),\n        )),\n        _ =\u003e {\n            // eprintln!(\"Invalid operation\");\n            Some((cell, None))\n        }\n    }\n}\n\n// assignment - cell, value - done\n// basic math - cells, values\n// sleep - cell, value - done\n// range operations - cells, values - done\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":128}},{"line":13,"address":[],"length":0,"stats":{"Line":128}},{"line":14,"address":[],"length":0,"stats":{"Line":128}},{"line":16,"address":[],"length":0,"stats":{"Line":128}},{"line":17,"address":[],"length":0,"stats":{"Line":128}},{"line":18,"address":[],"length":0,"stats":{"Line":256}},{"line":19,"address":[],"length":0,"stats":{"Line":384}},{"line":20,"address":[],"length":0,"stats":{"Line":128}},{"line":22,"address":[],"length":0,"stats":{"Line":128}},{"line":24,"address":[],"length":0,"stats":{"Line":128}},{"line":26,"address":[],"length":0,"stats":{"Line":256}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":257}},{"line":30,"address":[],"length":0,"stats":{"Line":258}},{"line":31,"address":[],"length":0,"stats":{"Line":129}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":129}},{"line":37,"address":[],"length":0,"stats":{"Line":255}},{"line":38,"address":[],"length":0,"stats":{"Line":2}},{"line":40,"address":[],"length":0,"stats":{"Line":126}},{"line":43,"address":[],"length":0,"stats":{"Line":68}},{"line":53,"address":[],"length":0,"stats":{"Line":68}},{"line":54,"address":[],"length":0,"stats":{"Line":43}},{"line":55,"address":[],"length":0,"stats":{"Line":25}},{"line":59,"address":[],"length":0,"stats":{"Line":68}},{"line":60,"address":[],"length":0,"stats":{"Line":111}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":50}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":89}},{"line":74,"address":[],"length":0,"stats":{"Line":89}},{"line":75,"address":[],"length":0,"stats":{"Line":91}},{"line":76,"address":[],"length":0,"stats":{"Line":89}},{"line":77,"address":[],"length":0,"stats":{"Line":86}},{"line":78,"address":[],"length":0,"stats":{"Line":84}},{"line":79,"address":[],"length":0,"stats":{"Line":1}},{"line":81,"address":[],"length":0,"stats":{"Line":83}},{"line":82,"address":[],"length":0,"stats":{"Line":1}},{"line":83,"address":[],"length":0,"stats":{"Line":1}},{"line":84,"address":[],"length":0,"stats":{"Line":1}},{"line":87,"address":[],"length":0,"stats":{"Line":82}},{"line":88,"address":[],"length":0,"stats":{"Line":1}},{"line":90,"address":[],"length":0,"stats":{"Line":81}},{"line":91,"address":[],"length":0,"stats":{"Line":1}},{"line":93,"address":[],"length":0,"stats":{"Line":80}},{"line":94,"address":[],"length":0,"stats":{"Line":1}},{"line":96,"address":[],"length":0,"stats":{"Line":79}},{"line":97,"address":[],"length":0,"stats":{"Line":1}},{"line":99,"address":[],"length":0,"stats":{"Line":78}},{"line":100,"address":[],"length":0,"stats":{"Line":1}},{"line":102,"address":[],"length":0,"stats":{"Line":77}},{"line":105,"address":[],"length":0,"stats":{"Line":77}},{"line":106,"address":[],"length":0,"stats":{"Line":2}},{"line":107,"address":[],"length":0,"stats":{"Line":2}},{"line":108,"address":[],"length":0,"stats":{"Line":3}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":1}},{"line":119,"address":[],"length":0,"stats":{"Line":75}},{"line":120,"address":[],"length":0,"stats":{"Line":1}},{"line":121,"address":[],"length":0,"stats":{"Line":1}},{"line":122,"address":[],"length":0,"stats":{"Line":1}},{"line":123,"address":[],"length":0,"stats":{"Line":1}},{"line":127,"address":[],"length":0,"stats":{"Line":74}},{"line":128,"address":[],"length":0,"stats":{"Line":1}},{"line":129,"address":[],"length":0,"stats":{"Line":1}},{"line":130,"address":[],"length":0,"stats":{"Line":1}},{"line":131,"address":[],"length":0,"stats":{"Line":1}},{"line":135,"address":[],"length":0,"stats":{"Line":70}},{"line":137,"address":[],"length":0,"stats":{"Line":3}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":18}},{"line":145,"address":[],"length":0,"stats":{"Line":52}},{"line":146,"address":[],"length":0,"stats":{"Line":52}},{"line":147,"address":[],"length":0,"stats":{"Line":155}},{"line":148,"address":[],"length":0,"stats":{"Line":155}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":103}},{"line":152,"address":[],"length":0,"stats":{"Line":14}},{"line":153,"address":[],"length":0,"stats":{"Line":14}},{"line":154,"address":[],"length":0,"stats":{"Line":28}},{"line":155,"address":[],"length":0,"stats":{"Line":14}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":5}},{"line":160,"address":[],"length":0,"stats":{"Line":5}},{"line":161,"address":[],"length":0,"stats":{"Line":5}},{"line":162,"address":[],"length":0,"stats":{"Line":5}},{"line":163,"address":[],"length":0,"stats":{"Line":5}},{"line":164,"address":[],"length":0,"stats":{"Line":5}},{"line":169,"address":[],"length":0,"stats":{"Line":3}},{"line":170,"address":[],"length":0,"stats":{"Line":3}},{"line":171,"address":[],"length":0,"stats":{"Line":3}},{"line":172,"address":[],"length":0,"stats":{"Line":3}},{"line":173,"address":[],"length":0,"stats":{"Line":3}},{"line":174,"address":[],"length":0,"stats":{"Line":3}},{"line":179,"address":[],"length":0,"stats":{"Line":3}},{"line":180,"address":[],"length":0,"stats":{"Line":3}},{"line":181,"address":[],"length":0,"stats":{"Line":3}},{"line":182,"address":[],"length":0,"stats":{"Line":3}},{"line":183,"address":[],"length":0,"stats":{"Line":3}},{"line":184,"address":[],"length":0,"stats":{"Line":3}},{"line":189,"address":[],"length":0,"stats":{"Line":3}},{"line":190,"address":[],"length":0,"stats":{"Line":3}},{"line":191,"address":[],"length":0,"stats":{"Line":3}},{"line":192,"address":[],"length":0,"stats":{"Line":3}},{"line":193,"address":[],"length":0,"stats":{"Line":3}},{"line":194,"address":[],"length":0,"stats":{"Line":3}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":76}},{"line":208,"address":[],"length":0,"stats":{"Line":38}},{"line":209,"address":[],"length":0,"stats":{"Line":38}},{"line":210,"address":[],"length":0,"stats":{"Line":38}},{"line":211,"address":[],"length":0,"stats":{"Line":38}},{"line":212,"address":[],"length":0,"stats":{"Line":38}},{"line":213,"address":[],"length":0,"stats":{"Line":38}},{"line":217,"address":[],"length":0,"stats":{"Line":18}},{"line":219,"address":[],"length":0,"stats":{"Line":16}},{"line":221,"address":[],"length":0,"stats":{"Line":2}},{"line":222,"address":[],"length":0,"stats":{"Line":2}},{"line":223,"address":[],"length":0,"stats":{"Line":4}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":16}},{"line":238,"address":[],"length":0,"stats":{"Line":15}},{"line":239,"address":[],"length":0,"stats":{"Line":15}},{"line":240,"address":[],"length":0,"stats":{"Line":29}},{"line":242,"address":[],"length":0,"stats":{"Line":1}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":3}},{"line":249,"address":[],"length":0,"stats":{"Line":3}},{"line":250,"address":[],"length":0,"stats":{"Line":3}},{"line":251,"address":[],"length":0,"stats":{"Line":3}},{"line":252,"address":[],"length":0,"stats":{"Line":3}},{"line":253,"address":[],"length":0,"stats":{"Line":3}},{"line":256,"address":[],"length":0,"stats":{"Line":14}},{"line":257,"address":[],"length":0,"stats":{"Line":3}},{"line":258,"address":[],"length":0,"stats":{"Line":3}},{"line":259,"address":[],"length":0,"stats":{"Line":3}},{"line":260,"address":[],"length":0,"stats":{"Line":3}},{"line":261,"address":[],"length":0,"stats":{"Line":3}},{"line":264,"address":[],"length":0,"stats":{"Line":11}},{"line":265,"address":[],"length":0,"stats":{"Line":3}},{"line":266,"address":[],"length":0,"stats":{"Line":3}},{"line":267,"address":[],"length":0,"stats":{"Line":3}},{"line":268,"address":[],"length":0,"stats":{"Line":3}},{"line":269,"address":[],"length":0,"stats":{"Line":3}},{"line":272,"address":[],"length":0,"stats":{"Line":7}},{"line":273,"address":[],"length":0,"stats":{"Line":2}},{"line":274,"address":[],"length":0,"stats":{"Line":2}},{"line":275,"address":[],"length":0,"stats":{"Line":2}},{"line":276,"address":[],"length":0,"stats":{"Line":2}},{"line":277,"address":[],"length":0,"stats":{"Line":2}},{"line":280,"address":[],"length":0,"stats":{"Line":5}},{"line":281,"address":[],"length":0,"stats":{"Line":2}},{"line":282,"address":[],"length":0,"stats":{"Line":2}},{"line":283,"address":[],"length":0,"stats":{"Line":2}},{"line":284,"address":[],"length":0,"stats":{"Line":2}},{"line":285,"address":[],"length":0,"stats":{"Line":2}},{"line":290,"address":[],"length":0,"stats":{"Line":1}}],"covered":146,"coverable":170},{"path":["/","Users","yuvikachaudhary","Desktop","Semester 4","COP290","spreadsheet_rust","src","extension_main.rs"],"content":"pub mod extension;\n#[allow(unused_imports)]\nuse crate::extension::backend::backend::*;\n#[allow(unused_imports)]\nuse crate::extension::frontend::terminal::Frontend;\n#[allow(unused_imports)]\nuse crate::extension::frontend::web::start_web_app;\n#[allow(unused_imports)]\nuse std::env;\n#[allow(unused_imports)]\nuse std::process::{Command, Stdio};\n#[allow(unused_imports)]\nuse std::thread;\n\n/// Entry point of the spreadsheet application.\n///\n/// By default starts terminal spreadsheet. If the user enters 'web' command,\n/// it will launch the web interface in a separate thread while keeping\n/// the terminal interface running.\nfn main() {\n    #[cfg(not(target_arch = \"wasm32\"))]\n    let args: Vec\u003cString\u003e = env::args().collect();\n\n    // Default rows and columns if not specified\n    #[cfg(not(target_arch = \"wasm32\"))]\n    let rows = if args.len() \u003e 1 {\n        args[1].parse::\u003cusize\u003e().unwrap_or(10)\n    } else {\n        10\n    };\n\n    #[cfg(not(target_arch = \"wasm32\"))]\n    let columns = if args.len() \u003e 2 {\n        args[2].parse::\u003cusize\u003e().unwrap_or(10)\n    } else {\n        10\n    };\n\n    #[cfg(not(target_arch = \"wasm32\"))]\n    let path = if args.len() \u003e 3 {\n        args[3].clone()\n    } else {\n        String::new()\n    };\n\n    #[cfg(not(target_arch = \"wasm32\"))]\n    if !(1..=999).contains(\u0026rows) {\n        return;\n    }\n    #[cfg(not(target_arch = \"wasm32\"))]\n    if !(1..=18278).contains(\u0026columns) {\n        return;\n    }\n    #[cfg(not(target_arch = \"wasm32\"))]\n    let start_time = std::time::Instant::now();\n    #[cfg(not(target_arch = \"wasm32\"))]\n    let mut frontend = Frontend::init_frontend(rows, columns, \u0026path);\n    #[cfg(not(target_arch = \"wasm32\"))]\n    let elapsed_time = start_time.elapsed();\n    #[cfg(not(target_arch = \"wasm32\"))]\n    frontend.display(Status::Success, elapsed_time.as_secs_f64());\n    #[cfg(not(target_arch = \"wasm32\"))]\n    frontend.run_frontend();\n\n    #[cfg(target_arch = \"wasm32\")]\n    start_web_app();\n}\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":21},{"path":["/","Users","yuvikachaudhary","Desktop","Semester 4","COP290","spreadsheet_rust","src","lib.rs"],"content":"pub mod extension;\npub mod terminal;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","yuvikachaudhary","Desktop","Semester 4","COP290","spreadsheet_rust","src","main.rs"],"content":"// use project::terminal::backend::*;\n// use project::terminal::spreadsheet::*;\nuse std::env;\npub mod terminal;\nuse crate::terminal::backend::*;\nuse crate::terminal::spreadsheet::*;\nuse std::io::{self, BufRead, Write};\nuse std::time::Instant;\nfn main() {\n    let mut start_x = 1;\n    let mut start_y = 1;\n    let mut is_disabled = false;\n    let args: Vec\u003cString\u003e = env::args().collect();\n    // part of first processing\n    if !process_first(args.len(), \u0026args, \u0026mut is_disabled) {\n        return;\n    }\n    let r = args[1].parse::\u003cusize\u003e().unwrap();\n    let c = args[2].parse::\u003cusize\u003e().unwrap();\n    let start = Instant::now();\n    // init frontend\n    let mut grid = generate_grid(r, c);\n    if !is_disabled {\n        print_grid(start_x, start_y, r, c, \u0026mut grid);\n    }\n    let duration = start.elapsed();\n    display_status(1, duration.as_secs_f64());\n\n    let stdin = io::stdin();\n    let mut command = String::new();\n\n    // let graph = create_graph(r + 1, c + 1);\n\n    loop {\n        command.clear();\n        let bytes_read = stdin.lock().read_line(\u0026mut command).unwrap();\n        if bytes_read == 0 {\n            break;\n        }\n        // remove the trailing newline character\n        if command.ends_with('\\n') {\n            command.pop();\n        }\n        if command.is_empty() {\n            print_grid(start_x, start_y, r, c, \u0026mut grid);\n            print!(\"[0.0] (unrecognized cmd) \u003e \");\n            io::stdout().flush().unwrap();\n            continue;\n        }\n\n        let start = Instant::now();\n        // , \u0026graph // debug\n        let status = process_command(\n            \u0026command,\n            \u0026mut start_x,\n            \u0026mut start_y,\n            r,\n            c,\n            \u0026mut is_disabled,\n            \u0026mut grid,\n        );\n        let duration = start.elapsed();\n\n        // quit status\n        if status == 0 {\n            break;\n        }\n        display_status(status, duration.as_secs_f64());\n    }\n}\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":40},{"path":["/","Users","yuvikachaudhary","Desktop","Semester 4","COP290","spreadsheet_rust","src","terminal","backend.rs"],"content":"/// Terminal backend module for the spreadsheet application.\n///\n/// This module provides core functionality for managing the spreadsheet grid,\n/// handling dependencies between cells, and evaluating cell expressions.\n/// It includes functions for updating cell values, checking for cycles,\n/// and performing topological sorts on the dependency graph.\nuse crate::terminal::functions::Operation;\nuse crate::terminal::functions::avg_function;\nuse crate::terminal::functions::max_function;\nuse crate::terminal::functions::min_function;\nuse crate::terminal::functions::stdev_function;\nuse crate::terminal::functions::sum_function;\nuse crate::terminal::graph::Node;\nuse crate::terminal::types::Coordinates;\n\n///// debug -\u003e in add_and _break check which ops you are taking  ---\u003e done\n\n/// Creates a new grid with the specified number of rows and columns.\n///\n/// # Arguments\n///\n/// * `r` - The number of rows in the grid\n/// * `c` - The number of columns in the grid\n///\n/// # Returns\n///\n/// A 2D vector of `Node`s, initialized with default values\npub fn generate_grid(r: usize, c: usize) -\u003e Vec\u003cVec\u003cNode\u003e\u003e {\n    (0..r + 1)\n        .map(|i| {\n            (0..c + 1)\n                .map(|j| Node {\n                    node_value: 0,\n                    value1: Coordinates { row: -1, col: -1 },\n                    value2: Coordinates { row: -1, col: -1 },\n                    position: Coordinates {\n                        row: i as i32,\n                        col: j as i32,\n                    },\n                    op: Operation::Cons, // Default to constant assignment\n                    valid: true,\n                    visited: false,\n                    dependents: Vec::new(),\n                })\n                .collect()\n        })\n        .collect()\n}\n// wrt new node -- inward\n\n// flags : for these two functions\n// true: when working with new dependencies : value1 and value2\n// false: when working with old dependencies : old_value1 and old_value2\n\n/// Adds edges to the dependency graph based on the specified operation.\n///\n/// # Arguments\n///\n/// * `graph` - The dependency graph represented as a 2D vector of `Node`s\n/// * `value1` - The first value involved in the operation\n/// * `value2` - The second value involved in the operation\n/// * `target` - The target cell where the operation result will be stored\n/// * `op` - The operation to be performed\n/// * `flag` - A flag indicating whether to work with new dependencies (true) or old dependencies (false)\npub fn add_edges(\n    graph: \u0026mut [Vec\u003cNode\u003e],\n    value1: Coordinates,\n    value2: Coordinates,\n    target: Coordinates,\n    op: Operation,\n    flag: bool, // debug\n) {\n    let target_row = target.row as usize;\n    let target_col = target.col as usize;\n    let target_cell = \u0026mut graph[target_row][target_col];\n    if flag {\n        match op {\n            Operation::Sum | Operation::Avg | Operation::Max | Operation::Min =\u003e {\n                // For range operations, remove from all cells in the range\n                for i in value1.row..=value2.row {\n                    for j in value1.col..=value2.col {\n                        if i \u003e= 0 \u0026\u0026 j \u003e= 0 {\n                            let r = i as usize;\n                            let c = j as usize;\n                            graph[r][c].add_dep(target);\n                        }\n                    }\n                }\n            }\n            Operation::Add | Operation::Sub | Operation::Mul | Operation::Div =\u003e {\n                // For binary operations, remove dependency from value1 and value2 - check cells and values\n                if value1.col != -1 {\n                    graph[value1.row as usize][value1.col as usize].add_dep(target);\n                }\n                if value2.col != -1 {\n                    graph[value2.row as usize][value2.col as usize].add_dep(target);\n                }\n            }\n            Operation::Cons | Operation::Slp =\u003e {\n                // single cell operation just check value1 and apply the cases\n                // cell\n                if value1.col != -1 \u0026\u0026 value1.row != -1 {\n                    graph[value1.row as usize][value1.col as usize].add_dep(target);\n                }\n                // value -- do nothing\n            }\n            _ =\u003e {} // will not reach here\n        }\n    } else {\n        let old_value1 = target_cell.value1;\n        let old_value2 = target_cell.value2;\n\n        match target_cell.op {\n            Operation::Sum | Operation::Avg | Operation::Max | Operation::Min =\u003e {\n                // For range operations, remove from all cells in the range\n                for i in old_value1.row..=old_value2.row {\n                    for j in old_value1.col..=old_value2.col {\n                        if i \u003e= 0 \u0026\u0026 j \u003e= 0 {\n                            let r = i as usize;\n                            let c = j as usize;\n                            graph[r][c].add_dep(target);\n                        }\n                    }\n                }\n            }\n            Operation::Add | Operation::Sub | Operation::Mul | Operation::Div =\u003e {\n                // For binary operations, remove dependency from value1 and value2 - check cells and values\n                if old_value1.col != -1 {\n                    graph[old_value1.row as usize][old_value1.col as usize].add_dep(target);\n                }\n                if old_value2.col != -1 {\n                    graph[old_value2.row as usize][old_value2.col as usize].add_dep(target);\n                }\n            }\n            Operation::Cons | Operation::Slp =\u003e {\n                // single cell operation just check value1 and apply the cases\n                // cell\n                if old_value1.col != -1 \u0026\u0026 old_value1.row != -1 {\n                    graph[old_value1.row as usize][old_value1.col as usize].add_dep(target);\n                }\n                // value -- do nothing\n            }\n            _ =\u003e {} // will not reach here\n        }\n    }\n}\n\n// will fill when structure is more clear\n// debug -- see the old dependecies where they are stored in the graph when fully made\n// wrt new node -- inward\n\n/// Breaks edges in the dependency graph based on the specified operation.\n///\n/// # Arguments\n///\n/// * `graph` - The dependency graph represented as a 2D vector of `Node`s\n/// * `value1` - The first value involved in the operation\n/// * `value2` - The second value involved in the operation\n/// * `target` - The target cell where the operation result will be stored\n/// * `op` - The operation to be performed\n/// * `flag` - A flag indicating whether to work with new dependencies (true) or old dependencies (false)\npub fn break_edges(\n    graph: \u0026mut [Vec\u003cNode\u003e],\n    value1: Coordinates,\n    value2: Coordinates,\n    target: Coordinates,\n    op: Operation,\n    flag: bool, // debug\n) {\n    // Get the target cell\n    let target_row = target.row as usize;\n    let target_col = target.col as usize;\n    let target_cell = \u0026mut graph[target_row][target_col];\n    if flag {\n        match op {\n            Operation::Sum | Operation::Avg | Operation::Max | Operation::Min =\u003e {\n                // For range operations, remove from all cells in the range\n                for i in value1.row..=value2.row {\n                    for j in value1.col..=value2.col {\n                        if i \u003e= 0 \u0026\u0026 j \u003e= 0 {\n                            let r = i as usize;\n                            let c = j as usize;\n                            graph[r][c].remove_dep(target);\n                        }\n                    }\n                }\n            }\n            Operation::Add | Operation::Sub | Operation::Mul | Operation::Div =\u003e {\n                // For binary operations, remove dependency from value1 and value2 - check cells and values\n                if value1.col != -1 {\n                    graph[value1.row as usize][value1.col as usize].remove_dep(target);\n                }\n                if value2.col != -1 {\n                    graph[value2.row as usize][value2.col as usize].remove_dep(target);\n                }\n            }\n            Operation::Cons | Operation::Slp =\u003e {\n                // single cell operation just check value1 and apply the cases\n                // cell\n                if value1.col != -1 \u0026\u0026 value1.row != -1 {\n                    graph[value1.row as usize][value1.col as usize].remove_dep(target);\n                }\n                // value -- do nothing\n            }\n            _ =\u003e {} // will not reach here\n        }\n    } else {\n        // Get the previous dependencies (value1 and value2)\n        let old_value1 = target_cell.value1;\n        let old_value2 = target_cell.value2;\n\n        // If old value1 is valid (not -1), remove dependencies\n        // Check if the operation is range-based\n        match target_cell.op {\n            Operation::Sum | Operation::Avg | Operation::Max | Operation::Min =\u003e {\n                // For range operations, remove from all cells in the range\n                for i in old_value1.row..=old_value2.row {\n                    for j in old_value1.col..=old_value2.col {\n                        if i \u003e= 0 \u0026\u0026 j \u003e= 0 {\n                            let r = i as usize;\n                            let c = j as usize;\n                            graph[r][c].remove_dep(target);\n                        }\n                    }\n                }\n            }\n            Operation::Add | Operation::Sub | Operation::Mul | Operation::Div =\u003e {\n                // For binary operations, remove dependency from value1 and value2 - check cells and values\n                if old_value1.col != -1 {\n                    graph[old_value1.row as usize][old_value1.col as usize].remove_dep(target);\n                }\n                if old_value2.col != -1 {\n                    graph[old_value2.row as usize][old_value2.col as usize].remove_dep(target);\n                }\n            }\n            Operation::Cons | Operation::Slp =\u003e {\n                // single cell operation just check value1 and apply the cases\n                // cell\n                if old_value1.col != -1 \u0026\u0026 old_value1.row != -1 {\n                    graph[old_value1.row as usize][old_value1.col as usize].remove_dep(target);\n                }\n                // value -- do nothing\n            }\n            _ =\u003e {} // will not reach here\n        }\n    }\n}\n\n/// Updates the target cell and its dependencies in the graph.\n///\n/// # Arguments\n///\n/// * `graph` - The dependency graph represented as a 2D vector of `Node`s\n/// * `target` - The target cell to be updated\n/// * `value1` - The first value involved in the operation\n/// * `value2` - The second value involved in the operation\n/// * `op` - The operation to be performed\n///\n/// # Returns\n///\n/// An integer status code indicating success (1) or failure (5)\npub fn getting_things_updated(\n    graph: \u0026mut Vec\u003cVec\u003cNode\u003e\u003e,\n    target: Coordinates,\n    value1: Coordinates,\n    value2: Coordinates,\n    op: Operation,\n    // r: usize,\n    // c: usize,\n) -\u003e i32 {\n    // so at this point of time value1 and value2 will store the new ranges of the new function to be applied on target cell\n    // will call update_node (breaking and adding edges)\n    // break previous inward dependecies (will remove the target from its previous parents)\n    // add new dependencies of target in parent's vector\n    // old_op :\n    // println!(\"Old op: {:?}\", graph[target.row as usize][target.col as usize].op);// debug\n    break_edges(graph, value1, value2, target, op, false); // old dependencies\n    add_edges(graph, value1, value2, target, op, true); // new dependencies\n    // check if new dependecies introduces cycle\n    if has_cycle(target, graph) {\n        // println!(\"Cycle detected!\"); // debug\n        break_edges(graph, value1, value2, target, op, true); // new dependencies\n        add_edges(graph, value1, value2, target, op, false); // old dependencies\n        return 5;\n    }\n\n    // go to dependents of the cell and change their values\n    graph[target.row as usize][target.col as usize].op = op;\n    graph[target.row as usize][target.col as usize].value1.row = value1.row;\n    graph[target.row as usize][target.col as usize].value1.col = value1.col;\n    graph[target.row as usize][target.col as usize].value2.row = value2.row;\n    graph[target.row as usize][target.col as usize].value2.col = value2.col;\n\n    // evaluate_node(graph, target);\n    update_topo(graph, target);\n\n    1 // success\n}\n\n/// Updates the topological order of the graph starting from the specified cell.\n///\n/// # Arguments\n///\n/// * `graph` - The dependency graph represented as a 2D vector of `Node`s\n/// * `start` - The starting cell for the topological sort\npub fn update_topo(graph: \u0026mut Vec\u003cVec\u003cNode\u003e\u003e, start: Coordinates) {\n    let mut stack = Vec::new();\n\n    topological_sort(graph, start, \u0026mut stack);\n\n    while let Some(coord) = stack.pop() {\n        evaluate_node(graph, coord);\n    }\n\n    // Reset visited flags so next call works correctly\n    reset_visited(graph, start);\n}\n\n/// Performs a topological sort on the graph starting from the specified cell.\n///\n/// # Arguments\n///\n/// * `graph` - The dependency graph represented as a 2D vector of `Node`s\n/// * `node` - The starting cell for the topological sort\n/// * `stack` - A stack to store the sorted cells\npub fn topological_sort(\n    graph: \u0026mut Vec\u003cVec\u003cNode\u003e\u003e,\n    node: Coordinates,\n    stack: \u0026mut Vec\u003cCoordinates\u003e,\n) {\n    let (i, j) = (node.row as usize, node.col as usize);\n    if graph[i][j].visited {\n        return;\n    }\n\n    // Mark visited before recursive calls\n    graph[i][j].visited = true;\n\n    // Clone dependents to avoid borrowing `graph[i][j]` during iteration\n    let dependents = graph[i][j].dependents.clone();\n\n    for dep in dependents {\n        topological_sort(graph, dep, stack);\n    }\n\n    stack.push(node);\n}\n\n/// Evaluates the value of a node based on its operation and dependencies.\n///\n/// # Arguments\n///\n/// * `graph` - The dependency graph represented as a 2D vector of `Node`s\n/// * `coord` - The coordinates of the node to be evaluated\npub fn evaluate_node(graph: \u0026mut [Vec\u003cNode\u003e], coord: Coordinates) {\n    let row = coord.row as usize;\n    let col = coord.col as usize;\n\n    // extract value1 and value2 before borrowing node\n    let value1 = graph[row][col].value1;\n    let value2 = graph[row][col].value2;\n    //  check here it is going out of bounds (A1=3 - like first command it will go out of bounds)\n    // let value1_valid = graph[value1.row as usize][value1.col as usize].valid;\n    let value1_valid = if value1.row \u003e= 0\n        \u0026\u0026 value1.col \u003e= 0\n        \u0026\u0026 (value1.row as usize) \u003c graph.len()\n        \u0026\u0026 (value1.col as usize) \u003c graph[0].len()\n    {\n        graph[value1.row as usize][value1.col as usize].valid\n    } else {\n        true // assume constants are always valid\n    };\n    let value2_valid = if value2.row \u003e= 0\n        \u0026\u0026 value2.col \u003e= 0\n        \u0026\u0026 (value2.row as usize) \u003c graph.len()\n        \u0026\u0026 (value2.col as usize) \u003c graph[0].len()\n    {\n        graph[value2.row as usize][value2.col as usize].valid\n    } else {\n        true // assume constants are always valid\n    };\n    // let value2_valid = graph[value2.row as usize][value2.col as usize].valid;\n    let value1_node_value = if value1.row \u003e= 0\n        \u0026\u0026 value1.col \u003e= 0\n        \u0026\u0026 (value1.row as usize) \u003c graph.len()\n        \u0026\u0026 (value1.col as usize) \u003c graph[0].len()\n    {\n        graph[value1.row as usize][value1.col as usize].node_value\n    } else {\n        value1.row // constant\n    };\n\n    let value2_node_value = if value2.row \u003e= 0\n        \u0026\u0026 value2.col \u003e= 0\n        \u0026\u0026 (value2.row as usize) \u003c graph.len()\n        \u0026\u0026 (value2.col as usize) \u003c graph[0].len()\n    {\n        graph[value2.row as usize][value2.col as usize].node_value\n    } else {\n        value2.row // constant\n    };\n    let op = graph[row][col].op;\n\n    // evaluate range result before mutable borrow\n    let range_result = match op {\n        Operation::Min =\u003e min_function(value1, value2, graph),\n        Operation::Max =\u003e max_function(value1, value2, graph),\n        Operation::Avg =\u003e avg_function(value1, value2, graph),\n        Operation::Sum =\u003e sum_function(value1, value2, graph),\n        Operation::Std =\u003e stdev_function(value1, value2, graph),\n        _ =\u003e None,\n    };\n\n    let node = \u0026mut graph[row][col];\n\n    match node.op {\n        Operation::Add =\u003e {\n            // V V\n            if node.value1.col == -1 \u0026\u0026 node.value2.col == -1 {\n                node.valid = true;\n                node.node_value = node.value1.row + node.value2.row;\n            }\n            // V C\n            else if node.value1.col == -1 {\n                if value2_valid {\n                    node.valid = true;\n                    node.node_value = node.value1.row + value2_node_value;\n                } else {\n                    node.valid = false;\n                }\n            }\n            // C V\n            else if node.value2.col == -1 {\n                if value1_valid {\n                    node.valid = true;\n                    node.node_value = value1_node_value + node.value2.row;\n                } else {\n                    node.valid = false;\n                }\n            }\n            // C C\n            else if value1_valid \u0026\u0026 value2_valid {\n                node.valid = true;\n                node.node_value = value1_node_value + value2_node_value;\n            } else {\n                node.valid = false;\n            }\n        }\n        Operation::Sub =\u003e {\n            // V V\n            if node.value1.col == -1 \u0026\u0026 node.value2.col == -1 {\n                node.valid = true;\n                node.node_value = node.value1.row - node.value2.row;\n            }\n            // V C\n            else if node.value1.col == -1 {\n                if value2_valid {\n                    node.valid = true;\n                    node.node_value = node.value1.row - value2_node_value;\n                } else {\n                    node.valid = false;\n                }\n            }\n            // C V\n            else if node.value2.col == -1 {\n                if value1_valid {\n                    node.valid = true;\n                    node.node_value = value1_node_value - node.value2.row;\n                } else {\n                    node.valid = false;\n                }\n            }\n            // C C\n            else if value1_valid \u0026\u0026 value2_valid {\n                node.valid = true;\n                node.node_value = value1_node_value - value2_node_value;\n            } else {\n                node.valid = false;\n            }\n        }\n        Operation::Mul =\u003e {\n            // V V\n            if node.value1.col == -1 \u0026\u0026 node.value2.col == -1 {\n                node.valid = true;\n                node.node_value = node.value1.row * node.value2.row;\n            }\n            // V C\n            else if node.value1.col == -1 {\n                if value2_valid {\n                    node.valid = true;\n                    node.node_value = node.value1.row * value2_node_value;\n                } else {\n                    node.valid = false;\n                }\n            }\n            // C V\n            else if node.value2.col == -1 {\n                if value1_valid {\n                    node.valid = true;\n                    node.node_value = value1_node_value * node.value2.row;\n                } else {\n                    node.valid = false;\n                }\n            }\n            // C C\n            else if value1_valid \u0026\u0026 value2_valid {\n                node.valid = true;\n                node.node_value = value1_node_value * value2_node_value;\n            } else {\n                node.valid = false;\n            }\n        }\n        Operation::Div =\u003e {\n            // handle ERR here /// debug\n            // V V\n            if node.value1.col == -1 \u0026\u0026 node.value2.col == -1 {\n                if node.value2.row == 0 {\n                    node.valid = false;\n                } else {\n                    node.valid = true;\n                    node.node_value = node.value1.row / node.value2.row;\n                }\n            }\n            // V C\n            else if node.value1.col == -1 {\n                if value2_valid {\n                    if value2_node_value == 0 {\n                        node.valid = false;\n                    } else {\n                        node.valid = true;\n                        node.node_value = node.value1.row / value2_node_value;\n                    }\n                } else {\n                    node.valid = false;\n                }\n            }\n            // C V\n            else if node.value2.col == -1 {\n                if value1_valid {\n                    if node.value2.row == 0 {\n                        node.valid = false;\n                    } else {\n                        node.valid = true;\n                        node.node_value = value1_node_value / node.value2.row;\n                    }\n                } else {\n                    node.valid = false;\n                }\n            }\n            // C C\n            else if value1_valid \u0026\u0026 value2_valid {\n                if value2_node_value == 0 {\n                    node.valid = false;\n                } else {\n                    node.valid = true;\n                    node.node_value = value1_node_value / value2_node_value;\n                }\n            } else {\n                node.valid = false;\n            }\n        }\n        // range based functions\n        Operation::Min | Operation::Max | Operation::Avg | Operation::Sum | Operation::Std =\u003e {\n            if let Some(result) = range_result {\n                node.node_value = result;\n                node.valid = true;\n            } else {\n                node.valid = false;\n            }\n        }\n        // sleep function\n        Operation::Slp =\u003e {\n            // Handle sleep operation\n            // std::thread::sleep(std::time::Duration::from_secs(1));\n            // V or C\n            if (node.value1.col == -1 \u0026\u0026 node.value2.col == -1) || value1_valid {\n                node.valid = true;\n                node.node_value = value1_node_value;\n                std::thread::sleep(std::time::Duration::from_secs(value1_node_value as u64));\n            } else {\n                node.valid = false;\n            }\n        }\n        #[allow(clippy::if_same_then_else)]\n        Operation::Cons =\u003e {\n            // Handle constant assignment\n            // No operation needed, just set the value\n            node.valid = true;\n            // V\n            if node.value1.col == -1 \u0026\u0026 node.value2.col == -1 {\n                node.valid = true;\n                node.node_value = value1_node_value;\n            }\n            // C\n            else if value1_valid {\n                node.valid = true;\n                node.node_value = value1_node_value;\n            } else {\n                node.valid = false;\n            }\n        }\n        _ =\u003e {}\n    }\n}\n\n/// Checks for cycles in the dependency graph starting from the target cell.\n///\n/// # Arguments\n///\n/// * `target` - The target cell to check for cycles\n/// * `graph` - The dependency graph represented as a 2D vector of `Node`s\n///\n/// # Returns\n///\n/// A boolean indicating whether a cycle was detected (true) or not (false)\npub fn has_cycle(target: Coordinates, graph: \u0026mut [Vec\u003cNode\u003e]) -\u003e bool {\n    // check for cycle using iterative DFS\n    // use stack\n    // reset visited flags\n    let mut stack = vec![target];\n    graph[target.row as usize][target.col as usize].visited = true;\n    while let Some(node1) = stack.pop() {\n        // borrow checker error\n        // let node = \u0026mut graph[node1.row as usize][node1.col as usize];\n        let dependents = graph[node1.row as usize][node1.col as usize]\n            .dependents\n            .clone();\n\n        for dep in dependents {\n            if dep.row == target.row \u0026\u0026 dep.col == target.col {\n                // back edge to target → cycle\n                reset_visited(graph, target);\n                return true;\n            }\n\n            if !graph[dep.row as usize][dep.col as usize].visited {\n                graph[dep.row as usize][dep.col as usize].visited = true;\n                stack.push(dep);\n            }\n        }\n    }\n\n    reset_visited(graph, target);\n    false\n}\n\n// redo dfs to reset flags\n\n/// Resets the visited flags in the graph starting from the specified cell.\n///\n/// # Arguments\n///\n/// * `graph` - The dependency graph represented as a 2D vector of `Node`s\n/// * `start` - The starting cell for resetting visited flags\npub fn reset_visited(graph: \u0026mut [Vec\u003cNode\u003e], start: Coordinates) {\n    let mut stack = vec![start];\n    graph[start.row as usize][start.col as usize].visited = false;\n\n    while let Some(node1) = stack.pop() {\n        // clone dependents first\n        let dependents = graph[node1.row as usize][node1.col as usize]\n            .dependents\n            .clone();\n\n        for dep in dependents {\n            let dep_node = \u0026mut graph[dep.row as usize][dep.col as usize];\n            if dep_node.visited {\n                dep_node.visited = false;\n                stack.push(dep);\n            }\n        }\n    }\n}\n","traces":[{"line":28,"address":[],"length":0,"stats":{"Line":37}},{"line":29,"address":[],"length":0,"stats":{"Line":37}},{"line":30,"address":[],"length":0,"stats":{"Line":185}},{"line":31,"address":[],"length":0,"stats":{"Line":148}},{"line":32,"address":[],"length":0,"stats":{"Line":740}},{"line":33,"address":[],"length":0,"stats":{"Line":592}},{"line":34,"address":[],"length":0,"stats":{"Line":592}},{"line":35,"address":[],"length":0,"stats":{"Line":592}},{"line":36,"address":[],"length":0,"stats":{"Line":592}},{"line":37,"address":[],"length":0,"stats":{"Line":592}},{"line":38,"address":[],"length":0,"stats":{"Line":592}},{"line":40,"address":[],"length":0,"stats":{"Line":592}},{"line":41,"address":[],"length":0,"stats":{"Line":592}},{"line":42,"address":[],"length":0,"stats":{"Line":592}},{"line":43,"address":[],"length":0,"stats":{"Line":592}},{"line":45,"address":[],"length":0,"stats":{"Line":148}},{"line":65,"address":[],"length":0,"stats":{"Line":38}},{"line":73,"address":[],"length":0,"stats":{"Line":38}},{"line":74,"address":[],"length":0,"stats":{"Line":38}},{"line":75,"address":[],"length":0,"stats":{"Line":38}},{"line":76,"address":[],"length":0,"stats":{"Line":38}},{"line":77,"address":[],"length":0,"stats":{"Line":37}},{"line":80,"address":[],"length":0,"stats":{"Line":6}},{"line":81,"address":[],"length":0,"stats":{"Line":12}},{"line":82,"address":[],"length":0,"stats":{"Line":24}},{"line":83,"address":[],"length":0,"stats":{"Line":8}},{"line":84,"address":[],"length":0,"stats":{"Line":8}},{"line":85,"address":[],"length":0,"stats":{"Line":8}},{"line":92,"address":[],"length":0,"stats":{"Line":66}},{"line":93,"address":[],"length":0,"stats":{"Line":33}},{"line":95,"address":[],"length":0,"stats":{"Line":56}},{"line":96,"address":[],"length":0,"stats":{"Line":23}},{"line":102,"address":[],"length":0,"stats":{"Line":1}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":1}},{"line":110,"address":[],"length":0,"stats":{"Line":1}},{"line":111,"address":[],"length":0,"stats":{"Line":1}},{"line":113,"address":[],"length":0,"stats":{"Line":1}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":1}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":11}},{"line":171,"address":[],"length":0,"stats":{"Line":11}},{"line":172,"address":[],"length":0,"stats":{"Line":11}},{"line":173,"address":[],"length":0,"stats":{"Line":11}},{"line":174,"address":[],"length":0,"stats":{"Line":11}},{"line":175,"address":[],"length":0,"stats":{"Line":3}},{"line":178,"address":[],"length":0,"stats":{"Line":3}},{"line":179,"address":[],"length":0,"stats":{"Line":6}},{"line":180,"address":[],"length":0,"stats":{"Line":12}},{"line":181,"address":[],"length":0,"stats":{"Line":4}},{"line":182,"address":[],"length":0,"stats":{"Line":4}},{"line":183,"address":[],"length":0,"stats":{"Line":4}},{"line":190,"address":[],"length":0,"stats":{"Line":4}},{"line":191,"address":[],"length":0,"stats":{"Line":2}},{"line":193,"address":[],"length":0,"stats":{"Line":3}},{"line":194,"address":[],"length":0,"stats":{"Line":1}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":8}},{"line":210,"address":[],"length":0,"stats":{"Line":8}},{"line":214,"address":[],"length":0,"stats":{"Line":8}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":10}},{"line":230,"address":[],"length":0,"stats":{"Line":5}},{"line":232,"address":[],"length":0,"stats":{"Line":10}},{"line":233,"address":[],"length":0,"stats":{"Line":5}},{"line":239,"address":[],"length":0,"stats":{"Line":3}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":8}},{"line":277,"address":[],"length":0,"stats":{"Line":8}},{"line":278,"address":[],"length":0,"stats":{"Line":8}},{"line":280,"address":[],"length":0,"stats":{"Line":8}},{"line":282,"address":[],"length":0,"stats":{"Line":1}},{"line":283,"address":[],"length":0,"stats":{"Line":1}},{"line":284,"address":[],"length":0,"stats":{"Line":1}},{"line":288,"address":[],"length":0,"stats":{"Line":7}},{"line":289,"address":[],"length":0,"stats":{"Line":7}},{"line":290,"address":[],"length":0,"stats":{"Line":7}},{"line":291,"address":[],"length":0,"stats":{"Line":7}},{"line":292,"address":[],"length":0,"stats":{"Line":7}},{"line":295,"address":[],"length":0,"stats":{"Line":7}},{"line":297,"address":[],"length":0,"stats":{"Line":7}},{"line":306,"address":[],"length":0,"stats":{"Line":8}},{"line":307,"address":[],"length":0,"stats":{"Line":8}},{"line":309,"address":[],"length":0,"stats":{"Line":8}},{"line":311,"address":[],"length":0,"stats":{"Line":38}},{"line":312,"address":[],"length":0,"stats":{"Line":10}},{"line":316,"address":[],"length":0,"stats":{"Line":8}},{"line":326,"address":[],"length":0,"stats":{"Line":13}},{"line":331,"address":[],"length":0,"stats":{"Line":13}},{"line":332,"address":[],"length":0,"stats":{"Line":13}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":13}},{"line":340,"address":[],"length":0,"stats":{"Line":13}},{"line":342,"address":[],"length":0,"stats":{"Line":25}},{"line":343,"address":[],"length":0,"stats":{"Line":4}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":84}},{"line":356,"address":[],"length":0,"stats":{"Line":84}},{"line":357,"address":[],"length":0,"stats":{"Line":84}},{"line":360,"address":[],"length":0,"stats":{"Line":84}},{"line":361,"address":[],"length":0,"stats":{"Line":84}},{"line":364,"address":[],"length":0,"stats":{"Line":168}},{"line":365,"address":[],"length":0,"stats":{"Line":84}},{"line":366,"address":[],"length":0,"stats":{"Line":27}},{"line":367,"address":[],"length":0,"stats":{"Line":23}},{"line":369,"address":[],"length":0,"stats":{"Line":23}},{"line":371,"address":[],"length":0,"stats":{"Line":61}},{"line":373,"address":[],"length":0,"stats":{"Line":168}},{"line":374,"address":[],"length":0,"stats":{"Line":29}},{"line":375,"address":[],"length":0,"stats":{"Line":20}},{"line":376,"address":[],"length":0,"stats":{"Line":20}},{"line":378,"address":[],"length":0,"stats":{"Line":20}},{"line":380,"address":[],"length":0,"stats":{"Line":64}},{"line":383,"address":[],"length":0,"stats":{"Line":168}},{"line":384,"address":[],"length":0,"stats":{"Line":84}},{"line":385,"address":[],"length":0,"stats":{"Line":27}},{"line":386,"address":[],"length":0,"stats":{"Line":23}},{"line":388,"address":[],"length":0,"stats":{"Line":23}},{"line":390,"address":[],"length":0,"stats":{"Line":61}},{"line":393,"address":[],"length":0,"stats":{"Line":168}},{"line":394,"address":[],"length":0,"stats":{"Line":29}},{"line":395,"address":[],"length":0,"stats":{"Line":20}},{"line":396,"address":[],"length":0,"stats":{"Line":20}},{"line":398,"address":[],"length":0,"stats":{"Line":20}},{"line":400,"address":[],"length":0,"stats":{"Line":64}},{"line":402,"address":[],"length":0,"stats":{"Line":84}},{"line":405,"address":[],"length":0,"stats":{"Line":168}},{"line":406,"address":[],"length":0,"stats":{"Line":1}},{"line":407,"address":[],"length":0,"stats":{"Line":1}},{"line":408,"address":[],"length":0,"stats":{"Line":1}},{"line":409,"address":[],"length":0,"stats":{"Line":1}},{"line":410,"address":[],"length":0,"stats":{"Line":1}},{"line":411,"address":[],"length":0,"stats":{"Line":79}},{"line":414,"address":[],"length":0,"stats":{"Line":84}},{"line":416,"address":[],"length":0,"stats":{"Line":84}},{"line":419,"address":[],"length":0,"stats":{"Line":11}},{"line":420,"address":[],"length":0,"stats":{"Line":1}},{"line":421,"address":[],"length":0,"stats":{"Line":1}},{"line":424,"address":[],"length":0,"stats":{"Line":7}},{"line":425,"address":[],"length":0,"stats":{"Line":2}},{"line":426,"address":[],"length":0,"stats":{"Line":1}},{"line":427,"address":[],"length":0,"stats":{"Line":1}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":6}},{"line":434,"address":[],"length":0,"stats":{"Line":4}},{"line":435,"address":[],"length":0,"stats":{"Line":2}},{"line":436,"address":[],"length":0,"stats":{"Line":2}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":11}},{"line":443,"address":[],"length":0,"stats":{"Line":3}},{"line":444,"address":[],"length":0,"stats":{"Line":3}},{"line":446,"address":[],"length":0,"stats":{"Line":1}},{"line":451,"address":[],"length":0,"stats":{"Line":9}},{"line":452,"address":[],"length":0,"stats":{"Line":1}},{"line":453,"address":[],"length":0,"stats":{"Line":1}},{"line":456,"address":[],"length":0,"stats":{"Line":5}},{"line":457,"address":[],"length":0,"stats":{"Line":2}},{"line":458,"address":[],"length":0,"stats":{"Line":1}},{"line":459,"address":[],"length":0,"stats":{"Line":1}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":465,"address":[],"length":0,"stats":{"Line":4}},{"line":466,"address":[],"length":0,"stats":{"Line":2}},{"line":467,"address":[],"length":0,"stats":{"Line":1}},{"line":468,"address":[],"length":0,"stats":{"Line":1}},{"line":470,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[],"length":0,"stats":{"Line":9}},{"line":475,"address":[],"length":0,"stats":{"Line":3}},{"line":476,"address":[],"length":0,"stats":{"Line":3}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":483,"address":[],"length":0,"stats":{"Line":10}},{"line":484,"address":[],"length":0,"stats":{"Line":1}},{"line":485,"address":[],"length":0,"stats":{"Line":1}},{"line":488,"address":[],"length":0,"stats":{"Line":6}},{"line":489,"address":[],"length":0,"stats":{"Line":2}},{"line":490,"address":[],"length":0,"stats":{"Line":1}},{"line":491,"address":[],"length":0,"stats":{"Line":1}},{"line":493,"address":[],"length":0,"stats":{"Line":0}},{"line":497,"address":[],"length":0,"stats":{"Line":5}},{"line":498,"address":[],"length":0,"stats":{"Line":6}},{"line":499,"address":[],"length":0,"stats":{"Line":3}},{"line":500,"address":[],"length":0,"stats":{"Line":3}},{"line":502,"address":[],"length":0,"stats":{"Line":0}},{"line":506,"address":[],"length":0,"stats":{"Line":6}},{"line":507,"address":[],"length":0,"stats":{"Line":2}},{"line":508,"address":[],"length":0,"stats":{"Line":2}},{"line":510,"address":[],"length":0,"stats":{"Line":0}},{"line":516,"address":[],"length":0,"stats":{"Line":3}},{"line":517,"address":[],"length":0,"stats":{"Line":0}},{"line":518,"address":[],"length":0,"stats":{"Line":0}},{"line":520,"address":[],"length":0,"stats":{"Line":0}},{"line":521,"address":[],"length":0,"stats":{"Line":0}},{"line":525,"address":[],"length":0,"stats":{"Line":3}},{"line":526,"address":[],"length":0,"stats":{"Line":0}},{"line":527,"address":[],"length":0,"stats":{"Line":0}},{"line":528,"address":[],"length":0,"stats":{"Line":0}},{"line":530,"address":[],"length":0,"stats":{"Line":0}},{"line":531,"address":[],"length":0,"stats":{"Line":0}},{"line":534,"address":[],"length":0,"stats":{"Line":0}},{"line":538,"address":[],"length":0,"stats":{"Line":3}},{"line":539,"address":[],"length":0,"stats":{"Line":0}},{"line":540,"address":[],"length":0,"stats":{"Line":0}},{"line":541,"address":[],"length":0,"stats":{"Line":0}},{"line":543,"address":[],"length":0,"stats":{"Line":0}},{"line":544,"address":[],"length":0,"stats":{"Line":0}},{"line":547,"address":[],"length":0,"stats":{"Line":0}},{"line":551,"address":[],"length":0,"stats":{"Line":6}},{"line":552,"address":[],"length":0,"stats":{"Line":5}},{"line":553,"address":[],"length":0,"stats":{"Line":2}},{"line":555,"address":[],"length":0,"stats":{"Line":1}},{"line":556,"address":[],"length":0,"stats":{"Line":1}},{"line":559,"address":[],"length":0,"stats":{"Line":0}},{"line":564,"address":[],"length":0,"stats":{"Line":10}},{"line":565,"address":[],"length":0,"stats":{"Line":0}},{"line":566,"address":[],"length":0,"stats":{"Line":0}},{"line":568,"address":[],"length":0,"stats":{"Line":0}},{"line":576,"address":[],"length":0,"stats":{"Line":3}},{"line":577,"address":[],"length":0,"stats":{"Line":1}},{"line":578,"address":[],"length":0,"stats":{"Line":1}},{"line":579,"address":[],"length":0,"stats":{"Line":1}},{"line":581,"address":[],"length":0,"stats":{"Line":0}},{"line":588,"address":[],"length":0,"stats":{"Line":54}},{"line":590,"address":[],"length":0,"stats":{"Line":154}},{"line":591,"address":[],"length":0,"stats":{"Line":50}},{"line":592,"address":[],"length":0,"stats":{"Line":50}},{"line":595,"address":[],"length":0,"stats":{"Line":8}},{"line":596,"address":[],"length":0,"stats":{"Line":4}},{"line":597,"address":[],"length":0,"stats":{"Line":4}},{"line":599,"address":[],"length":0,"stats":{"Line":0}},{"line":602,"address":[],"length":0,"stats":{"Line":0}},{"line":616,"address":[],"length":0,"stats":{"Line":11}},{"line":620,"address":[],"length":0,"stats":{"Line":11}},{"line":621,"address":[],"length":0,"stats":{"Line":11}},{"line":622,"address":[],"length":0,"stats":{"Line":38}},{"line":625,"address":[],"length":0,"stats":{"Line":0}},{"line":626,"address":[],"length":0,"stats":{"Line":0}},{"line":629,"address":[],"length":0,"stats":{"Line":26}},{"line":630,"address":[],"length":0,"stats":{"Line":7}},{"line":632,"address":[],"length":0,"stats":{"Line":3}},{"line":633,"address":[],"length":0,"stats":{"Line":3}},{"line":636,"address":[],"length":0,"stats":{"Line":8}},{"line":637,"address":[],"length":0,"stats":{"Line":4}},{"line":638,"address":[],"length":0,"stats":{"Line":4}},{"line":643,"address":[],"length":0,"stats":{"Line":8}},{"line":644,"address":[],"length":0,"stats":{"Line":8}},{"line":655,"address":[],"length":0,"stats":{"Line":20}},{"line":656,"address":[],"length":0,"stats":{"Line":20}},{"line":657,"address":[],"length":0,"stats":{"Line":20}},{"line":659,"address":[],"length":0,"stats":{"Line":76}},{"line":661,"address":[],"length":0,"stats":{"Line":0}},{"line":662,"address":[],"length":0,"stats":{"Line":0}},{"line":665,"address":[],"length":0,"stats":{"Line":50}},{"line":666,"address":[],"length":0,"stats":{"Line":0}},{"line":667,"address":[],"length":0,"stats":{"Line":8}},{"line":668,"address":[],"length":0,"stats":{"Line":8}},{"line":669,"address":[],"length":0,"stats":{"Line":8}}],"covered":212,"coverable":274},{"path":["/","Users","yuvikachaudhary","Desktop","Semester 4","COP290","spreadsheet_rust","src","terminal","functions.rs"],"content":"/// Module for spreadsheet functions implementation.\n///\n/// Provides implementations of various cell operations including:\n/// - Range-based operations (SUM, MIN, MAX, AVG, STDEV)\n/// - Arithmetic operations (Add, Sub, Mul, Div)\n/// - Special operations like Sleep and Constant assignment\n///\n/// These functions are the core computational elements of the spreadsheet.\nuse crate::terminal::graph::Node;\nuse crate::terminal::types::Coordinates;\nuse std::cmp::{max, min};\n\n/// Represents a range of cells in the spreadsheet.\n///\n/// Used for range-based functions like SUM, MIN, MAX, AVG, and STDEV\n/// to specify the corners of a rectangular selection of cells.\npub struct Range {\n    /// The starting cell (top-left corner) of the range\n    pub start: Coordinates,\n\n    /// The ending cell (bottom-right corner) of the range\n    pub end: Coordinates,\n}\n\n/// Supported operations in the spreadsheet.\n///\n/// This enum defines all possible operations that can be performed\n/// on cells in the spreadsheet, including both arithmetic operations\n/// and range-based functions.\n#[derive(Clone, Copy, Debug, PartialEq, Default)]\npub enum Operation {\n    /// Assign a constant value to a cell\n    #[default]\n    Cons,\n\n    /// Add two values\n    Add,\n\n    /// Subtract one value from another\n    Sub,\n\n    /// Multiply two values\n    Mul,\n\n    /// Divide one value by another\n    Div,\n\n    /// Find the minimum value in a range\n    Min,\n\n    /// Find the maximum value in a range\n    Max,\n\n    /// Calculate the average of values in a range\n    Avg,\n\n    /// Calculate the sum of values in a range\n    Sum,\n\n    /// Calculate the standard deviation of values in a range\n    Std,\n\n    /// Sleep operation (pause execution)\n    Slp,\n\n    /// Enable output to the terminal\n    EnableOutput,\n\n    /// Disable output to the terminal\n    DisableOutput,\n\n    /// Scroll to a specific cell\n    Scrollto,\n}\n\n/// Represents a value in the spreadsheet expression system.\n///\n/// Values can be cell references, constants, or operations involving\n/// other values.\n#[derive(Debug, PartialEq)]\npub enum Value {\n    /// A cell reference with row and column indices\n    Cell(i32, i32),\n\n    /// A constant integer value\n    Const(isize),\n\n    /// An operation involving two values and an operator\n    Oper(Box\u003cValue\u003e, Box\u003cValue\u003e, Operation),\n}\n\n/// Computes the maximum value in a specified range of cells.\n///\n/// # Arguments\n///\n/// * `value1` - The starting cell (top-left corner) of the range.\n/// * `value2` - The ending cell (bottom-right corner) of the range.\n/// * `grid` - The 2D array representing the spreadsheet.\n///\n/// # Returns\n///\n/// * `Some(i32)` - The maximum value in the range if all cells are valid.\n/// * `None` - If any cell in the range is invalid.\npub fn max_function(value1: Coordinates, value2: Coordinates, grid: \u0026[Vec\u003cNode\u003e]) -\u003e Option\u003ci32\u003e {\n    let mut max_val = i32::MIN;\n    for i in value1.row..=value2.row {\n        for j in value1.col..=value2.col {\n            if grid[i as usize][j as usize].valid {\n                max_val = max(max_val, grid[i as usize][j as usize].node_value);\n            } else {\n                return None;\n            }\n        }\n    }\n    Some(max_val)\n}\n\n/// Computes the minimum value in a specified range of cells.\n///\n/// # Arguments\n///\n/// * `value1` - The starting cell (top-left corner) of the range.\n/// * `value2` - The ending cell (bottom-right corner) of the range.\n/// * `grid` - The 2D array representing the spreadsheet.\n///\n/// # Returns\n///\n/// * `Some(i32)` - The minimum value in the range if all cells are valid.\n/// * `None` - If any cell in the range is invalid.\npub fn min_function(value1: Coordinates, value2: Coordinates, grid: \u0026[Vec\u003cNode\u003e]) -\u003e Option\u003ci32\u003e {\n    let mut min_val = i32::MAX;\n    for i in value1.row..=value2.row {\n        for j in value1.col..=value2.col {\n            if grid[i as usize][j as usize].valid {\n                min_val = min(min_val, grid[i as usize][j as usize].node_value);\n            } else {\n                return None;\n            }\n        }\n    }\n    Some(min_val)\n}\n\n/// Computes the average value in a specified range of cells.\n///\n/// # Arguments\n///\n/// * `value1` - The starting cell (top-left corner) of the range.\n/// * `value2` - The ending cell (bottom-right corner) of the range.\n/// * `grid` - The 2D array representing the spreadsheet.\n///\n/// # Returns\n///\n/// * `Some(i32)` - The average value in the range if all cells are valid.\n/// * `None` - If any cell in the range is invalid.\npub fn avg_function(value1: Coordinates, value2: Coordinates, grid: \u0026[Vec\u003cNode\u003e]) -\u003e Option\u003ci32\u003e {\n    let mut sum = 0;\n    let mut count = 0;\n    for i in value1.row..=value2.row {\n        for j in value1.col..=value2.col {\n            if grid[i as usize][j as usize].valid {\n                sum += grid[i as usize][j as usize].node_value;\n                count += 1;\n            } else {\n                return None;\n            }\n        }\n    }\n    if count == 0 { None } else { Some(sum / count) }\n}\n\n/// Computes the sum of values in a specified range of cells.\n///\n/// # Arguments\n///\n/// * `value1` - The starting cell (top-left corner) of the range.\n/// * `value2` - The ending cell (bottom-right corner) of the range.\n/// * `grid` - The 2D array representing the spreadsheet.\n///\n/// # Returns\n///\n/// * `Some(i32)` - The sum of values in the range if all cells are valid.\n/// * `None` - If any cell in the range is invalid.\npub fn sum_function(value1: Coordinates, value2: Coordinates, grid: \u0026[Vec\u003cNode\u003e]) -\u003e Option\u003ci32\u003e {\n    let mut sum = 0;\n    for i in value1.row..=value2.row {\n        for j in value1.col..=value2.col {\n            if grid[i as usize][j as usize].valid {\n                sum += grid[i as usize][j as usize].node_value;\n            } else {\n                return None;\n            }\n        }\n    }\n    Some(sum)\n}\n\n/// Computes the standard deviation of values in a specified range of cells.\n///\n/// # Arguments\n///\n/// * `value1` - The starting cell (top-left corner) of the range.\n/// * `value2` - The ending cell (bottom-right corner) of the range.\n/// * `grid` - The 2D array representing the spreadsheet.\n///\n/// # Returns\n///\n/// * `Some(i32)` - The standard deviation of values in the range if all cells are valid.\n/// * `None` - If any cell in the range is invalid.\npub fn stdev_function(value1: Coordinates, value2: Coordinates, grid: \u0026[Vec\u003cNode\u003e]) -\u003e Option\u003ci32\u003e {\n    let mut sum = 0f64;\n    let mut count = 0;\n\n    // First pass: calculate sum and count\n    for i in value1.row..=value2.row {\n        for j in value1.col..=value2.col {\n            let node = \u0026grid[i as usize][j as usize];\n            if node.valid {\n                sum += node.node_value as f64;\n                count += 1;\n            } else {\n                return None;\n            }\n        }\n    }\n\n    if count == 0 {\n        return Some(0); // Consistent with C behavior\n    }\n\n    let mean = sum / count as f64;\n\n    // Second pass: calculate variance\n    let mut stdev = 0f64;\n    for i in value1.row..=value2.row {\n        for j in value1.col..=value2.col {\n            let node = \u0026grid[i as usize][j as usize];\n            if !node.valid {\n                return None; // In C, this sets the target to invalid\n            }\n            let val = node.node_value as f64;\n            stdev += (val - mean) * (val - mean);\n        }\n    }\n\n    let result = (stdev / count as f64).sqrt().round() as i32;\n    Some(result)\n}\n\n/// Checks if the given operation is an arithmetic operation.\n///\n/// # Arguments\n///\n/// * `op` - The operation to check.\n///\n/// # Returns\n///\n/// * `true` - If the operation is Add, Sub, Mul, or Div.\n/// * `false` - Otherwise.\npub fn is_arithmetic(op: Operation) -\u003e bool {\n    matches!(\n        op,\n        Operation::Add | Operation::Sub | Operation::Mul | Operation::Div\n    )\n}\n","traces":[{"line":104,"address":[],"length":0,"stats":{"Line":5}},{"line":105,"address":[],"length":0,"stats":{"Line":5}},{"line":106,"address":[],"length":0,"stats":{"Line":14}},{"line":107,"address":[],"length":0,"stats":{"Line":30}},{"line":108,"address":[],"length":0,"stats":{"Line":41}},{"line":109,"address":[],"length":0,"stats":{"Line":20}},{"line":111,"address":[],"length":0,"stats":{"Line":1}},{"line":115,"address":[],"length":0,"stats":{"Line":4}},{"line":130,"address":[],"length":0,"stats":{"Line":5}},{"line":131,"address":[],"length":0,"stats":{"Line":5}},{"line":132,"address":[],"length":0,"stats":{"Line":14}},{"line":133,"address":[],"length":0,"stats":{"Line":30}},{"line":134,"address":[],"length":0,"stats":{"Line":41}},{"line":135,"address":[],"length":0,"stats":{"Line":20}},{"line":137,"address":[],"length":0,"stats":{"Line":1}},{"line":141,"address":[],"length":0,"stats":{"Line":4}},{"line":156,"address":[],"length":0,"stats":{"Line":6}},{"line":157,"address":[],"length":0,"stats":{"Line":6}},{"line":158,"address":[],"length":0,"stats":{"Line":6}},{"line":159,"address":[],"length":0,"stats":{"Line":14}},{"line":160,"address":[],"length":0,"stats":{"Line":24}},{"line":161,"address":[],"length":0,"stats":{"Line":31}},{"line":162,"address":[],"length":0,"stats":{"Line":15}},{"line":163,"address":[],"length":0,"stats":{"Line":15}},{"line":165,"address":[],"length":0,"stats":{"Line":1}},{"line":169,"address":[],"length":0,"stats":{"Line":10}},{"line":184,"address":[],"length":0,"stats":{"Line":8}},{"line":185,"address":[],"length":0,"stats":{"Line":8}},{"line":186,"address":[],"length":0,"stats":{"Line":20}},{"line":187,"address":[],"length":0,"stats":{"Line":32}},{"line":188,"address":[],"length":0,"stats":{"Line":39}},{"line":189,"address":[],"length":0,"stats":{"Line":19}},{"line":191,"address":[],"length":0,"stats":{"Line":1}},{"line":195,"address":[],"length":0,"stats":{"Line":7}},{"line":210,"address":[],"length":0,"stats":{"Line":7}},{"line":211,"address":[],"length":0,"stats":{"Line":7}},{"line":212,"address":[],"length":0,"stats":{"Line":7}},{"line":215,"address":[],"length":0,"stats":{"Line":18}},{"line":216,"address":[],"length":0,"stats":{"Line":33}},{"line":217,"address":[],"length":0,"stats":{"Line":22}},{"line":218,"address":[],"length":0,"stats":{"Line":43}},{"line":219,"address":[],"length":0,"stats":{"Line":21}},{"line":220,"address":[],"length":0,"stats":{"Line":21}},{"line":222,"address":[],"length":0,"stats":{"Line":1}},{"line":227,"address":[],"length":0,"stats":{"Line":6}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":6}},{"line":234,"address":[],"length":0,"stats":{"Line":6}},{"line":235,"address":[],"length":0,"stats":{"Line":9}},{"line":236,"address":[],"length":0,"stats":{"Line":27}},{"line":237,"address":[],"length":0,"stats":{"Line":18}},{"line":238,"address":[],"length":0,"stats":{"Line":18}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":18}},{"line":242,"address":[],"length":0,"stats":{"Line":18}},{"line":246,"address":[],"length":0,"stats":{"Line":6}},{"line":247,"address":[],"length":0,"stats":{"Line":6}},{"line":260,"address":[],"length":0,"stats":{"Line":11}},{"line":261,"address":[],"length":0,"stats":{"Line":7}},{"line":262,"address":[],"length":0,"stats":{"Line":11}}],"covered":58,"coverable":60},{"path":["/","Users","yuvikachaudhary","Desktop","Semester 4","COP290","spreadsheet_rust","src","terminal","graph.rs"],"content":"/// Graph module for dependency management in the spreadsheet.\n///\n/// This module provides data structures and functions to manage the dependency graph\n/// between cells, detect cycles, and maintain relationships between cells that depend\n/// on one another's values.\nuse crate::terminal::functions::Operation;\nuse crate::terminal::types::Coordinates;\n\n/// Represents a node (cell) in the spreadsheet dependency graph.\n///\n/// Each node maintains its value, the operation it performs, references to its\n/// operands, and a list of other cells that depend on it.\n#[derive(Debug, Clone, Default)]\npub struct Node {\n    /// List of cells that depend on this node's value\n    pub dependents: Vec\u003cCoordinates\u003e,\n\n    /// The computed value of this cell\n    pub node_value: i32,\n\n    /// First operand for the operation performed by this cell\n    pub value1: Coordinates,\n\n    /// Second operand for the operation performed by this cell\n    pub value2: Coordinates,\n\n    /// Position of this cell in the grid\n    pub position: Coordinates,\n\n    /// The operation performed by this cell\n    pub op: Operation,\n\n    /// Whether the cell contains a valid value\n    pub valid: bool,\n\n    /// Used during graph traversal algorithms (e.g., cycle detection)\n    pub visited: bool,\n}\n\nimpl Node {\n    /// Gets the value of this node.\n    ///\n    /// # Returns\n    ///\n    /// The value of this node.\n    pub fn get_value(\u0026self) -\u003e i32 {\n        self.node_value\n    }\n\n    /// Sets the value of this node.\n    ///\n    /// # Arguments\n    ///\n    /// * `value` - The new value to set for this node.\n    pub fn set_value(\u0026mut self, value: i32) {\n        self.node_value = value;\n    }\n\n    /// Sets the position of this node.\n    ///\n    /// # Arguments\n    ///\n    /// * `position` - The new position to set for this node.\n    pub fn set_position(\u0026mut self, position: Coordinates) {\n        self.position = position;\n    }\n\n    /// Sets the first operand for the operation performed by this cell.\n    ///\n    /// # Arguments\n    ///\n    /// * `value1` - The coordinates of the first operand.\n    pub fn set_value1(\u0026mut self, value1: Coordinates) {\n        self.value1 = value1;\n    }\n\n    /// Sets the second operand for the operation performed by this cell.\n    ///\n    /// # Arguments\n    ///\n    /// * `value2` - The coordinates of the second operand.\n    pub fn set_value2(\u0026mut self, value2: Coordinates) {\n        self.value2 = value2;\n    }\n\n    /// Gets whether the cell contains a valid value.\n    ///\n    /// # Returns\n    ///\n    /// `true` if the cell contains a valid value, `false` otherwise.\n    pub fn get_valid(\u0026self) -\u003e bool {\n        self.valid\n    }\n\n    /// Sets whether the cell contains a valid value.\n    ///\n    /// # Arguments\n    ///\n    /// * `valid` - `true` if the cell contains a valid value, `false` otherwise.\n    pub fn set_valid(\u0026mut self, valid: bool) {\n        self.valid = valid;\n    }\n\n    /// Adds a dependent cell to this node's dependents list if it's not already there.\n    ///\n    /// # Arguments\n    ///\n    /// * `cell` - The coordinates of the cell to add to dependents.\n    pub fn add_dep(\u0026mut self, cell: Coordinates) {\n        if !self\n            .dependents\n            .iter()\n            .any(|x| x.row == cell.row \u0026\u0026 x.col == cell.col)\n        {\n            self.dependents.push(cell);\n        }\n    }\n\n    /// Removes a dependent cell from this node's dependents list.\n    ///\n    /// # Arguments\n    ///\n    /// * `cell` - The coordinates of the cell to remove from dependents.\n    pub fn remove_dep(\u0026mut self, cell: Coordinates) {\n        self.dependents\n            .retain(|x| x.row != cell.row || x.col != cell.col);\n    }\n\n    /// Gets the list of cells that depend on this node's value.\n    ///\n    /// # Returns\n    ///\n    /// A reference to the list of dependent cells.\n    pub fn get_dependents(\u0026self) -\u003e \u0026Vec\u003cCoordinates\u003e {\n        \u0026self.dependents\n    }\n\n    /// Sets the list of cells that depend on this node's value.\n    ///\n    /// # Arguments\n    ///\n    /// * `dependents` - The new list of dependent cells.\n    pub fn set_dependents(\u0026mut self, dependents: Vec\u003cCoordinates\u003e) {\n        self.dependents = dependents;\n    }\n}\n","traces":[{"line":46,"address":[],"length":0,"stats":{"Line":3}},{"line":47,"address":[],"length":0,"stats":{"Line":3}},{"line":55,"address":[],"length":0,"stats":{"Line":2}},{"line":56,"address":[],"length":0,"stats":{"Line":2}},{"line":64,"address":[],"length":0,"stats":{"Line":2}},{"line":65,"address":[],"length":0,"stats":{"Line":2}},{"line":73,"address":[],"length":0,"stats":{"Line":1}},{"line":74,"address":[],"length":0,"stats":{"Line":1}},{"line":82,"address":[],"length":0,"stats":{"Line":1}},{"line":83,"address":[],"length":0,"stats":{"Line":1}},{"line":91,"address":[],"length":0,"stats":{"Line":6}},{"line":92,"address":[],"length":0,"stats":{"Line":6}},{"line":100,"address":[],"length":0,"stats":{"Line":3}},{"line":101,"address":[],"length":0,"stats":{"Line":3}},{"line":109,"address":[],"length":0,"stats":{"Line":74}},{"line":110,"address":[],"length":0,"stats":{"Line":74}},{"line":111,"address":[],"length":0,"stats":{"Line":74}},{"line":112,"address":[],"length":0,"stats":{"Line":74}},{"line":113,"address":[],"length":0,"stats":{"Line":156}},{"line":115,"address":[],"length":0,"stats":{"Line":73}},{"line":124,"address":[],"length":0,"stats":{"Line":20}},{"line":125,"address":[],"length":0,"stats":{"Line":20}},{"line":126,"address":[],"length":0,"stats":{"Line":67}},{"line":134,"address":[],"length":0,"stats":{"Line":6}},{"line":135,"address":[],"length":0,"stats":{"Line":6}},{"line":143,"address":[],"length":0,"stats":{"Line":3}},{"line":144,"address":[],"length":0,"stats":{"Line":3}}],"covered":27,"coverable":27},{"path":["/","Users","yuvikachaudhary","Desktop","Semester 4","COP290","spreadsheet_rust","src","terminal","mod.rs"],"content":"pub mod backend;\n/// Terminal module for the spreadsheet application.\n///\n/// This module provides the core functionality for the terminal-based version of the\n/// spreadsheet, including:\n///\n/// - Backend logic for cell computation and dependency tracking\n/// - Spreadsheet rendering and display in the terminal\n/// - Command parsing and processing\n/// - Graph-based dependency management\n///\n/// The terminal version allows for interactive use via command-line input.\npub mod functions;\npub mod graph;\npub mod parser;\npub mod spreadsheet;\npub mod types;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","yuvikachaudhary","Desktop","Semester 4","COP290","spreadsheet_rust","src","terminal","parser.rs"],"content":"/// Parser module for the terminal spreadsheet application.\n///\n/// Provides functionality to parse and validate user input commands,\n/// converting them into operations that can be executed by the spreadsheet.\n/// Supports parsing of cell references, ranges, constants, and various operations.\nuse crate::terminal::functions::{Operation, Value};\n\n/// Validates and parses a command string into spreadsheet operations.\n///\n/// # Arguments\n///\n/// * `cmd` - The command string to parse\n/// * `rows` - The maximum row index (for validation)\n/// * `columns` - The maximum column index (for validation)\n///\n/// # Returns\n///\n/// * `Some((cell, operation))` - If the command is valid, returns the target cell and operation\n/// * `None` - If the command is invalid or unrecognized\n///\n/// # Examples\n///\n/// Commands can be:\n/// - Cell assignments: \"A1=5\"\n/// - Operations: \"B2=A1+10\"\n/// - Range functions: \"C3=SUM(A1:B5)\"\n/// - Special commands: \"enable_output\", \"scroll_to B5\", etc.\npub fn validate(\n    cmd: \u0026str,\n    rows: \u0026usize,\n    columns: \u0026usize,\n) -\u003e Option\u003c(Option\u003cValue\u003e, Option\u003cValue\u003e)\u003e {\n    match cmd.trim() {\n        \"enable_output\" =\u003e {\n            return Some((\n                None,\n                Some(Value::Oper(\n                    Box::new(Value::Const(-1)),\n                    Box::new(Value::Const(-1)),\n                    Operation::EnableOutput,\n                )),\n            ));\n        }\n        \"disable_output\" =\u003e {\n            return Some((\n                None,\n                Some(Value::Oper(\n                    Box::new(Value::Const(-1)),\n                    Box::new(Value::Const(-1)),\n                    Operation::DisableOutput,\n                )),\n            ));\n        }\n        _ =\u003e {} // Continue with the regular parsing for other commands\n    }\n\n    if cmd.trim().starts_with(\"scroll_to \") {\n        let cell_name = cmd.trim()[\"scroll_to \".len()..].trim();\n        let cell = is_cell(cell_name, rows, columns);\n        if let Some(cell) = cell {\n            return Some((\n                Some(cell),\n                Some(Value::Oper(\n                    Box::new(Value::Const(-1)),\n                    Box::new(Value::Const(-1)),\n                    Operation::Scrollto,\n                )),\n            ));\n        } else {\n            return None;\n        }\n    }\n\n    let (cell, exp) = cmd.split_once('=')?;\n\n    let cell = String::from(cell).trim().to_string();\n    let cell = is_cell(\u0026cell, rows, columns);\n\n    let Some((operation, range)) = exp.split_once('(') else {\n        // basic math operations or constant (0-4)\n        let val = (String::from(exp)).trim().to_string();\n        let operators = [\"+\", \"-\", \"*\", \"/\"];\n        for (i, c) in val.chars().enumerate() {\n            if i == 0 \u0026\u0026 c == '-' {\n                continue;\n            }\n            if operators.contains(\u0026c.to_string().as_str()) {\n                let op1 = (val[..i]).trim().to_string();\n                let op2 = \u0026val[i + 1..].trim().to_string();\n                let op1 = is_cell_or_const(\u0026op1.to_string(), rows, columns)?;\n                let op2 = is_cell_or_const(\u0026op2.to_string(), rows, columns)?;\n                match c {\n                    '+' =\u003e {\n                        return Some((\n                            cell,\n                            Some(Value::Oper(Box::new(op1), Box::new(op2), Operation::Add)),\n                        ));\n                    }\n                    '-' =\u003e {\n                        return Some((\n                            cell,\n                            Some(Value::Oper(Box::new(op1), Box::new(op2), Operation::Sub)),\n                        ));\n                    }\n                    '*' =\u003e {\n                        return Some((\n                            cell,\n                            Some(Value::Oper(Box::new(op1), Box::new(op2), Operation::Mul)),\n                        ));\n                    }\n                    '/' =\u003e {\n                        return Some((\n                            cell,\n                            Some(Value::Oper(Box::new(op1), Box::new(op2), Operation::Div)),\n                        ));\n                    }\n                    _ =\u003e {\n                        return None;\n                    } //This case is not possible, just for compilation\n                }\n            }\n        }\n\n        let val = is_cell_or_const(\u0026val, rows, columns)?; //for the moment, assuming the RHS to be a constant or cell\n        return Some((\n            cell,\n            Some(Value::Oper(\n                Box::new(val),\n                Box::new(Value::Const(-1)),\n                Operation::Cons,\n            )),\n        ));\n    };\n    let range = range.strip_suffix(')')?.to_string(); //removing the closing bracket\n\n    let Some((start, end)) = range.split_once(':') else {\n        // SLEEP (the keyword 'SLEEP' is not checked for, it is taken fro granted)\n        let val = range;\n        let val = is_cell_or_const(\u0026val, rows, columns);\n        if let Some(val) = val {\n            return Some((\n                cell,\n                Some(Value::Oper(\n                    Box::new(val),\n                    Box::new(Value::Const(-1)),\n                    Operation::Slp,\n                )),\n            ));\n        }\n        return Some((cell, None));\n    };\n    let start = String::from(start);\n    let end = String::from(end);\n    let start = is_cell(\u0026start, rows, columns)?;\n    let end = is_cell(\u0026end, rows, columns)?;\n    if let (Value::Cell(r, c), Value::Cell(r2, c2)) = (\u0026start, \u0026end) {\n        if r \u003e r2 || c \u003e c2 {\n            return None;\n        }\n    } else {\n        return None;\n    }\n    match operation {\n        \"SUM\" =\u003e Some((\n            cell,\n            Some(Value::Oper(Box::new(start), Box::new(end), Operation::Sum)),\n        )),\n        \"AVG\" =\u003e Some((\n            cell,\n            Some(Value::Oper(Box::new(start), Box::new(end), Operation::Avg)),\n        )),\n        \"STDEV\" =\u003e Some((\n            cell,\n            Some(Value::Oper(Box::new(start), Box::new(end), Operation::Std)),\n        )),\n        \"MIN\" =\u003e Some((\n            cell,\n            Some(Value::Oper(Box::new(start), Box::new(end), Operation::Min)),\n        )),\n        \"MAX\" =\u003e Some((\n            cell,\n            Some(Value::Oper(Box::new(start), Box::new(end), Operation::Max)),\n        )),\n        _ =\u003e Some((cell, None)),\n    }\n}\n\n/// Parses a cell reference in the format \"A1\", \"B2\", etc.\n///\n/// # Arguments\n///\n/// * `exp` - The string containing the cell reference\n/// * `rows` - The maximum row index (for validation)\n/// * `columns` - The maximum column index (for validation)\n///\n/// # Returns\n///\n/// * `Some(Value::Cell(row, col))` - If the expression is a valid cell reference\n/// * `None` - If the expression is not a valid cell reference\npub fn is_cell(exp: \u0026str, rows: \u0026usize, columns: \u0026usize) -\u003e Option\u003cValue\u003e {\n    let mut col = 0;\n    let mut row = 0;\n\n    let chars: Vec\u003cchar\u003e = exp.chars().collect();\n    let mut i = 0;\n    while i \u003c 3 {\n        if chars[i].is_alphabetic() {\n            col = col * 26 + (chars[i] as u8 - b'A') as usize + 1;\n        } else {\n            break;\n        }\n        i += 1;\n    }\n    if exp.chars().count() - i \u003e 3 || i == 0 {\n        return None;\n    }\n    while i \u003c exp.chars().count() {\n        if chars[i].is_numeric() {\n            row = row * 10 + (chars[i] as u8 - b'0') as usize;\n        } else {\n            return None;\n        }\n        i += 1;\n    }\n    if row \u003e *rows || col \u003e *columns {\n        return None;\n    }\n    Some(Value::Cell(col as i32, row as i32))\n}\n\n/// Parses a constant integer value.\n///\n/// # Arguments\n///\n/// * `exp` - The string containing the integer constant\n///\n/// # Returns\n///\n/// * `Some(Value::Const(value))` - If the expression is a valid integer\n/// * `None` - If the expression is not a valid integer\npub fn is_const(exp: \u0026str) -\u003e Option\u003cValue\u003e {\n    // let mut ans = 0;\n    // for c in exp.chars() {\n    //     if c.is_numeric() {\n    //         ans = ans*10 + (c as u8 - '0' as u8) as usize;\n    //     } else {\n    //         return None;\n    //     }\n    // }\n    // return Some(Value::Const(ans));\n    match exp.parse::\u003cisize\u003e() {\n        Ok(ans) =\u003e Some(Value::Const(ans)),\n        Err(_) =\u003e None,\n    }\n}\n\n/// Parses an expression that could be either a cell reference or a constant.\n///\n/// # Arguments\n///\n/// * `exp` - The string to parse\n/// * `rows` - The maximum row index (for cell validation)\n/// * `columns` - The maximum column index (for cell validation)\n///\n/// # Returns\n///\n/// * `Some(Value)` - If the expression is either a valid cell or constant\n/// * `None` - If the expression is neither a valid cell nor constant\npub fn is_cell_or_const(exp: \u0026str, rows: \u0026usize, columns: \u0026usize) -\u003e Option\u003cValue\u003e {\n    if let Some(constant) = is_const(exp) {\n        Some(constant)\n    } else if let Some(cell) = is_cell(exp, rows, columns) {\n        return Some(cell);\n    } else {\n        return None;\n    }\n}\n\n// assignment - cell, value - done\n// basic math - cells, values\n// sleep - cell, value - done\n// range operations - cells, values - done\n","traces":[{"line":28,"address":[],"length":0,"stats":{"Line":42}},{"line":33,"address":[],"length":0,"stats":{"Line":42}},{"line":34,"address":[],"length":0,"stats":{"Line":42}},{"line":35,"address":[],"length":0,"stats":{"Line":2}},{"line":36,"address":[],"length":0,"stats":{"Line":2}},{"line":37,"address":[],"length":0,"stats":{"Line":2}},{"line":38,"address":[],"length":0,"stats":{"Line":2}},{"line":39,"address":[],"length":0,"stats":{"Line":2}},{"line":40,"address":[],"length":0,"stats":{"Line":2}},{"line":44,"address":[],"length":0,"stats":{"Line":40}},{"line":45,"address":[],"length":0,"stats":{"Line":2}},{"line":46,"address":[],"length":0,"stats":{"Line":2}},{"line":47,"address":[],"length":0,"stats":{"Line":2}},{"line":48,"address":[],"length":0,"stats":{"Line":2}},{"line":49,"address":[],"length":0,"stats":{"Line":2}},{"line":50,"address":[],"length":0,"stats":{"Line":2}},{"line":54,"address":[],"length":0,"stats":{"Line":38}},{"line":57,"address":[],"length":0,"stats":{"Line":38}},{"line":58,"address":[],"length":0,"stats":{"Line":5}},{"line":59,"address":[],"length":0,"stats":{"Line":5}},{"line":60,"address":[],"length":0,"stats":{"Line":8}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":2}},{"line":74,"address":[],"length":0,"stats":{"Line":33}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":9}},{"line":81,"address":[],"length":0,"stats":{"Line":18}},{"line":82,"address":[],"length":0,"stats":{"Line":18}},{"line":83,"address":[],"length":0,"stats":{"Line":79}},{"line":84,"address":[],"length":0,"stats":{"Line":79}},{"line":85,"address":[],"length":0,"stats":{"Line":1}},{"line":87,"address":[],"length":0,"stats":{"Line":60}},{"line":88,"address":[],"length":0,"stats":{"Line":15}},{"line":89,"address":[],"length":0,"stats":{"Line":15}},{"line":90,"address":[],"length":0,"stats":{"Line":30}},{"line":91,"address":[],"length":0,"stats":{"Line":15}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":6}},{"line":95,"address":[],"length":0,"stats":{"Line":6}},{"line":96,"address":[],"length":0,"stats":{"Line":6}},{"line":100,"address":[],"length":0,"stats":{"Line":3}},{"line":101,"address":[],"length":0,"stats":{"Line":3}},{"line":102,"address":[],"length":0,"stats":{"Line":3}},{"line":106,"address":[],"length":0,"stats":{"Line":3}},{"line":107,"address":[],"length":0,"stats":{"Line":3}},{"line":108,"address":[],"length":0,"stats":{"Line":3}},{"line":112,"address":[],"length":0,"stats":{"Line":3}},{"line":113,"address":[],"length":0,"stats":{"Line":3}},{"line":114,"address":[],"length":0,"stats":{"Line":3}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":6}},{"line":125,"address":[],"length":0,"stats":{"Line":2}},{"line":126,"address":[],"length":0,"stats":{"Line":2}},{"line":127,"address":[],"length":0,"stats":{"Line":2}},{"line":128,"address":[],"length":0,"stats":{"Line":2}},{"line":129,"address":[],"length":0,"stats":{"Line":2}},{"line":130,"address":[],"length":0,"stats":{"Line":2}},{"line":134,"address":[],"length":0,"stats":{"Line":9}},{"line":136,"address":[],"length":0,"stats":{"Line":7}},{"line":138,"address":[],"length":0,"stats":{"Line":1}},{"line":139,"address":[],"length":0,"stats":{"Line":1}},{"line":140,"address":[],"length":0,"stats":{"Line":1}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":1}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":7}},{"line":155,"address":[],"length":0,"stats":{"Line":7}},{"line":156,"address":[],"length":0,"stats":{"Line":7}},{"line":157,"address":[],"length":0,"stats":{"Line":13}},{"line":158,"address":[],"length":0,"stats":{"Line":1}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":1}},{"line":165,"address":[],"length":0,"stats":{"Line":1}},{"line":166,"address":[],"length":0,"stats":{"Line":1}},{"line":168,"address":[],"length":0,"stats":{"Line":6}},{"line":169,"address":[],"length":0,"stats":{"Line":1}},{"line":170,"address":[],"length":0,"stats":{"Line":1}},{"line":172,"address":[],"length":0,"stats":{"Line":5}},{"line":173,"address":[],"length":0,"stats":{"Line":1}},{"line":174,"address":[],"length":0,"stats":{"Line":1}},{"line":176,"address":[],"length":0,"stats":{"Line":4}},{"line":177,"address":[],"length":0,"stats":{"Line":1}},{"line":178,"address":[],"length":0,"stats":{"Line":1}},{"line":180,"address":[],"length":0,"stats":{"Line":3}},{"line":181,"address":[],"length":0,"stats":{"Line":1}},{"line":182,"address":[],"length":0,"stats":{"Line":1}},{"line":184,"address":[],"length":0,"stats":{"Line":1}},{"line":200,"address":[],"length":0,"stats":{"Line":75}},{"line":201,"address":[],"length":0,"stats":{"Line":75}},{"line":202,"address":[],"length":0,"stats":{"Line":75}},{"line":204,"address":[],"length":0,"stats":{"Line":75}},{"line":205,"address":[],"length":0,"stats":{"Line":75}},{"line":206,"address":[],"length":0,"stats":{"Line":152}},{"line":207,"address":[],"length":0,"stats":{"Line":228}},{"line":208,"address":[],"length":0,"stats":{"Line":77}},{"line":210,"address":[],"length":0,"stats":{"Line":74}},{"line":212,"address":[],"length":0,"stats":{"Line":77}},{"line":214,"address":[],"length":0,"stats":{"Line":147}},{"line":215,"address":[],"length":0,"stats":{"Line":4}},{"line":217,"address":[],"length":0,"stats":{"Line":150}},{"line":218,"address":[],"length":0,"stats":{"Line":159}},{"line":219,"address":[],"length":0,"stats":{"Line":79}},{"line":221,"address":[],"length":0,"stats":{"Line":1}},{"line":223,"address":[],"length":0,"stats":{"Line":79}},{"line":225,"address":[],"length":0,"stats":{"Line":136}},{"line":226,"address":[],"length":0,"stats":{"Line":6}},{"line":228,"address":[],"length":0,"stats":{"Line":64}},{"line":241,"address":[],"length":0,"stats":{"Line":46}},{"line":251,"address":[],"length":0,"stats":{"Line":46}},{"line":252,"address":[],"length":0,"stats":{"Line":21}},{"line":253,"address":[],"length":0,"stats":{"Line":25}},{"line":269,"address":[],"length":0,"stats":{"Line":40}},{"line":270,"address":[],"length":0,"stats":{"Line":58}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":40}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":4}}],"covered":108,"coverable":130},{"path":["/","Users","yuvikachaudhary","Desktop","Semester 4","COP290","spreadsheet_rust","src","terminal","spreadsheet.rs"],"content":"/// Spreadsheet module for the terminal-based interface.\n///\n/// This module provides functionality for rendering the spreadsheet grid in\n/// the terminal, handling user commands, and displaying the current state of\n/// cells to the user. It acts as the frontend for the terminal-based version\n/// of the spreadsheet application.\nuse crate::terminal::backend::getting_things_updated;\nuse crate::terminal::functions::Operation;\nuse crate::terminal::functions::Value;\nuse crate::terminal::graph::Node;\nuse crate::terminal::parser;\nuse crate::terminal::types::Coordinates;\nuse std::cmp;\nuse std::io;\nuse std::io::Write;\n\n/// Constants defining the maximum dimensions of the spreadsheet\nconst MAX_ROW: usize = 999;\nconst MAX_COLUMN: usize = 18278;\n\n/// Translates a column number to its Excel-style letter representation (A, B, C, ..., AA, AB, etc.).\n///\n/// # Arguments\n///\n/// * `y` - The 1-based column index to convert\n///\n/// # Returns\n///\n/// A string containing the column letter(s)\npub fn column_decoder(mut j: usize) -\u003e String {\n    let mut cc = Vec::new();\n    while j \u003e 0 {\n        j -= 1;\n        cc.push((b'A' + (j % 26) as u8) as char);\n        j /= 26;\n    }\n    cc.reverse();\n    cc.into_iter().collect()\n}\n\n/// Prints the current state of the spreadsheet grid to the terminal.\n///\n/// # Arguments\n///\n/// * `start_x` - The starting row index for display\n/// * `start_y` - The starting column index for display\n/// * `r` - The number of rows in the grid\n/// * `c` - The number of columns in the grid\n/// * `grid` - The spreadsheet grid containing the cells\npub fn print_grid(start_x: usize, start_y: usize, r: usize, c: usize, grid: \u0026mut [Vec\u003cNode\u003e]) {\n    let max_x = cmp::min(9 + start_x, r);\n    let max_y = cmp::min(9 + start_y, c);\n\n    for (i, _row) in grid.iter().enumerate().take(max_x + 1).skip(start_x - 1) {\n        for j in start_y - 1..=max_y {\n            if i == start_x - 1 \u0026\u0026 j == start_y - 1 {\n                print!(\"{:\u003e12}\", \" \");\n            } else if i == start_x - 1 \u0026\u0026 j != start_y - 1 {\n                print!(\"{:\u003e12}\", column_decoder(j));\n            } else if j == start_y - 1 {\n                print!(\"{:\u003e12}\", i);\n            } else if grid[i][j].valid {\n                print!(\"{:\u003e12}\", grid[i][j].node_value);\n            } else {\n                print!(\"{:\u003e12}\", \"ERR\");\n            }\n        }\n        println!();\n    }\n}\n\n/// Displays a status message with execution time.\n///\n/// # Arguments\n///\n/// * `status` - The status code of the previous operation\n/// * `time` - The execution time of the operation in seconds\npub fn display_status(x: i32, time_taken: f64) {\n    print!(\"[{:.2}] \", time_taken);\n    match x {\n        1 =\u003e print!(\"(ok) \u003e \"),                 // relevant\n        2 =\u003e print!(\"(invalid range) \u003e \"), // not relevant to autograder - will have to change parser if want to // debug\n        3 =\u003e print!(\"(unrecognized cmd) \u003e \"), // relevant\n        4 =\u003e print!(\"(invalid row/column) \u003e \"), // ig not relevant\n        5 =\u003e print!(\"(cycle not allowed) \u003e \"), // relevant\n        _ =\u003e (),\n    }\n    io::stdout().flush().unwrap();\n}\n\nfn is_number(str: \u0026str) -\u003e bool {\n    !str.is_empty() \u0026\u0026 str.chars().all(|c| c.is_ascii_digit())\n}\n\n/// Processes a single command and updates the spreadsheet state accordingly.\n///\n/// # Arguments\n///\n/// * `cmd` - The command string to process\n/// * `start_x` - The current row index for display (may be updated)\n/// * `start_y` - The current column index for display (may be updated)\n/// * `r` - The number of rows in the grid\n/// * `c` - The number of columns in the grid\n/// * `is_disabled` - Whether output is disabled\n/// * `grid` - The spreadsheet grid to update\n///\n/// # Returns\n///\n/// An integer status code indicating success or specific failure modes\n#[allow(unreachable_code)]\npub fn process_command(\n    command: \u0026str,\n    start_x: \u0026mut usize,\n    start_y: \u0026mut usize,\n    r: usize,\n    c: usize,\n    is_disabled: \u0026mut bool,\n    grid: \u0026mut Vec\u003cVec\u003cNode\u003e\u003e,\n) -\u003e i32 {\n    match command {\n        \"q\" =\u003e return 0,\n        \"w\" =\u003e {\n            *start_x = if *start_x \u003e 10 { *start_x - 10 } else { 1 };\n            if !(*is_disabled) {\n                print_grid(*start_x, *start_y, r, c, grid);\n            }\n            return 1;\n        }\n        \"s\" =\u003e {\n            if *start_x + 10 \u003c= r {\n                *start_x += 10;\n                *start_x = cmp::min(*start_x, r - 9);\n            }\n            if !(*is_disabled) {\n                print_grid(*start_x, *start_y, r, c, grid);\n            }\n            return 1;\n        }\n        \"a\" =\u003e {\n            *start_y = if *start_y \u003e 10 { *start_y - 10 } else { 1 };\n            if !(*is_disabled) {\n                print_grid(*start_x, *start_y, r, c, grid);\n            }\n            return 1;\n        }\n        \"d\" =\u003e {\n            if *start_y + 10 \u003c= c {\n                *start_y += 10;\n                *start_y = cmp::min(*start_y, c - 9);\n            }\n            if !(*is_disabled) {\n                print_grid(*start_x, *start_y, r, c, grid);\n            }\n            return 1;\n        }\n        _ =\u003e {}\n    }\n\n    // let mut function: isize = -1;\n    // work with enums only not functions\n\n    // debug - complete this\n    match parser::validate(command, \u0026r, \u0026c) {\n        Some((Some(Value::Cell(col, row)), Some(Value::Oper(v1, v2, op)))) =\u003e {\n            // Handle special operations\n            if op == Operation::Scrollto {\n                {\n                    *start_x = row as usize;\n                    *start_y = col as usize;\n                    if !(*is_disabled) {\n                        print_grid(*start_x, *start_y, r, c, grid);\n                    }\n                    return 1;\n                }\n            }\n\n            let target_cell = Coordinates { row, col };\n            let (value1, value2) = match (\u0026*v1, \u0026*v2) {\n                (Value::Cell(c1, r1), Value::Cell(c2, r2)) =\u003e (\n                    Coordinates { row: *r1, col: *c1 },\n                    Coordinates { row: *r2, col: *c2 },\n                ),\n                (Value::Cell(c1, r1), Value::Const(val)) =\u003e (\n                    Coordinates { row: *r1, col: *c1 },\n                    Coordinates {\n                        row: *val as i32,\n                        col: -1,\n                    },\n                ),\n                (Value::Const(val), Value::Cell(c2, r2)) =\u003e (\n                    Coordinates {\n                        row: *val as i32,\n                        col: -1,\n                    },\n                    Coordinates { row: *r2, col: *c2 },\n                ),\n                (Value::Const(val1), Value::Const(val2)) =\u003e (\n                    Coordinates {\n                        row: *val1 as i32,\n                        col: -1,\n                    },\n                    Coordinates {\n                        row: *val2 as i32,\n                        col: -1,\n                    },\n                ),\n                _ =\u003e {\n                    if !(*is_disabled) {\n                        print_grid(*start_x, *start_y, r, c, grid);\n                    }\n                    return 3; // Invalid operands\n                }\n            };\n            let operation = op;\n\n            let status = getting_things_updated(grid, target_cell, value1, value2, operation);\n\n            if !(*is_disabled) {\n                print_grid(*start_x, *start_y, r, c, grid);\n            }\n\n            return status;\n        }\n        Some((None, Some(Value::Oper(_v1, _v2, op)))) =\u003e {\n            // Handle special operations\n            match op {\n                Operation::EnableOutput =\u003e {\n                    *is_disabled = false;\n                    print_grid(*start_x, *start_y, r, c, grid);\n                    return 1;\n                }\n                Operation::DisableOutput =\u003e {\n                    *is_disabled = true;\n                    return 1;\n                }\n                _ =\u003e {\n                    if !(*is_disabled) {\n                        print_grid(*start_x, *start_y, r, c, grid);\n                    }\n                    return 3; // Invalid operands\n                }\n            }\n        }\n        _ =\u003e {\n            if !(*is_disabled) {\n                print_grid(*start_x, *start_y, r, c, grid);\n            }\n            return 3; // Invalid operands\n        }\n    }\n    1\n}\n\n/// Processes the command line arguments provided to the application.\n///\n/// # Arguments\n///\n/// * `argc` - The number of arguments\n/// * `args` - The vector of argument strings\n/// * `is_disabled` - Whether the output should be disabled\n///\n/// # Returns\n///\n/// `true` if arguments are valid and processing should continue, `false` otherwise\npub fn process_first(x: usize, command: \u0026[String], _is_disabled: \u0026mut bool) -\u003e bool {\n    if x != 3 {\n        return false;\n    }\n    if !is_number(\u0026command[1]) || !is_number(\u0026command[2]) {\n        return false;\n    }\n\n    let r = command[1].parse::\u003cusize\u003e().unwrap();\n    let c = command[2].parse::\u003cusize\u003e().unwrap();\n\n    if !(1..=MAX_ROW).contains(\u0026r) || !(1..=MAX_COLUMN).contains(\u0026c) {\n        return false;\n    }\n    true\n}\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":276}},{"line":31,"address":[],"length":0,"stats":{"Line":276}},{"line":32,"address":[],"length":0,"stats":{"Line":850}},{"line":33,"address":[],"length":0,"stats":{"Line":287}},{"line":34,"address":[],"length":0,"stats":{"Line":287}},{"line":35,"address":[],"length":0,"stats":{"Line":287}},{"line":37,"address":[],"length":0,"stats":{"Line":276}},{"line":38,"address":[],"length":0,"stats":{"Line":276}},{"line":50,"address":[],"length":0,"stats":{"Line":32}},{"line":51,"address":[],"length":0,"stats":{"Line":32}},{"line":52,"address":[],"length":0,"stats":{"Line":32}},{"line":54,"address":[],"length":0,"stats":{"Line":329}},{"line":55,"address":[],"length":0,"stats":{"Line":3271}},{"line":56,"address":[],"length":0,"stats":{"Line":3303}},{"line":57,"address":[],"length":0,"stats":{"Line":32}},{"line":58,"address":[],"length":0,"stats":{"Line":3504}},{"line":59,"address":[],"length":0,"stats":{"Line":265}},{"line":60,"address":[],"length":0,"stats":{"Line":3207}},{"line":61,"address":[],"length":0,"stats":{"Line":265}},{"line":62,"address":[],"length":0,"stats":{"Line":5086}},{"line":63,"address":[],"length":0,"stats":{"Line":2409}},{"line":65,"address":[],"length":0,"stats":{"Line":3}},{"line":68,"address":[],"length":0,"stats":{"Line":297}},{"line":78,"address":[],"length":0,"stats":{"Line":10}},{"line":79,"address":[],"length":0,"stats":{"Line":10}},{"line":80,"address":[],"length":0,"stats":{"Line":10}},{"line":81,"address":[],"length":0,"stats":{"Line":4}},{"line":82,"address":[],"length":0,"stats":{"Line":1}},{"line":83,"address":[],"length":0,"stats":{"Line":1}},{"line":84,"address":[],"length":0,"stats":{"Line":1}},{"line":85,"address":[],"length":0,"stats":{"Line":1}},{"line":86,"address":[],"length":0,"stats":{"Line":2}},{"line":88,"address":[],"length":0,"stats":{"Line":10}},{"line":91,"address":[],"length":0,"stats":{"Line":14}},{"line":92,"address":[],"length":0,"stats":{"Line":64}},{"line":111,"address":[],"length":0,"stats":{"Line":24}},{"line":120,"address":[],"length":0,"stats":{"Line":24}},{"line":121,"address":[],"length":0,"stats":{"Line":25}},{"line":122,"address":[],"length":0,"stats":{"Line":23}},{"line":123,"address":[],"length":0,"stats":{"Line":6}},{"line":124,"address":[],"length":0,"stats":{"Line":6}},{"line":125,"address":[],"length":0,"stats":{"Line":3}},{"line":127,"address":[],"length":0,"stats":{"Line":3}},{"line":129,"address":[],"length":0,"stats":{"Line":20}},{"line":130,"address":[],"length":0,"stats":{"Line":4}},{"line":131,"address":[],"length":0,"stats":{"Line":1}},{"line":132,"address":[],"length":0,"stats":{"Line":1}},{"line":134,"address":[],"length":0,"stats":{"Line":6}},{"line":135,"address":[],"length":0,"stats":{"Line":3}},{"line":137,"address":[],"length":0,"stats":{"Line":3}},{"line":139,"address":[],"length":0,"stats":{"Line":17}},{"line":140,"address":[],"length":0,"stats":{"Line":6}},{"line":141,"address":[],"length":0,"stats":{"Line":6}},{"line":142,"address":[],"length":0,"stats":{"Line":3}},{"line":144,"address":[],"length":0,"stats":{"Line":3}},{"line":146,"address":[],"length":0,"stats":{"Line":14}},{"line":147,"address":[],"length":0,"stats":{"Line":4}},{"line":148,"address":[],"length":0,"stats":{"Line":1}},{"line":149,"address":[],"length":0,"stats":{"Line":1}},{"line":151,"address":[],"length":0,"stats":{"Line":6}},{"line":152,"address":[],"length":0,"stats":{"Line":3}},{"line":154,"address":[],"length":0,"stats":{"Line":3}},{"line":156,"address":[],"length":0,"stats":{"Line":11}},{"line":163,"address":[],"length":0,"stats":{"Line":11}},{"line":164,"address":[],"length":0,"stats":{"Line":4}},{"line":166,"address":[],"length":0,"stats":{"Line":4}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":4}},{"line":178,"address":[],"length":0,"stats":{"Line":4}},{"line":179,"address":[],"length":0,"stats":{"Line":4}},{"line":180,"address":[],"length":0,"stats":{"Line":4}},{"line":181,"address":[],"length":0,"stats":{"Line":4}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":4}},{"line":219,"address":[],"length":0,"stats":{"Line":4}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":2}},{"line":226,"address":[],"length":0,"stats":{"Line":2}},{"line":228,"address":[],"length":0,"stats":{"Line":1}},{"line":229,"address":[],"length":0,"stats":{"Line":1}},{"line":230,"address":[],"length":0,"stats":{"Line":1}},{"line":233,"address":[],"length":0,"stats":{"Line":1}},{"line":234,"address":[],"length":0,"stats":{"Line":1}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":10}},{"line":246,"address":[],"length":0,"stats":{"Line":5}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":10}},{"line":266,"address":[],"length":0,"stats":{"Line":10}},{"line":267,"address":[],"length":0,"stats":{"Line":2}},{"line":269,"address":[],"length":0,"stats":{"Line":14}},{"line":270,"address":[],"length":0,"stats":{"Line":2}},{"line":273,"address":[],"length":0,"stats":{"Line":6}},{"line":274,"address":[],"length":0,"stats":{"Line":6}},{"line":276,"address":[],"length":0,"stats":{"Line":10}},{"line":277,"address":[],"length":0,"stats":{"Line":3}},{"line":279,"address":[],"length":0,"stats":{"Line":3}}],"covered":92,"coverable":124},{"path":["/","Users","yuvikachaudhary","Desktop","Semester 4","COP290","spreadsheet_rust","src","terminal","types.rs"],"content":"/// Common types module used throughout the terminal spreadsheet application.\n///\n/// This module defines fundamental types like Coordinates that are\n/// used across different components of the spreadsheet.\nuse std::fmt;\n\n/// Represents coordinates within the spreadsheet grid.\n///\n/// Used to identify cells by their row and column positions, and to\n/// represent positions for operations and rendering.\n#[derive(Debug, Clone, Copy, PartialEq, Default)]\npub struct Coordinates {\n    /// The row index (0-based)\n    pub row: i32,\n\n    /// The column index (0-based)\n    pub col: i32,\n}\n\nimpl fmt::Display for Coordinates {\n    /// Formats the Coordinates for display.\n    ///\n    /// # Arguments\n    ///\n    /// * `f` - The formatter\n    ///\n    /// # Returns\n    ///\n    /// A Result indicating whether the formatting succeeded\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"({}, {})\", self.row, self.col)\n    }\n}\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":1}},{"line":31,"address":[],"length":0,"stats":{"Line":1}}],"covered":2,"coverable":2},{"path":["/","Users","yuvikachaudhary","Desktop","Semester 4","COP290","spreadsheet_rust","tests","backend_ext.rs"],"content":"use project::extension::backend::backend::*;\n#[allow(unused_imports)]\nuse project::extension::common::{Operation, Value};\nuse std::fs;\n\n#[test]\nfn test_init_backend() {\n    let backend = Backend::init_backend(10, 15);\n    let grid = backend.get_grid();\n    assert_eq!(grid.get_row_size(), 10 + 1);\n    assert_eq!(grid.get_column_size(), 15 + 1);\n    assert_eq!(grid.get_node_value(9, 14), Some(0));\n}\n\n#[test]\n#[should_panic(expected = \"Expected a Cell value\")]\nfn test_init_backend1() {\n    let backend = Backend::init_backend(10, 15);\n    let val = Value::Const(5);\n    backend.get_node_value(val);\n}\n\n#[test]\nfn test_grid_new() {\n    let grid = Grid::new(10, 15);\n    assert_eq!(grid.get_row_size(), 10);\n    assert_eq!(grid.get_column_size(), 15);\n}\n\n#[test]\nfn test_valgrid_creation() {\n    let backend = Backend::init_backend(5, 5);\n    let valgrid = backend.get_valgrid();\n    assert_eq!(valgrid.rows, 6);\n    assert_eq!(valgrid.columns, 6);\n}\n\n#[test]\nfn test_process_command_assign_value() {\n    let mut backend = Backend::init_backend(10, 10);\n    let status = backend.process_command(10, 10, \"A1=5\".to_string());\n    assert_eq!(status, Status::Success);\n    assert_eq!(backend.get_node_value(Value::Cell(1, 1)), Some(5));\n}\n\n#[test]\nfn test_process_command_invalid() {\n    let mut backend = Backend::init_backend(10, 10);\n    let status = backend.process_command(10, 10, \"invalid command\".to_string());\n    assert_eq!(status, Status::UnrecognizedCmd);\n}\n\n#[test]\nfn test_process_command_sum() {\n    let mut backend = Backend::init_backend(10, 10);\n    // Assign values to cells\n    backend.process_command(10, 10, \"A1=5\".to_string());\n    backend.process_command(10, 10, \"A2=10\".to_string());\n    backend.process_command(10, 10, \"A3=15\".to_string());\n\n    // Test SUM function\n    let status = backend.process_command(10, 10, \"B1=SUM(A1:A3)\".to_string());\n    assert_eq!(status, Status::Success);\n    assert_eq!(backend.get_node_value(Value::Cell(1, 2)), Some(30));\n}\n\n#[test]\nfn test_process_command_avg() {\n    let mut backend = Backend::init_backend(10, 10);\n    // Assign values to cells\n    backend.process_command(10, 10, \"A1=6\".to_string());\n    backend.process_command(10, 10, \"A2=12\".to_string());\n    backend.process_command(10, 10, \"A3=18\".to_string());\n\n    // Test AVG function\n\n    let status = backend.process_command(10, 10, \"B1=AVG(A1:A3)\".to_string());\n    assert_eq!(status, Status::Success);\n    assert_eq!(backend.get_node_value(Value::Cell(1, 2)), Some(12));\n}\n\n#[test]\nfn test_process_command_arithmetic() {\n    let mut backend = Backend::init_backend(10, 10);\n    // Assign values to cells\n    backend.process_command(10, 10, \"A1=5\".to_string());\n    backend.process_command(10, 10, \"A2=10\".to_string());\n\n    // Test arithmetic operations\n    backend.process_command(10, 10, \"B1=A1+A2\".to_string()); // Addition\n    backend.process_command(10, 10, \"B2=A2-A1\".to_string()); // Subtraction\n    backend.process_command(10, 10, \"B3=A1*A2\".to_string()); // Multiplication\n    backend.process_command(10, 10, \"B4=A2/A1\".to_string()); // Division\n\n    assert_eq!(backend.get_node_value(Value::Cell(1, 2)), Some(15)); // 5+10\n    assert_eq!(backend.get_node_value(Value::Cell(2, 2)), Some(5)); // 10-5\n    assert_eq!(backend.get_node_value(Value::Cell(3, 2)), Some(50)); // 5*10\n    assert_eq!(backend.get_node_value(Value::Cell(4, 2)), Some(2)); // 10/5\n}\n\n#[test]\nfn test_process_command_stdev() {\n    let mut backend = Backend::init_backend(10, 10);\n    // Assign values to cells\n    backend.process_command(10, 10, \"A1=5\".to_string());\n    backend.process_command(10, 10, \"A2=10\".to_string());\n    backend.process_command(10, 10, \"A3=15\".to_string());\n\n    // Test SUM function\n    let status = backend.process_command(10, 10, \"B1=STDEV(A1:A3)\".to_string());\n    assert_eq!(status, Status::Success);\n    assert_eq!(backend.get_node_value(Value::Cell(1, 2)), Some(4));\n}\n\n#[test]\nfn test_process_command_stdev_none() {\n    let mut backend = Backend::init_backend(10, 10);\n    // Assign values to cells\n    backend.process_command(10, 10, \"A1=5\".to_string());\n    backend.process_command(10, 10, \"A2=10\".to_string());\n    backend.process_command(10, 10, \"A3=15\".to_string());\n    backend.grid.cells_vec[1][1].valid = false;\n    // Test SUM function\n    let status = backend.process_command(10, 10, \"B1=STDEV(A1:A3)\".to_string());\n    assert_eq!(status, Status::Success);\n    assert_eq!(backend.get_node_value(Value::Cell(1, 2)), None);\n}\n\n#[test]\nfn test_process_command_sleep() {\n    let mut backend = Backend::init_backend(10, 10);\n    // Assign values to cells\n    backend.process_command(10, 10, \"A1=1\".to_string());\n    backend.process_command(10, 10, \"A2=10\".to_string());\n    backend.process_command(10, 10, \"A3=15\".to_string());\n\n    // Test SUM function\n    let status = backend.process_command(10, 10, \"B1=SLEEP(A1)\".to_string());\n    assert_eq!(status, Status::Success);\n    assert_eq!(backend.get_node_value(Value::Cell(1, 2)), Some(1));\n}\n\n#[test]\nfn test_process_command_sleep_none() {\n    let mut backend = Backend::init_backend(10, 10);\n    // Assign values to cells\n    backend.process_command(10, 10, \"A1=5\".to_string());\n    backend.process_command(10, 10, \"A2=10\".to_string());\n    backend.process_command(10, 10, \"A3=15\".to_string());\n    backend.grid.cells_vec[1][1].valid = false;\n    // Test SUM function\n    let status = backend.process_command(10, 10, \"B1=SLEEP(A1)\".to_string());\n    assert_eq!(status, Status::Success);\n}\n\n#[test]\nfn test_process_command_sum_none() {\n    let mut backend = Backend::init_backend(10, 10);\n    // Assign values to cells\n    backend.process_command(10, 10, \"A1=5\".to_string());\n    backend.process_command(10, 10, \"A2=10\".to_string());\n    backend.process_command(10, 10, \"A3=15\".to_string());\n    backend.grid.cells_vec[1][1].valid = false;\n    // Test SUM function\n    let status = backend.process_command(10, 10, \"B1=SUM(A1:A3)\".to_string());\n    assert_eq!(status, Status::Success);\n    assert_eq!(backend.get_node_value(Value::Cell(1, 2)), None);\n}\n\n#[test]\nfn test_process_command_avg_none() {\n    let mut backend = Backend::init_backend(10, 10);\n    // Assign values to cells\n    backend.process_command(10, 10, \"A1=6\".to_string());\n    backend.process_command(10, 10, \"A2=12\".to_string());\n    backend.process_command(10, 10, \"A3=18\".to_string());\n\n    // Test AVG function\n    backend.grid.cells_vec[1][1].valid = false;\n    let status = backend.process_command(10, 10, \"B1=AVG(A1:A3)\".to_string());\n    assert_eq!(status, Status::Success);\n    assert_eq!(backend.get_node_value(Value::Cell(1, 2)), None);\n}\n\n#[test]\nfn test_process_command_arithmetic_none() {\n    let mut backend = Backend::init_backend(10, 10);\n    // Assign values to cells\n    backend.process_command(10, 10, \"A1=5\".to_string());\n    backend.process_command(10, 10, \"A2=10\".to_string());\n    // Test arithmetic operations\n    backend.grid.cells_vec[1][1].valid = false;\n    backend.process_command(10, 10, \"B1=A1+A2\".to_string()); // Addition\n    backend.process_command(10, 10, \"B2=A2-A1\".to_string()); // Subtraction\n    backend.process_command(10, 10, \"B3=A1*A2\".to_string()); // Multiplication\n    backend.process_command(10, 10, \"B4=A2/A1\".to_string()); // Division\n\n    assert_eq!(backend.get_node_value(Value::Cell(1, 2)), None); // 5+10\n    assert_eq!(backend.get_node_value(Value::Cell(2, 2)), None); // 10-5\n    assert_eq!(backend.get_node_value(Value::Cell(3, 2)), None); // 5*10\n    assert_eq!(backend.get_node_value(Value::Cell(4, 2)), None); // 10/5\n}\n\n#[test]\nfn test_circular_dependency() {\n    let mut backend = Backend::init_backend(10, 10);\n    // Create a circular dependency\n    backend.process_command(10, 10, \"A1=5\".to_string());\n    backend.process_command(10, 10, \"A2=A1+10\".to_string());\n    let status = backend.process_command(10, 10, \"A1=A2+5\".to_string());\n\n    assert_eq!(status, Status::CircularDependency);\n}\n\n#[test]\nfn test_undo_redo() {\n    let mut backend = Backend::init_backend(10, 10);\n\n    // Make changes\n    backend.process_command(10, 10, \"A1=5\".to_string());\n    assert_eq!(backend.get_node_value(Value::Cell(1, 1)), Some(5));\n\n    backend.process_command(10, 10, \"A1=10\".to_string());\n    assert_eq!(backend.get_node_value(Value::Cell(1, 1)), Some(10));\n\n    // Undo\n    backend.process_command(10, 10, \"undo\".to_string());\n    assert_eq!(backend.get_node_value(Value::Cell(1, 1)), Some(5));\n\n    // Redo\n    backend.process_command(10, 10, \"redo\".to_string());\n    assert_eq!(backend.get_node_value(Value::Cell(1, 1)), Some(10));\n}\n\n#[test]\nfn test_serialization() {\n    let mut backend = Backend::init_backend(5, 5);\n    backend.process_command(5, 5, \"A1=42\".to_string());\n\n    // Create a temporary file path\n    let temp_file = \"test_serialization.json\";\n\n    // Serialize\n    let result = backend.serial(temp_file);\n    assert!(result.is_ok());\n\n    // Deserialize\n    let loaded_backend = Backend::deserial(temp_file);\n    assert!(loaded_backend.is_ok());\n\n    let loaded_backend = loaded_backend.unwrap();\n    assert_eq!(loaded_backend.get_node_value(Value::Cell(1, 1)), Some(42));\n\n    // Clean up\n    if let Ok(_) = fs::remove_file(temp_file) {\n        // File deleted successfully\n    }\n}\n\n#[test]\nfn test_invalid_range() {\n    let mut backend = Backend::init_backend(10, 10);\n    let status = backend.process_command(10, 10, \"A1=SUM(Z1:Z10)\".to_string());\n    // Z column is beyond our 10 columns, so it should report invalid range\n    assert_eq!(status, Status::UnrecognizedCmd);\n}\n\n#[test]\nfn test_min_max_functions() {\n    let mut backend = Backend::init_backend(10, 10);\n    // Assign values to cells\n    backend.process_command(10, 10, \"A1=5\".to_string());\n    backend.process_command(10, 10, \"A2=10\".to_string());\n    backend.process_command(10, 10, \"A3=15\".to_string());\n    backend.process_command(10, 10, \"A4=2\".to_string());\n\n    // Test MIN and MAX functions\n    backend.process_command(10, 10, \"B1=MIN(A1:A4)\".to_string());\n    backend.process_command(10, 10, \"B2=MAX(A1:A4)\".to_string());\n\n    assert_eq!(backend.get_node_value(Value::Cell(1, 2)), Some(2)); // MIN\n    assert_eq!(backend.get_node_value(Value::Cell(2, 2)), Some(15)); // MAX\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","yuvikachaudhary","Desktop","Semester 4","COP290","spreadsheet_rust","tests","backend_terminal.rs"],"content":"use project::terminal::backend::*;\nuse project::terminal::functions::Operation;\n#[allow(unused_imports)]\nuse project::terminal::graph::Node;\nuse project::terminal::types::Coordinates;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_generate_grid() {\n        let grid = generate_grid(3, 3);\n\n        // Check grid dimensions\n        assert_eq!(grid.len(), 4); // 0-indexed + specified rows\n        assert_eq!(grid[0].len(), 4); // 0-indexed + specified columns\n\n        // Check node initialization\n        let node = \u0026grid[1][2]; // Random cell\n        assert_eq!(node.node_value, 0);\n        assert_eq!(node.value1, Coordinates { row: -1, col: -1 });\n        assert_eq!(node.value2, Coordinates { row: -1, col: -1 });\n        assert_eq!(node.position, Coordinates { row: 1, col: 2 });\n        assert_eq!(node.op, Operation::Cons);\n        assert!(node.valid);\n        assert!(!node.visited);\n        assert!(node.dependents.is_empty());\n    }\n\n    #[test]\n    fn test_add_edges_binary_operation() {\n        let mut grid = generate_grid(3, 3);\n\n        // Create a simple dependency: C1 = A1 + B1\n        let a1 = Coordinates { row: 1, col: 1 };\n        let b1 = Coordinates { row: 1, col: 2 };\n        let c1 = Coordinates { row: 1, col: 3 };\n\n        add_edges(\u0026mut grid, a1, b1, c1, Operation::Add, true);\n\n        // Check that A1 and B1 have C1 as dependent\n        assert!(grid[1][1].dependents.contains(\u0026c1));\n        assert!(grid[1][2].dependents.contains(\u0026c1));\n    }\n\n    #[test]\n    fn test_add_edges_range_operation() {\n        let mut grid = generate_grid(3, 3);\n\n        // Create a range dependency: D1 = SUM(A1:B2)\n        let a1 = Coordinates { row: 1, col: 1 };\n        let b2 = Coordinates { row: 2, col: 2 };\n        let d1 = Coordinates { row: 1, col: 3 };\n\n        add_edges(\u0026mut grid, a1, b2, d1, Operation::Sum, true);\n\n        // Check that all cells in range have D1 as dependent\n        assert!(grid[1][1].dependents.contains(\u0026d1)); // A1\n        assert!(grid[1][2].dependents.contains(\u0026d1)); // B1\n        assert!(grid[2][1].dependents.contains(\u0026d1)); // A2\n        assert!(grid[2][2].dependents.contains(\u0026d1)); // B2\n    }\n\n    #[test]\n    fn test_add_edges_range_sleep() {\n        let mut grid = generate_grid(3, 3);\n\n        // Create a range dependency: D1 = SUM(A1:B2)\n        let a1 = Coordinates { row: -1, col: -1 };\n        let b2 = Coordinates { row: 2, col: 2 };\n        let d1 = Coordinates { row: 1, col: 3 };\n\n        add_edges(\u0026mut grid, a1, b2, d1, Operation::Slp, true);\n\n        // Check that all cells in range have D1 as dependent\n        assert!(!grid[1][1].dependents.contains(\u0026d1)); // A1\n    }\n\n    #[test]\n    fn test_add_edges_range_enable() {\n        let mut grid = generate_grid(3, 3);\n\n        // Create a range dependency: D1 = SUM(A1:B2)\n        let a1 = Coordinates { row: -1, col: -1 };\n        let b2 = Coordinates { row: 2, col: 2 };\n        let d1 = Coordinates { row: 1, col: 3 };\n\n        add_edges(\u0026mut grid, a1, b2, d1, Operation::EnableOutput, true);\n\n        // Check that all cells in range have D1 as dependent\n        assert!(!grid[1][1].dependents.contains(\u0026d1)); // A1\n        assert!(!grid[1][2].dependents.contains(\u0026d1)); // B1\n        assert!(!grid[2][1].dependents.contains(\u0026d1)); // A2\n        assert!(!grid[2][2].dependents.contains(\u0026d1)); // B2\n    }\n\n    #[test]\n    fn test_break_edges_binary_operation() {\n        let mut grid = generate_grid(3, 3);\n\n        // Setup: C1 = A1 + B1\n        let a1 = Coordinates { row: 1, col: 1 };\n        let b1 = Coordinates { row: 1, col: 2 };\n        let c1 = Coordinates { row: 1, col: 3 };\n\n        // First add edges\n        add_edges(\u0026mut grid, a1, b1, c1, Operation::Add, true);\n\n        // Then break them\n        break_edges(\u0026mut grid, a1, b1, c1, Operation::Add, true);\n\n        // Check that A1 and B1 no longer have C1 as dependent\n        assert!(!grid[1][1].dependents.contains(\u0026c1));\n        assert!(!grid[1][2].dependents.contains(\u0026c1));\n    }\n\n    #[test]\n    fn test_break_edges_range_operation() {\n        let mut grid = generate_grid(3, 3);\n\n        // Setup: D1 = SUM(A1:B2)\n        let a1 = Coordinates { row: 1, col: 1 };\n        let b2 = Coordinates { row: 2, col: 2 };\n        let d1 = Coordinates { row: 1, col: 3 };\n\n        // First add edges\n        add_edges(\u0026mut grid, a1, b2, d1, Operation::Sum, true);\n\n        // Then break them\n        break_edges(\u0026mut grid, a1, b2, d1, Operation::Sum, true);\n\n        // Check that all cells in range no longer have D1 as dependent\n        assert!(!grid[1][1].dependents.contains(\u0026d1)); // A1\n        assert!(!grid[1][2].dependents.contains(\u0026d1)); // B1\n        assert!(!grid[2][1].dependents.contains(\u0026d1)); // A2\n        assert!(!grid[2][2].dependents.contains(\u0026d1)); // B2\n    }\n\n    #[test]\n    fn test_has_cycle_no_cycle() {\n        let mut grid = generate_grid(3, 3);\n\n        // Setup: B1 = A1 + 5\n        let a1 = Coordinates { row: 1, col: 1 };\n        let b1 = Coordinates { row: 1, col: 2 };\n        let five = Coordinates { row: 5, col: -1 }; // constant value 5\n\n        add_edges(\u0026mut grid, a1, five, b1, Operation::Add, true);\n\n        // This shouldn't create a cycle\n        assert!(!has_cycle(b1, \u0026mut grid));\n    }\n\n    #[test]\n    fn test_has_cycle_direct_cycle() {\n        let mut grid = generate_grid(3, 3);\n\n        // Setup: A1 = B1 + 5, B1 = A1 + 3\n        let a1 = Coordinates { row: 1, col: 1 };\n        let b1 = Coordinates { row: 1, col: 2 };\n        let five = Coordinates { row: 5, col: -1 }; // constant value 5\n        let three = Coordinates { row: 3, col: -1 }; // constant value 3\n\n        // First add A1 = B1 + 5\n        add_edges(\u0026mut grid, b1, five, a1, Operation::Add, true);\n\n        // Now try to add B1 = A1 + 3 (which creates a cycle)\n        add_edges(\u0026mut grid, a1, three, b1, Operation::Add, true);\n\n        // This should detect a cycle\n        assert!(has_cycle(b1, \u0026mut grid));\n    }\n\n    #[test]\n    fn test_has_cycle_indirect_cycle() {\n        let mut grid = generate_grid(3, 3);\n\n        // Setup: A1 = C1 + 1, B1 = A1 + 2, C1 = B1 + 3\n        let a1 = Coordinates { row: 1, col: 1 };\n        let b1 = Coordinates { row: 1, col: 2 };\n        let c1 = Coordinates { row: 1, col: 3 };\n        let one = Coordinates { row: 1, col: -1 };\n        let two = Coordinates { row: 2, col: -1 };\n        let three = Coordinates { row: 3, col: -1 };\n\n        // Add first two relationships\n        add_edges(\u0026mut grid, c1, one, a1, Operation::Add, true);\n        add_edges(\u0026mut grid, a1, two, b1, Operation::Add, true);\n\n        // Now try to add C1 = B1 + 3 (which creates an indirect cycle)\n        add_edges(\u0026mut grid, b1, three, c1, Operation::Add, true);\n\n        // This should detect a cycle\n        assert!(has_cycle(c1, \u0026mut grid));\n    }\n\n    #[test]\n    fn test_evaluate_node_constant() {\n        let mut grid = generate_grid(3, 3);\n\n        // Set A1 = 42\n        let a1 = Coordinates { row: 1, col: 1 };\n        let val = Coordinates { row: 42, col: -1 }; // constant value 42\n\n        grid[1][1].op = Operation::Cons;\n        grid[1][1].value1 = val;\n\n        evaluate_node(\u0026mut grid, a1);\n\n        // Check that A1 has value 42\n        assert_eq!(grid[1][1].node_value, 42);\n        assert!(grid[1][1].valid);\n    }\n\n    #[test]\n    fn test_evaluate_node_binary_add() {\n        let mut grid = generate_grid(3, 3);\n\n        // Set A1 = 10, B1 = 20, C1 = A1 + B1\n        let a1 = Coordinates { row: 1, col: 1 };\n        let b1 = Coordinates { row: 1, col: 2 };\n        let c1 = Coordinates { row: 1, col: 3 };\n\n        // Set values for A1 and B1\n        grid[1][1].op = Operation::Cons;\n        grid[1][1].value1 = Coordinates { row: 10, col: -1 };\n        grid[1][2].op = Operation::Cons;\n        grid[1][2].value1 = Coordinates { row: 20, col: -1 };\n\n        // Evaluate them first\n        evaluate_node(\u0026mut grid, a1);\n        evaluate_node(\u0026mut grid, b1);\n\n        // Set C1 = A1 + B1\n        grid[1][3].op = Operation::Add;\n        grid[1][3].value1 = a1;\n        grid[1][3].value2 = b1;\n\n        // Add dependencies\n        add_edges(\u0026mut grid, a1, b1, c1, Operation::Add, true);\n\n        // Evaluate C1\n        evaluate_node(\u0026mut grid, c1);\n\n        // Check result\n        assert_eq!(grid[1][3].node_value, 30); // 10 + 20\n        assert!(grid[1][3].valid);\n    }\n\n    #[test]\n    fn test_evaluate_node_binary_add_1() {\n        let mut grid = generate_grid(3, 3);\n\n        // Set A1 = 10, B1 = 20, C1 = A1 + B1\n        let a1 = Coordinates { row: 1, col: 1 };\n        let b1 = Coordinates { row: 1, col: 2 };\n        let c1 = Coordinates { row: 1, col: 3 };\n\n        // Set values for A1 and B1\n        grid[1][1].op = Operation::Cons;\n        grid[1][1].value1 = Coordinates { row: 10, col: -1 };\n        grid[1][2].op = Operation::Cons;\n        grid[1][2].value1 = Coordinates { row: 20, col: -1 };\n\n        // Evaluate them first\n        evaluate_node(\u0026mut grid, a1);\n        evaluate_node(\u0026mut grid, b1);\n\n        // Set C1 = A1 + B1\n        grid[1][3].op = Operation::Add;\n        grid[1][3].value1 = Coordinates { row: 1, col: -1 };\n        grid[1][3].value2 = Coordinates { row: 1, col: 2 };\n\n        // Add dependencies\n        add_edges(\u0026mut grid, a1, b1, c1, Operation::Add, true);\n\n        // Evaluate C1\n        evaluate_node(\u0026mut grid, c1);\n\n        // Check result\n        assert_eq!(grid[1][3].node_value, 21); // 10 + 20\n        assert!(grid[1][3].valid);\n    }\n\n    #[test]\n    fn test_evaluate_node_binary_add_2() {\n        let mut grid = generate_grid(3, 3);\n\n        // Set A1 = 10, B1 = 20, C1 = A1 + B1\n        let a1 = Coordinates { row: 1, col: 1 };\n        let b1 = Coordinates { row: 1, col: 2 };\n        let c1 = Coordinates { row: 1, col: 3 };\n\n        // Set values for A1 and B1\n        grid[1][1].op = Operation::Cons;\n        grid[1][1].value1 = Coordinates { row: 10, col: -1 };\n        grid[1][2].op = Operation::Cons;\n        grid[1][2].value1 = Coordinates { row: 20, col: -1 };\n\n        // Evaluate them first\n        evaluate_node(\u0026mut grid, a1);\n        evaluate_node(\u0026mut grid, b1);\n\n        // Set C1 = A1 + B1\n        grid[1][3].op = Operation::Add;\n        grid[1][3].value1 = Coordinates { row: 1, col: 1 };\n        grid[1][3].value2 = Coordinates { row: 1, col: -1 };\n\n        // Add dependencies\n        add_edges(\u0026mut grid, a1, b1, c1, Operation::Add, true);\n\n        // Evaluate C1\n        evaluate_node(\u0026mut grid, c1);\n\n        // Check result\n        assert_eq!(grid[1][3].node_value, 11); // 10 + 20\n        assert!(grid[1][3].valid);\n    }\n\n    #[test]\n    fn test_evaluate_node_binary_add_3() {\n        let mut grid = generate_grid(3, 3);\n\n        // Set A1 = 10, B1 = 20, C1 = A1 + B1\n        let a1 = Coordinates { row: 1, col: 1 };\n        let b1 = Coordinates { row: 1, col: 2 };\n        let c1 = Coordinates { row: 1, col: 3 };\n\n        // Set values for A1 and B1\n        grid[1][1].op = Operation::Cons;\n        grid[1][1].value1 = Coordinates { row: 10, col: -1 };\n        grid[1][2].op = Operation::Cons;\n        grid[1][2].value1 = Coordinates { row: 20, col: -1 };\n\n        // Evaluate them first\n        evaluate_node(\u0026mut grid, a1);\n        evaluate_node(\u0026mut grid, b1);\n\n        // Set C1 = A1 + B1\n        grid[1][3].op = Operation::Add;\n        grid[1][3].value1 = Coordinates { row: 1, col: -1 };\n        grid[1][3].value2 = Coordinates { row: 1, col: -1 };\n\n        // Add dependencies\n        add_edges(\u0026mut grid, a1, b1, c1, Operation::Add, true);\n\n        // Evaluate C1\n        evaluate_node(\u0026mut grid, c1);\n\n        // Check result\n        assert_eq!(grid[1][3].node_value, 2); // 10 + 20\n        assert!(grid[1][3].valid);\n    }\n\n    #[test]\n    fn test_evaluate_node_binary_sub() {\n        let mut grid = generate_grid(3, 3);\n\n        // Set A1 = 30, B1 = 12, C1 = A1 - B1\n        let a1 = Coordinates { row: 1, col: 1 };\n        let b1 = Coordinates { row: 1, col: 2 };\n        let c1 = Coordinates { row: 1, col: 3 };\n\n        // Set values for A1 and B1\n        grid[1][1].op = Operation::Cons;\n        grid[1][1].value1 = Coordinates { row: 30, col: -1 };\n        grid[1][2].op = Operation::Cons;\n        grid[1][2].value1 = Coordinates { row: 12, col: -1 };\n\n        // Evaluate them first\n        evaluate_node(\u0026mut grid, a1);\n        evaluate_node(\u0026mut grid, b1);\n\n        // Set C1 = A1 - B1\n        grid[1][3].op = Operation::Sub;\n        grid[1][3].value1 = a1;\n        grid[1][3].value2 = b1;\n\n        // Add dependencies\n        add_edges(\u0026mut grid, a1, b1, c1, Operation::Sub, true);\n\n        // Evaluate C1\n        evaluate_node(\u0026mut grid, c1);\n\n        // Check result\n        assert_eq!(grid[1][3].node_value, 18); // 30 - 12\n        assert!(grid[1][3].valid);\n    }\n\n    #[test]\n    fn test_evaluate_node_binary_sub1() {\n        let mut grid = generate_grid(3, 3);\n\n        // Set A1 = 10, B1 = 20, C1 = A1 + B1\n        let a1 = Coordinates { row: 1, col: 1 };\n        let b1 = Coordinates { row: 1, col: 2 };\n        let c1 = Coordinates { row: 1, col: 3 };\n\n        // Set values for A1 and B1\n        grid[1][1].op = Operation::Cons;\n        grid[1][1].value1 = Coordinates { row: 10, col: -1 };\n        grid[1][2].op = Operation::Cons;\n        grid[1][2].value1 = Coordinates { row: 20, col: -1 };\n\n        // Evaluate them first\n        evaluate_node(\u0026mut grid, a1);\n        evaluate_node(\u0026mut grid, b1);\n\n        // Set C1 = A1 + B1\n        grid[1][3].op = Operation::Sub;\n        grid[1][3].value1 = Coordinates { row: 1, col: -1 };\n        grid[1][3].value2 = Coordinates { row: 1, col: 2 };\n\n        // Add dependencies\n        add_edges(\u0026mut grid, a1, b1, c1, Operation::Sub, true);\n\n        // Evaluate C1\n        evaluate_node(\u0026mut grid, c1);\n\n        // Check result\n        assert_eq!(grid[1][3].node_value, -19); // 10 + 20\n        assert!(grid[1][3].valid);\n    }\n\n    #[test]\n    fn test_evaluate_node_binary_sub2() {\n        let mut grid = generate_grid(3, 3);\n\n        // Set A1 = 10, B1 = 20, C1 = A1 + B1\n        let a1 = Coordinates { row: 1, col: 1 };\n        let b1 = Coordinates { row: 1, col: 2 };\n        let c1 = Coordinates { row: 1, col: 3 };\n\n        // Set values for A1 and B1\n        grid[1][1].op = Operation::Cons;\n        grid[1][1].value1 = Coordinates { row: 10, col: -1 };\n        grid[1][2].op = Operation::Cons;\n        grid[1][2].value1 = Coordinates { row: 20, col: -1 };\n\n        // Evaluate them first\n        evaluate_node(\u0026mut grid, a1);\n        evaluate_node(\u0026mut grid, b1);\n\n        // Set C1 = A1 + B1\n        grid[1][3].op = Operation::Sub;\n        grid[1][3].value1 = Coordinates { row: 1, col: 1 };\n        grid[1][3].value2 = Coordinates { row: 1, col: -1 };\n\n        // Add dependencies\n        add_edges(\u0026mut grid, a1, b1, c1, Operation::Sub, true);\n\n        // Evaluate C1\n        evaluate_node(\u0026mut grid, c1);\n\n        // Check result\n        assert_eq!(grid[1][3].node_value, 9); // 10 + 20\n        assert!(grid[1][3].valid);\n    }\n\n    #[test]\n    fn test_evaluate_node_binary_sub3() {\n        let mut grid = generate_grid(3, 3);\n\n        // Set A1 = 10, B1 = 20, C1 = A1 + B1\n        let a1 = Coordinates { row: 1, col: 1 };\n        let b1 = Coordinates { row: 1, col: 2 };\n        let c1 = Coordinates { row: 1, col: 3 };\n\n        // Set values for A1 and B1\n        grid[1][1].op = Operation::Cons;\n        grid[1][1].value1 = Coordinates { row: 10, col: -1 };\n        grid[1][2].op = Operation::Cons;\n        grid[1][2].value1 = Coordinates { row: 20, col: -1 };\n\n        // Evaluate them first\n        evaluate_node(\u0026mut grid, a1);\n        evaluate_node(\u0026mut grid, b1);\n\n        // Set C1 = A1 + B1\n        grid[1][3].op = Operation::Sub;\n        grid[1][3].value1 = Coordinates { row: 1, col: -1 };\n        grid[1][3].value2 = Coordinates { row: 1, col: -1 };\n\n        // Add dependencies\n        add_edges(\u0026mut grid, a1, b1, c1, Operation::Sub, true);\n\n        // Evaluate C1\n        evaluate_node(\u0026mut grid, c1);\n\n        // Check result\n        assert_eq!(grid[1][3].node_value, 0); // 10 + 20\n        assert!(grid[1][3].valid);\n    }\n\n    #[test]\n    fn test_evaluate_node_binary_mul() {\n        let mut grid = generate_grid(3, 3);\n\n        // Set A1 = 7, B1 = 6, C1 = A1 * B1\n        let a1 = Coordinates { row: 1, col: 1 };\n        let b1 = Coordinates { row: 1, col: 2 };\n        let c1 = Coordinates { row: 1, col: 3 };\n\n        // Set values for A1 and B1\n        grid[1][1].op = Operation::Cons;\n        grid[1][1].value1 = Coordinates { row: 7, col: -1 };\n        grid[1][2].op = Operation::Cons;\n        grid[1][2].value1 = Coordinates { row: 6, col: -1 };\n\n        // Evaluate them first\n        evaluate_node(\u0026mut grid, a1);\n        evaluate_node(\u0026mut grid, b1);\n\n        // Set C1 = A1 * B1\n        grid[1][3].op = Operation::Mul;\n        grid[1][3].value1 = a1;\n        grid[1][3].value2 = b1;\n\n        // Add dependencies\n        add_edges(\u0026mut grid, a1, b1, c1, Operation::Mul, true);\n\n        // Evaluate C1\n        evaluate_node(\u0026mut grid, c1);\n\n        // Check result\n        assert_eq!(grid[1][3].node_value, 42); // 7 * 6\n        assert!(grid[1][3].valid);\n    }\n\n    #[test]\n    fn test_evaluate_node_binary_mul1() {\n        let mut grid = generate_grid(3, 3);\n\n        // Set A1 = 10, B1 = 20, C1 = A1 + B1\n        let a1 = Coordinates { row: 1, col: 1 };\n        let b1 = Coordinates { row: 1, col: 2 };\n        let c1 = Coordinates { row: 1, col: 3 };\n\n        // Set values for A1 and B1\n        grid[1][1].op = Operation::Cons;\n        grid[1][1].value1 = Coordinates { row: 10, col: -1 };\n        grid[1][2].op = Operation::Cons;\n        grid[1][2].value1 = Coordinates { row: 20, col: -1 };\n\n        // Evaluate them first\n        evaluate_node(\u0026mut grid, a1);\n        evaluate_node(\u0026mut grid, b1);\n\n        // Set C1 = A1 + B1\n        grid[1][3].op = Operation::Mul;\n        grid[1][3].value1 = Coordinates { row: 1, col: -1 };\n        grid[1][3].value2 = Coordinates { row: 1, col: 2 };\n\n        // Add dependencies\n        add_edges(\u0026mut grid, a1, b1, c1, Operation::Mul, true);\n\n        // Evaluate C1\n        evaluate_node(\u0026mut grid, c1);\n\n        // Check result\n        assert_eq!(grid[1][3].node_value, 20); // 10 + 20\n        assert!(grid[1][3].valid);\n    }\n\n    #[test]\n    fn test_evaluate_node_binary_mul2() {\n        let mut grid = generate_grid(3, 3);\n\n        // Set A1 = 10, B1 = 20, C1 = A1 + B1\n        let a1 = Coordinates { row: 1, col: 1 };\n        let b1 = Coordinates { row: 1, col: 2 };\n        let c1 = Coordinates { row: 1, col: 3 };\n\n        // Set values for A1 and B1\n        grid[1][1].op = Operation::Cons;\n        grid[1][1].value1 = Coordinates { row: 10, col: -1 };\n        grid[1][2].op = Operation::Cons;\n        grid[1][2].value1 = Coordinates { row: 20, col: -1 };\n\n        // Evaluate them first\n        evaluate_node(\u0026mut grid, a1);\n        evaluate_node(\u0026mut grid, b1);\n\n        // Set C1 = A1 + B1\n        grid[1][3].op = Operation::Mul;\n        grid[1][3].value1 = Coordinates { row: 1, col: 1 };\n        grid[1][3].value2 = Coordinates { row: 1, col: -1 };\n\n        // Add dependencies\n        add_edges(\u0026mut grid, a1, b1, c1, Operation::Mul, true);\n\n        // Evaluate C1\n        evaluate_node(\u0026mut grid, c1);\n\n        // Check result\n        assert_eq!(grid[1][3].node_value, 10); // 10 + 20\n        assert!(grid[1][3].valid);\n    }\n\n    #[test]\n    fn test_evaluate_node_binary_mul3() {\n        let mut grid = generate_grid(3, 3);\n\n        // Set A1 = 10, B1 = 20, C1 = A1 + B1\n        let a1 = Coordinates { row: 1, col: 1 };\n        let b1 = Coordinates { row: 1, col: 2 };\n        let c1 = Coordinates { row: 1, col: 3 };\n\n        // Set values for A1 and B1\n        grid[1][1].op = Operation::Cons;\n        grid[1][1].value1 = Coordinates { row: 10, col: -1 };\n        grid[1][2].op = Operation::Cons;\n        grid[1][2].value1 = Coordinates { row: 20, col: -1 };\n\n        // Evaluate them first\n        evaluate_node(\u0026mut grid, a1);\n        evaluate_node(\u0026mut grid, b1);\n\n        // Set C1 = A1 + B1\n        grid[1][3].op = Operation::Mul;\n        grid[1][3].value1 = Coordinates { row: 1, col: -1 };\n        grid[1][3].value2 = Coordinates { row: 1, col: -1 };\n\n        // Add dependencies\n        add_edges(\u0026mut grid, a1, b1, c1, Operation::Mul, true);\n\n        // Evaluate C1\n        evaluate_node(\u0026mut grid, c1);\n\n        // Check result\n        assert_eq!(grid[1][3].node_value, 1); // 10 + 20\n        assert!(grid[1][3].valid);\n    }\n    #[test]\n    fn test_evaluate_node_binary_div() {\n        let mut grid = generate_grid(3, 3);\n\n        // Set A1 = 20, B1 = 4, C1 = A1 / B1\n        let a1 = Coordinates { row: 1, col: 1 };\n        let b1 = Coordinates { row: 1, col: 2 };\n        let c1 = Coordinates { row: 1, col: 3 };\n\n        // Set values for A1 and B1\n        grid[1][1].op = Operation::Cons;\n        grid[1][1].value1 = Coordinates { row: 20, col: -1 };\n        grid[1][2].op = Operation::Cons;\n        grid[1][2].value1 = Coordinates { row: 4, col: -1 };\n\n        // Evaluate them first\n        evaluate_node(\u0026mut grid, a1);\n        evaluate_node(\u0026mut grid, b1);\n\n        // Set C1 = A1 / B1\n        grid[1][3].op = Operation::Div;\n        grid[1][3].value1 = a1;\n        grid[1][3].value2 = b1;\n\n        // Add dependencies\n        add_edges(\u0026mut grid, a1, b1, c1, Operation::Div, true);\n\n        // Evaluate C1\n        evaluate_node(\u0026mut grid, c1);\n\n        // Check result\n        assert_eq!(grid[1][3].node_value, 5); // 20 / 4\n        assert!(grid[1][3].valid);\n    }\n\n    #[test]\n    fn test_evaluate_node_div_by_zero() {\n        let mut grid = generate_grid(3, 3);\n\n        // Set A1 = 20, B1 = 0, C1 = A1 / B1\n        let a1 = Coordinates { row: 1, col: 1 };\n        let b1 = Coordinates { row: 1, col: 2 };\n        let c1 = Coordinates { row: 1, col: 3 };\n\n        // Set values for A1 and B1\n        grid[1][1].op = Operation::Cons;\n        grid[1][1].value1 = Coordinates { row: 20, col: -1 };\n        grid[1][2].op = Operation::Cons;\n        grid[1][2].value1 = Coordinates { row: 0, col: -1 };\n\n        // Evaluate them first\n        evaluate_node(\u0026mut grid, a1);\n        evaluate_node(\u0026mut grid, b1);\n\n        // Set C1 = A1 / B1\n        grid[1][3].op = Operation::Div;\n        grid[1][3].value1 = a1;\n        grid[1][3].value2 = b1;\n\n        // Add dependencies\n        add_edges(\u0026mut grid, a1, b1, c1, Operation::Div, true);\n\n        // Evaluate C1\n        evaluate_node(\u0026mut grid, c1);\n\n        // Check result - should be invalid due to division by zero\n        assert!(!grid[1][3].valid);\n    }\n\n    #[test]\n    fn test_getting_things_updated_success() {\n        let mut grid = generate_grid(3, 3);\n\n        // Set A1 = 10, B1 = 20\n        let a1 = Coordinates { row: 1, col: 1 };\n        let b1 = Coordinates { row: 1, col: 2 };\n        let c1 = Coordinates { row: 1, col: 3 };\n\n        // Set up initial values\n        grid[1][1].op = Operation::Cons;\n        grid[1][1].value1 = Coordinates { row: 10, col: -1 };\n        grid[1][2].op = Operation::Cons;\n        grid[1][2].value1 = Coordinates { row: 20, col: -1 };\n\n        // Evaluate initial values\n        evaluate_node(\u0026mut grid, a1);\n        evaluate_node(\u0026mut grid, b1);\n\n        // Now update C1 = A1 + B1\n        let result = getting_things_updated(\u0026mut grid, c1, a1, b1, Operation::Add);\n\n        // Check result code and cell value\n        assert_eq!(result, 1); // Success\n        assert_eq!(grid[1][3].node_value, 30); // 10 + 20\n    }\n\n    #[test]\n    fn test_getting_things_updated_cycle_detection() {\n        let mut grid = generate_grid(3, 3);\n\n        // Set up A1 = 10, B1 = A1 * 2\n        let a1 = Coordinates { row: 1, col: 1 };\n        let b1 = Coordinates { row: 1, col: 2 };\n        let two = Coordinates { row: 2, col: -1 };\n\n        // Set initial value for A1 = 10\n        grid[1][1].op = Operation::Cons;\n        grid[1][1].value1 = Coordinates { row: 10, col: -1 };\n        evaluate_node(\u0026mut grid, a1);\n\n        // Set B1 = A1 * 2\n        grid[1][2].op = Operation::Mul;\n        grid[1][2].value1 = a1;\n        grid[1][2].value2 = two;\n        add_edges(\u0026mut grid, a1, two, b1, Operation::Mul, true);\n        evaluate_node(\u0026mut grid, b1);\n\n        // Now try to update A1 = B1 + 5 (which would create a cycle)\n        let five = Coordinates { row: 5, col: -1 };\n        let result = getting_things_updated(\u0026mut grid, a1, b1, five, Operation::Add);\n\n        // Should detect cycle and return error code\n        assert_eq!(result, 5); // Cycle detected\n\n        // A1 should retain its original value\n        assert_eq!(grid[1][1].node_value, 10);\n    }\n\n    #[test]\n    fn test_update_topo_simple_chain() {\n        let mut grid = generate_grid(3, 3);\n\n        // Set A1 = 10, B1 = A1 * 2, C1 = B1 + 5\n        let a1 = Coordinates { row: 1, col: 1 };\n        let b1 = Coordinates { row: 1, col: 2 };\n        let c1 = Coordinates { row: 1, col: 3 };\n        let two = Coordinates { row: 2, col: -1 };\n        let five = Coordinates { row: 5, col: -1 };\n\n        // Set up initial values\n        grid[1][1].op = Operation::Cons;\n        grid[1][1].value1 = Coordinates { row: 10, col: -1 };\n        evaluate_node(\u0026mut grid, a1);\n\n        // Set B1 = A1 * 2\n        grid[1][2].op = Operation::Mul;\n        grid[1][2].value1 = a1;\n        grid[1][2].value2 = two;\n        add_edges(\u0026mut grid, a1, two, b1, Operation::Mul, true);\n\n        // Set C1 = B1 + 5\n        grid[1][3].op = Operation::Add;\n        grid[1][3].value1 = b1;\n        grid[1][3].value2 = five;\n        add_edges(\u0026mut grid, b1, five, c1, Operation::Add, true);\n\n        // Update starting from A1\n        update_topo(\u0026mut grid, a1);\n\n        // Check the propagated values\n        assert_eq!(grid[1][1].node_value, 10); // A1 = 10\n        assert_eq!(grid[1][2].node_value, 20); // B1 = A1 * 2 = 10 * 2 = 20\n        assert_eq!(grid[1][3].node_value, 25); // C1 = B1 + 5 = 20 + 5 = 25\n    }\n\n    #[test]\n    fn test_reset_visited() {\n        let mut grid = generate_grid(3, 3);\n\n        // Set up a simple structure with dependents\n        let a1 = Coordinates { row: 1, col: 1 };\n        let b1 = Coordinates { row: 1, col: 2 };\n        let c1 = Coordinates { row: 1, col: 3 };\n\n        // Mark all as visited\n        grid[1][1].visited = true;\n        grid[1][2].visited = true;\n        grid[1][3].visited = true;\n\n        // Set up dependencies: A1 -\u003e B1 -\u003e C1\n        grid[1][1].dependents.push(b1);\n        grid[1][2].dependents.push(c1);\n\n        // Reset visited flags starting from A1\n        reset_visited(\u0026mut grid, a1);\n\n        // Check that all flags were reset\n        assert!(!grid[1][1].visited);\n        assert!(!grid[1][2].visited);\n        assert!(!grid[1][3].visited);\n    }\n\n    #[test]\n    fn test_topological_sort() {\n        let mut grid = generate_grid(3, 3);\n\n        // Set up a simple structure with dependencies: A1 -\u003e B1 -\u003e C1\n        let a1 = Coordinates { row: 1, col: 1 };\n        let b1 = Coordinates { row: 1, col: 2 };\n        let c1 = Coordinates { row: 1, col: 3 };\n\n        // Set up dependencies\n        grid[1][1].dependents.push(b1);\n        grid[1][2].dependents.push(c1);\n\n        // Perform topological sort\n        let mut stack = Vec::new();\n        topological_sort(\u0026mut grid, a1, \u0026mut stack);\n\n        // Check the order in the stack (it should be C1, B1, A1)\n        assert_eq!(stack.len(), 3);\n        assert_eq!(stack[0], c1); // C1 should be first out of the stack\n        assert_eq!(stack[1], b1); // B1 should be second\n        assert_eq!(stack[2], a1); // A1 should be last\n    }\n    #[test]\n    fn test_evaluate_node_sleep() {\n        let mut grid = generate_grid(3, 3);\n        let a1 = Coordinates { row: 1, col: 1 };\n\n        grid[1][1].op = Operation::Slp;\n        grid[1][1].value1 = Coordinates { row: 1, col: -1 };\n\n        evaluate_node(\u0026mut grid, a1);\n\n        assert_eq!(grid[1][1].node_value, 1);\n        assert!(grid[1][1].valid);\n    }\n    #[test]\n    fn test_evaluate_node_std_range() {\n        let mut grid = generate_grid(3, 3);\n        let a1 = Coordinates { row: 1, col: 1 };\n        let b2 = Coordinates { row: 2, col: 2 };\n        let d1 = Coordinates { row: 1, col: 3 };\n\n        // Fill A1:B2 with constants\n        for i in 1..=2 {\n            for j in 1..=2 {\n                grid[i][j].op = Operation::Cons;\n                grid[i][j].value1 = Coordinates {\n                    row: 5 * (i + j) as i32,\n                    col: -1,\n                };\n                evaluate_node(\n                    \u0026mut grid,\n                    Coordinates {\n                        row: i as i32,\n                        col: j as i32,\n                    },\n                );\n            }\n        }\n\n        grid[1][3].op = Operation::Std;\n        grid[1][3].value1 = a1;\n        grid[1][3].value2 = b2;\n\n        evaluate_node(\u0026mut grid, d1);\n\n        assert!(grid[1][3].valid);\n    }\n    #[test]\n    fn test_evaluate_node_min_range() {\n        let mut grid = generate_grid(3, 3);\n        let a1 = Coordinates { row: 1, col: 1 };\n        let b2 = Coordinates { row: 2, col: 2 };\n        let d1 = Coordinates { row: 1, col: 3 };\n\n        // Fill A1:B2 with constants\n        for i in 1..=2 {\n            for j in 1..=2 {\n                grid[i][j].op = Operation::Cons;\n                grid[i][j].value1 = Coordinates {\n                    row: 5 * (i + j) as i32,\n                    col: 3,\n                };\n                evaluate_node(\n                    \u0026mut grid,\n                    Coordinates {\n                        row: i as i32,\n                        col: j as i32,\n                    },\n                );\n            }\n        }\n\n        grid[1][3].op = Operation::Min;\n        grid[1][3].value1 = a1;\n        grid[1][3].value2 = b2;\n\n        evaluate_node(\u0026mut grid, d1);\n\n        assert!(grid[1][3].valid);\n    }\n    #[test]\n    fn test_evaluate_node_max_range() {\n        let mut grid = generate_grid(3, 3);\n        let a1 = Coordinates { row: 1, col: 1 };\n        let b2 = Coordinates { row: 2, col: 2 };\n        let d1 = Coordinates { row: 1, col: 3 };\n\n        // Fill A1:B2 with constants\n        for i in 1..=2 {\n            for j in 1..=2 {\n                grid[i][j].op = Operation::Cons;\n                grid[i][j].value1 = Coordinates {\n                    row: 5 * (i + j) as i32,\n                    col: -1,\n                };\n                evaluate_node(\n                    \u0026mut grid,\n                    Coordinates {\n                        row: i as i32,\n                        col: j as i32,\n                    },\n                );\n            }\n        }\n\n        grid[1][3].op = Operation::Max;\n        grid[1][3].value1 = a1;\n        grid[1][3].value2 = b2;\n\n        evaluate_node(\u0026mut grid, d1);\n\n        assert!(grid[1][3].valid);\n    }\n    #[test]\n    fn test_evaluate_node_avg_range() {\n        let mut grid = generate_grid(3, 3);\n        let a1 = Coordinates { row: 1, col: 1 };\n        let b2 = Coordinates { row: 2, col: 2 };\n        let d1 = Coordinates { row: 1, col: 3 };\n\n        // Fill A1:B2 with constants\n        for i in 1..=2 {\n            for j in 1..=2 {\n                grid[i][j].op = Operation::Cons;\n                grid[i][j].value1 = Coordinates {\n                    row: 5 * (i + j) as i32,\n                    col: -1,\n                };\n                evaluate_node(\n                    \u0026mut grid,\n                    Coordinates {\n                        row: i as i32,\n                        col: j as i32,\n                    },\n                );\n            }\n        }\n\n        grid[1][3].op = Operation::Avg;\n        grid[1][3].value1 = a1;\n        grid[1][3].value2 = b2;\n\n        evaluate_node(\u0026mut grid, d1);\n\n        assert!(grid[1][3].valid);\n    }\n    #[test]\n    fn test_evaluate_node_sum_range() {\n        let mut grid = generate_grid(3, 3);\n        let a1 = Coordinates { row: 1, col: 1 };\n        let b2 = Coordinates { row: 2, col: 2 };\n        let d1 = Coordinates { row: 1, col: 3 };\n\n        // Fill A1:B2 with constants\n        for i in 1..=2 {\n            for j in 1..=2 {\n                grid[i][j].op = Operation::Cons;\n                grid[i][j].value1 = Coordinates {\n                    row: 5 * (i + j) as i32,\n                    col: -1,\n                };\n                evaluate_node(\n                    \u0026mut grid,\n                    Coordinates {\n                        row: i as i32,\n                        col: j as i32,\n                    },\n                );\n            }\n        }\n\n        grid[1][3].op = Operation::Sum;\n        grid[1][3].value1 = a1;\n        grid[1][3].value2 = b2;\n\n        evaluate_node(\u0026mut grid, d1);\n\n        assert!(grid[1][3].valid);\n    }\n    #[test]\n    fn test_add_and_break_edges_old_dependencies() {\n        let mut grid = generate_grid(3, 3);\n        let a1 = Coordinates { row: 1, col: 1 };\n        let b1 = Coordinates { row: 1, col: 2 };\n        let c1 = Coordinates { row: 1, col: 3 };\n\n        // Initial: C1 = A1 + B1\n        getting_things_updated(\u0026mut grid, c1, a1, b1, Operation::Add);\n\n        // Update C1 = A1 - B1 (this should break previous edges using old values)\n        getting_things_updated(\u0026mut grid, c1, a1, b1, Operation::Sub);\n\n        // C1 should still be dependent on A1 and B1 (new op)\n        assert!(grid[1][1].dependents.contains(\u0026c1));\n        assert!(grid[1][2].dependents.contains(\u0026c1));\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","yuvikachaudhary","Desktop","Semester 4","COP290","spreadsheet_rust","tests","common_ext.rs"],"content":"use project::extension::common::*;\n\n#[test]\npub fn tesst() {\n    let mut val = Value::Const(5);\n    let my_val = val.row();\n    assert_eq!(my_val, 0);\n    let my_val = val.col();\n    assert_eq!(my_val, 0);\n    let mut my_val = val.assign_row(2);\n    assert_eq!(my_val, ());\n    let mut my_val = val.assign_col(3);\n    assert_eq!(my_val, ());\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","yuvikachaudhary","Desktop","Semester 4","COP290","spreadsheet_rust","tests","frontend_ext.rs"],"content":"use project::extension::backend::backend::*;\n#[allow(unused_imports)]\nuse project::extension::common::{Operation, Value};\nuse project::extension::frontend::terminal::*;\n\n#[cfg(test)]\nmod frontend_tests {\n    use super::*;\n\n    #[test]\n    fn test_column_decoder() {\n        // Test basic column conversions\n        assert_eq!(column_decoder(1), \"A\");\n        assert_eq!(column_decoder(2), \"B\");\n        assert_eq!(column_decoder(26), \"Z\");\n        assert_eq!(column_decoder(27), \"AA\");\n        assert_eq!(column_decoder(28), \"AB\");\n        assert_eq!(column_decoder(52), \"AZ\");\n        assert_eq!(column_decoder(53), \"BA\");\n        assert_eq!(column_decoder(702), \"ZZ\");\n        assert_eq!(column_decoder(703), \"AAA\");\n    }\n\n    #[test]\n    fn test_frontend_initialization() {\n        // Test initialization with empty path\n        let frontend = Frontend::init_frontend(10, 20, \"\");\n\n        // Check that default values are set correctly\n        assert_eq!(frontend.start, Value::Cell(1, 1));\n        assert_eq!(frontend.dimension, Value::Cell(10, 20));\n        assert_eq!(frontend.print_enabled, true);\n\n        // Check that backend was initialized with correct dimensions\n        assert_eq!(frontend.backend.grid.get_row_size(), 11); // +1 because backend adds 1\n        assert_eq!(frontend.backend.grid.get_column_size(), 21); // +1 because backend adds 1\n\n        // Test initialization with a path (this would require creating a test file first)\n        // This part is more complex and might need mocking, so we'll skip it for now\n    }\n    #[test]\n    fn test_frontend_from_file() {\n        // Test initialization with empty path\n        let frontend = Frontend::init_frontend(11, 11, \"gradient.json\");\n\n        // Check that default values are set correctly\n        assert_eq!(frontend.start, Value::Cell(1, 1));\n        assert_eq!(frontend.dimension, Value::Cell(10, 10));\n        assert_eq!(frontend.print_enabled, true);\n\n        // Check that backend was initialized with correct dimensions\n        assert_eq!(frontend.backend.grid.get_row_size(), 11); // +1 because backend adds 1\n        assert_eq!(frontend.backend.grid.get_column_size(), 11); // +1 because backend adds 1\n\n        // Test initialization with a path (this would require creating a test file first)\n        // This part is more complex and might need mocking, so we'll skip it for now\n    }\n\n    #[test]\n    fn test_execute_status() {\n        // Test navigation commands\n        let mut frontend = Frontend::init_frontend(100, 100, \"\");\n\n        // Test Left command\n        frontend.start = Value::Cell(50, 50);\n        frontend.execute_status(\u0026Status::Left);\n        assert_eq!(frontend.start, Value::Cell(50, 40));\n\n        // Test extreme Left (should stop at 1)\n        frontend.start = Value::Cell(50, 5);\n        frontend.execute_status(\u0026Status::Left);\n        assert_eq!(frontend.start, Value::Cell(50, 1));\n\n        // Test Right command\n        frontend.start = Value::Cell(50, 50);\n        frontend.execute_status(\u0026Status::Right);\n        assert_eq!(frontend.start, Value::Cell(50, 60));\n\n        // Test extreme Right (should stop at dimension-9)\n        frontend.start = Value::Cell(50, 95);\n        frontend.execute_status(\u0026Status::Right);\n        assert_eq!(frontend.start, Value::Cell(50, 91)); // dimension.col() - 9\n\n        // Test Up command\n        frontend.start = Value::Cell(50, 50);\n        frontend.execute_status(\u0026Status::Up);\n        assert_eq!(frontend.start, Value::Cell(40, 50));\n\n        // Test extreme Up (should stop at 1)\n        frontend.start = Value::Cell(5, 50);\n        frontend.execute_status(\u0026Status::Up);\n        assert_eq!(frontend.start, Value::Cell(1, 50));\n\n        // Test Down command\n        frontend.start = Value::Cell(50, 50);\n        frontend.execute_status(\u0026Status::Down);\n        assert_eq!(frontend.start, Value::Cell(60, 50));\n\n        // Test extreme Down (should stop at dimension-9)\n        frontend.start = Value::Cell(95, 50);\n        frontend.execute_status(\u0026Status::Down);\n        assert_eq!(frontend.start, Value::Cell(91, 50)); // dimension.row() - 9\n\n        // Test PrintDisabled command\n        frontend.execute_status(\u0026Status::PrintDisabled);\n        assert_eq!(frontend.print_enabled, false);\n\n        // Test PrintEnabled command\n        frontend.execute_status(\u0026Status::PrintEnabled);\n        assert_eq!(frontend.print_enabled, true);\n\n        // Test ScrollTo command\n        frontend.execute_status(\u0026Status::ScrollTo(25, 35));\n        assert_eq!(frontend.start, Value::Cell(25, 35));\n    }\n\n    #[test]\n    fn test_print_grid_enabled() {\n        let mut frontend = Frontend::init_frontend(10, 10, \"\");\n\n        // Directly access and modify grid nodes through public field\n        frontend.backend.grid.cells_vec[1][1].node_value = 100;\n        frontend.backend.grid.cells_vec[1][1].valid = true;\n\n        frontend.backend.grid.cells_vec[2][2].node_value = 42; // For text display test\n        frontend.backend.grid.cells_vec[2][2].valid = true;\n\n        // Ensure print is enabled\n        frontend.print_enabled = true;\n\n        // Capture stdout to verify output\n        let mut output = Vec::new();\n        {\n            use std::io::Write;\n            frontend.print_grid();\n            writeln!(output, \"Output captured\").unwrap();\n        }\n\n        // Verify that something was written\n        assert!(!output.is_empty());\n    }\n    #[test]\n    fn test_print_grid_err() {\n        let mut frontend = Frontend::init_frontend(10, 10, \"\");\n\n        // Directly access and modify grid nodes through public field\n        frontend.backend.grid.cells_vec[1][1].node_value = 100;\n        frontend.backend.grid.cells_vec[1][1].valid = false;\n\n        frontend.backend.grid.cells_vec[2][2].node_value = 42; // For text display test\n        frontend.backend.grid.cells_vec[2][2].valid = false;\n\n        // Ensure print is enabled\n        frontend.print_enabled = true;\n\n        // Capture stdout to verify output\n        let mut output = Vec::new();\n        {\n            use std::io::Write;\n            frontend.print_grid();\n            writeln!(output, \"Output captured\").unwrap();\n        }\n\n        // Verify that something was written\n        assert!(!output.is_empty());\n    }\n\n    #[test]\n    fn test_print_grid_disabled() {\n        let mut frontend = Frontend::init_frontend(10, 10, \"\");\n\n        // Set up some test data directly\n        frontend.backend.grid.cells_vec[1][1].node_value = 100;\n        frontend.backend.grid.cells_vec[1][1].valid = true;\n\n        // Disable printing\n        frontend.print_enabled = false;\n\n        // With print_enabled set to false, print_grid should return early\n        frontend.print_grid();\n\n        // If we reach here without errors, the test passes\n        assert!(!frontend.print_enabled);\n    }\n\n    #[test]\n    fn test_display() {\n        let mut frontend = Frontend::init_frontend(10, 10, \"\");\n\n        // Set up a test cell\n        frontend.backend.grid.cells_vec[1][1].node_value = 100;\n        frontend.backend.grid.cells_vec[1][1].valid = true;\n        // Capture stdout to verify output\n        let mut output = Vec::new();\n        {\n            use std::io::{Write, stdout};\n            let _stdout_backup = stdout();\n            // Note: In a real test, you'd use a crate like `rexpect` or set up\n            // proper stdout capturing, but this is simplified\n            frontend.display(Status::Success, 0.5);\n            writeln!(output, \"Output captured\").unwrap();\n        }\n        {\n            use std::io::{Write, stdout};\n            let _stdout_backup = stdout();\n            // Note: In a real test, you'd use a crate like `rexpect` or set up\n            // proper stdout capturing, but this is simplified\n            frontend.display(Status::UnrecognizedCmd, 0.5);\n            writeln!(output, \"Output captured\").unwrap();\n        }\n        {\n            use std::io::{Write, stdout};\n            let _stdout_backup = stdout();\n            // Note: In a real test, you'd use a crate like `rexpect` or set up\n            // proper stdout capturing, but this is simplified\n            frontend.display(Status::CircularDependency, 0.5);\n            writeln!(output, \"Output captured\").unwrap();\n        }\n        {\n            use std::io::{Write, stdout};\n            let _stdout_backup = stdout();\n            // Note: In a real test, you'd use a crate like `rexpect` or set up\n            // proper stdout capturing, but this is simplified\n            frontend.display(Status::PrintEnabled, 0.5);\n            writeln!(output, \"Output captured\").unwrap();\n        }\n        {\n            use std::io::{Write, stdout};\n            let _stdout_backup = stdout();\n            // Note: In a real test, you'd use a crate like `rexpect` or set up\n            // proper stdout capturing, but this is simplified\n            frontend.display(Status::PrintDisabled, 0.5);\n            writeln!(output, \"Output captured\").unwrap();\n        }\n        {\n            use std::io::{Write, stdout};\n            let _stdout_backup = stdout();\n            // Note: In a real test, you'd use a crate like `rexpect` or set up\n            // proper stdout capturing, but this is simplified\n            frontend.display(Status::Up, 0.5);\n            writeln!(output, \"Output captured\").unwrap();\n        }\n        {\n            use std::io::{Write, stdout};\n            let _stdout_backup = stdout();\n            // Note: In a real test, you'd use a crate like `rexpect` or set up\n            // proper stdout capturing, but this is simplified\n            frontend.display(Status::Down, 0.5);\n            writeln!(output, \"Output captured\").unwrap();\n        }\n        {\n            use std::io::{Write, stdout};\n            let _stdout_backup = stdout();\n            // Note: In a real test, you'd use a crate like `rexpect` or set up\n            // proper stdout capturing, but this is simplified\n            frontend.display(Status::Left, 0.5);\n            writeln!(output, \"Output captured\").unwrap();\n        }\n        {\n            use std::io::{Write, stdout};\n            let _stdout_backup = stdout();\n            // Note: In a real test, you'd use a crate like `rexpect` or set up\n            // proper stdout capturing, but this is simplified\n            frontend.display(Status::Right, 0.5);\n            writeln!(output, \"Output captured\").unwrap();\n        }\n        {\n            use std::io::{Write, stdout};\n            let _stdout_backup = stdout();\n            // Note: In a real test, you'd use a crate like `rexpect` or set up\n            // proper stdout capturing, but this is simplified\n            frontend.display(Status::ScrollTo(5, 5), 0.5);\n            writeln!(output, \"Output captured\").unwrap();\n        }\n\n        // Verify output contains expected elements\n        // This is just a basic test; actual implementation would need proper stdout capture\n        assert!(!output.is_empty());\n    }\n\n    #[test]\n    fn test_invalid_location_dimension() {\n        // Test handling of invalid location/dimension values\n        let mut frontend = Frontend::init_frontend(10, 10, \"\");\n\n        // Set invalid values that don't match the Cell pattern\n        frontend.start = Value::Const(42); // Using Const instead of Number\n        frontend.dimension = Value::Oper(None, None, Operation::Quit); // Using Oper instead of Text\n\n        // This should not panic, but handle the error gracefully\n        frontend.print_grid();\n\n        // If we reach here without errors, the test passes\n        assert!(frontend.print_enabled); // Check some state was maintained\n    }\n\n    #[test]\n    fn test_column_decoder_edge_cases() {\n        // Test edge cases for column decoder\n        assert_eq!(column_decoder(0), \"\"); // What should happen with 0?\n        assert_eq!(column_decoder(1000), \"ALL\"); // Very large column numbers\n        assert_eq!(column_decoder(18278), \"ZZZ\"); // Test triple-letter columns\n    }\n\n    #[test]\n    fn test_command_processing() {\n        let mut frontend = Frontend::init_frontend(10, 10, \"\");\n\n        // Test that commands are properly passed to backend\n        // You might need to mock backend.process_command to verify this\n\n        // For example:\n        let _command = \"A1 = 100\";\n        // Call a method that would trigger process_command\n        // Then verify backend state changed appropriately\n\n        // Or test navigation commands:\n        frontend.start = Value::Cell(50, 50);\n        frontend.execute_status(\u0026Status::ScrollTo(25, 30));\n        assert_eq!(frontend.start, Value::Cell(25, 30));\n    }\n\n    #[test]\n    fn test_dimension_boundaries() {\n        let mut frontend = Frontend::init_frontend(200, 200, \"\");\n\n        // Test that print_grid correctly handles cells at boundaries\n        frontend.start = Value::Cell(1, 1);\n        frontend.print_grid(); // Should show cells 1,1 through 9,9\n\n        // Test scrolling beyond grid boundaries\n        frontend.execute_status(\u0026Status::ScrollTo(100, 100));\n        // Verify it doesn't go beyond actual dimensions\n        assert_eq!(frontend.start.row(), 100);\n        assert_eq!(frontend.start.col(), 100);\n    }\n\n    #[test]\n    fn test_print_grid_formatting() {\n        let mut frontend = Frontend::init_frontend(10, 10, \"\");\n\n        // Set up a variety of cell values to test formatting\n        frontend.backend.grid.cells_vec[1][1].node_value = 12345; // Large number\n        frontend.backend.grid.cells_vec[1][1].valid = true;\n\n        frontend.backend.grid.cells_vec[2][2].node_value = -42; // Negative number\n        frontend.backend.grid.cells_vec[2][2].valid = true;\n\n        frontend.backend.grid.cells_vec[3][3].node_value = 0; // Zero\n        frontend.backend.grid.cells_vec[3][3].valid = true;\n\n        // In a real test, capture and verify stdout formatting\n        frontend.print_grid();\n        // Assert that formatting is correct (would need proper stdout capture)\n    }\n\n    #[test]\n    fn test_execute_status_chain() {\n        let mut frontend = Frontend::init_frontend(100, 100, \"\");\n\n        // Test complex sequence of status commands\n        frontend.start = Value::Cell(50, 50);\n\n        // Chain of navigation commands\n        frontend.execute_status(\u0026Status::Up); // Should go to row 40\n        frontend.execute_status(\u0026Status::Left); // Should go to col 40\n        frontend.execute_status(\u0026Status::Down); // Should go to row 50\n        frontend.execute_status(\u0026Status::Right); // Should go to col 50\n\n        // Verify final position after chain\n        assert_eq!(frontend.start, Value::Cell(50, 50));\n\n        // Test disable -\u003e enable print\n        frontend.execute_status(\u0026Status::PrintDisabled);\n        assert_eq!(frontend.print_enabled, false);\n        frontend.execute_status(\u0026Status::PrintEnabled);\n        assert_eq!(frontend.print_enabled, true);\n    }\n\n    // Note: run_counter and display are harder to test in isolation\n    // as they deal with stdin/stdout and would require more complex mocking\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","yuvikachaudhary","Desktop","Semester 4","COP290","spreadsheet_rust","tests","functions_ext.rs"],"content":"use project::extension::backend::backend::*;\nuse project::extension::backend::functions::*;\nuse project::extension::backend::graph::*;\n#[allow(unused_imports)]\nuse project::extension::common::{Operation, Value};\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn setup_test_grid(rows: usize, cols: usize) -\u003e Grid {\n        let mut grid = Grid::new(rows, cols);\n        // Initialize grid with default values\n        for i in 0..rows {\n            for j in 0..cols {\n                let node = Node::new(i as isize * cols as isize + j as isize);\n                grid.set_node(i, j, node);\n            }\n        }\n        grid\n    }\n\n    fn setup_grid_with_range_operation(rows: usize, cols: usize, oper: Operation) -\u003e Grid {\n        let mut grid = setup_test_grid(rows, cols);\n\n        // Set up a cell with a range operation\n        let mut function_node = Node::new(0);\n        function_node.function = Some(Value::Oper(\n            Some(Box::new(Value::Cell(0, 0))),\n            Some(Box::new(Value::Cell(2, 2))),\n            oper,\n        ));\n        grid.set_node(3, 3, function_node);\n\n        grid\n    }\n\n    fn setup_grid_with_binary_operation(rows: usize, cols: usize, oper: Operation) -\u003e Grid {\n        let mut grid = setup_test_grid(rows, cols);\n\n        // Set up a cell with a binary operation\n        let mut function_node = Node::new(0);\n        function_node.function = Some(Value::Oper(\n            Some(Box::new(Value::Cell(1, 1))),\n            Some(Box::new(Value::Cell(2, 2))),\n            oper,\n        ));\n        grid.set_node(3, 3, function_node);\n\n        grid\n    }\n\n    fn setup_grid_with_const_operation(rows: usize, cols: usize, oper: Operation) -\u003e Grid {\n        let mut grid = setup_test_grid(rows, cols);\n\n        // Set up a cell with a binary operation using constants\n        let mut function_node = Node::new(0);\n        function_node.function = Some(Value::Oper(\n            Some(Box::new(Value::Const(10))),\n            Some(Box::new(Value::Const(5))),\n            oper,\n        ));\n        grid.set_node(3, 3, function_node);\n\n        grid\n    }\n\n    fn setup_grid_with_mixed_operation(rows: usize, cols: usize, oper: Operation) -\u003e Grid {\n        let mut grid = setup_test_grid(rows, cols);\n\n        // Set up a cell with a binary operation using both cell and constant\n        let mut function_node = Node::new(0);\n        function_node.function = Some(Value::Oper(\n            Some(Box::new(Value::Cell(1, 1))),\n            Some(Box::new(Value::Const(5))),\n            oper,\n        ));\n        grid.set_node(3, 3, function_node);\n\n        grid\n    }\n\n    fn setup_invalid_grid_in_range(rows: usize, cols: usize, oper: Operation) -\u003e Grid {\n        let mut grid = setup_test_grid(rows, cols);\n\n        // Set up a cell with a range operation\n        let mut function_node = Node::new(0);\n        function_node.function = Some(Value::Oper(\n            Some(Box::new(Value::Cell(0, 0))),\n            Some(Box::new(Value::Cell(2, 2))),\n            oper,\n        ));\n        grid.set_node(3, 3, function_node);\n\n        // Make one cell in the range invalid\n        let invalid_node = grid.get_node(1, 1);\n        invalid_node.valid = false;\n\n        grid\n    }\n\n    #[test]\n    fn test_max_function_normal() {\n        let mut grid = setup_grid_with_range_operation(5, 5, Operation::Max);\n\n        // In a 3x3 grid (0,0 to 2,2), the max value would be at (2,2) = 2*5+2 = 12\n        let result = max_function(\u0026mut grid, 3, 3);\n        assert_eq!(result, Some(12));\n    }\n\n    #[test]\n    fn test_max_function_empty_range() {\n        let mut grid = setup_test_grid(5, 5);\n\n        // Set up a cell with a range operation for an empty range\n        let mut function_node = Node::new(0);\n        function_node.function = Some(Value::Oper(\n            Some(Box::new(Value::Cell(2, 2))),\n            Some(Box::new(Value::Cell(1, 1))),\n            Operation::Max,\n        ));\n        grid.set_node(3, 3, function_node);\n\n        // For an empty range (since end \u003c start), should return None\n        let result = max_function(\u0026mut grid, 3, 3);\n        assert_eq!(result, Some(isize::MIN));\n    }\n\n    #[test]\n    fn test_max_function_invalid_cell() {\n        let mut grid = setup_invalid_grid_in_range(5, 5, Operation::Max);\n\n        // If there's an invalid cell in the range, should return None\n        let result = max_function(\u0026mut grid, 3, 3);\n        assert_eq!(result, None);\n    }\n\n    #[test]\n    fn test_max_function_invalid_function() {\n        let mut grid = setup_test_grid(5, 5);\n\n        // Set up a cell with an invalid function structure\n        let mut function_node = Node::new(0);\n        function_node.function = Some(Value::Cell(1, 1)); // Not a Value::Oper\n        grid.set_node(3, 3, function_node);\n\n        // With an invalid function structure, max_function would return Some(isize::MIN), not None\n        let result = max_function(\u0026mut grid, 3, 3);\n        assert_eq!(result, Some(isize::MIN));\n    }\n\n    #[test]\n    fn test_min_function_normal() {\n        let mut grid = setup_grid_with_range_operation(5, 5, Operation::Min);\n\n        // In a 3x3 grid (0,0 to 2,2), the min value would be at (0,0) = 0\n        let result = min_function(\u0026mut grid, 3, 3);\n        assert_eq!(result, Some(0));\n    }\n\n    #[test]\n    fn test_min_function_empty_range() {\n        let mut grid = setup_test_grid(5, 5);\n\n        // Set up a cell with a range operation for an empty range\n        let mut function_node = Node::new(0);\n        function_node.function = Some(Value::Oper(\n            Some(Box::new(Value::Cell(2, 2))),\n            Some(Box::new(Value::Cell(1, 1))),\n            Operation::Min,\n        ));\n        grid.set_node(3, 3, function_node);\n\n        // For an empty range (since end \u003c start), should return None\n        let result = min_function(\u0026mut grid, 3, 3);\n        assert_eq!(result, Some(isize::MAX));\n    }\n\n    #[test]\n    fn test_min_function_invalid_cell() {\n        let mut grid = setup_invalid_grid_in_range(5, 5, Operation::Min);\n\n        // If there's an invalid cell in the range, should return None\n        let result = min_function(\u0026mut grid, 3, 3);\n        assert_eq!(result, None);\n    }\n\n    #[test]\n    fn test_sum_function_normal() {\n        let mut grid = setup_grid_with_range_operation(5, 5, Operation::Sum);\n\n        // In a 3x3 grid (0,0 to 2,2), the sum would be 0+1+2+5+6+7+10+11+12 = 54\n        let result = sum_function(\u0026mut grid, 3, 3);\n        assert_eq!(result, Some(54));\n    }\n\n    #[test]\n    fn test_sum_function_empty_range() {\n        let mut grid = setup_test_grid(5, 5);\n\n        // Set up a cell with a range operation for an empty range\n        let mut function_node = Node::new(0);\n        function_node.function = Some(Value::Oper(\n            Some(Box::new(Value::Cell(2, 2))),\n            Some(Box::new(Value::Cell(1, 1))),\n            Operation::Sum,\n        ));\n        grid.set_node(3, 3, function_node);\n\n        // For an empty range (since end \u003c start), should return Some(0)\n        let result = sum_function(\u0026mut grid, 3, 3);\n        assert_eq!(result, Some(0));\n    }\n\n    #[test]\n    fn test_sum_function_invalid_cell() {\n        let mut grid = setup_invalid_grid_in_range(5, 5, Operation::Sum);\n\n        // If there's an invalid cell in the range, should return None\n        let result = sum_function(\u0026mut grid, 3, 3);\n        assert_eq!(result, None);\n    }\n\n    #[test]\n    fn test_avg_function_normal() {\n        let mut grid = setup_grid_with_range_operation(5, 5, Operation::Avg);\n\n        // In a 3x3 grid (0,0 to 2,2), the average would be (0+1+2+5+6+7+10+11+12)/9 = 54/9 = 6\n        let result = avg_function(\u0026mut grid, 3, 3);\n        assert_eq!(result, Some(6));\n    }\n\n    #[test]\n    fn test_avg_function_empty_range() {\n        let mut grid = setup_test_grid(5, 5);\n\n        // Set up a cell with a range operation for an empty range\n        let mut function_node = Node::new(0);\n        function_node.function = Some(Value::Oper(\n            Some(Box::new(Value::Cell(2, 2))),\n            Some(Box::new(Value::Cell(1, 1))),\n            Operation::Avg,\n        ));\n        grid.set_node(3, 3, function_node);\n\n        // For an empty range (since end \u003c start), should return None\n        let result = avg_function(\u0026mut grid, 3, 3);\n        assert_eq!(result, None);\n    }\n\n    #[test]\n    fn test_avg_function_invalid_cell() {\n        let mut grid = setup_invalid_grid_in_range(5, 5, Operation::Avg);\n\n        // If there's an invalid cell in the range, should return None\n        let result = avg_function(\u0026mut grid, 3, 3);\n        assert_eq!(result, None);\n    }\n\n    #[test]\n    fn test_std_dev_function_normal() {\n        let mut grid = setup_grid_with_range_operation(5, 5, Operation::Std);\n\n        // In a 3x3 grid (0,0 to 2,2), values are 0,1,2,5,6,7,10,11,12\n        // Mean is 6, variance is (6-0)²+(6-1)²+(6-2)²+(6-5)²+(6-6)²+(6-7)²+(6-10)²+(6-11)²+(6-12)² = 36+25+16+1+0+1+16+25+36 = 156\n        // StdDev is sqrt(156/9) = sqrt(17.333) ≈ 4.16 rounded to 4\n        let result = std_dev_function(\u0026mut grid, 3, 3);\n        assert_eq!(result, Some(4));\n    }\n\n    #[test]\n    fn test_std_dev_function_empty_range() {\n        let mut grid = setup_test_grid(5, 5);\n\n        // Set up a cell with a range operation for an empty range\n        let mut function_node = Node::new(0);\n        function_node.function = Some(Value::Oper(\n            Some(Box::new(Value::Cell(2, 2))),\n            Some(Box::new(Value::Cell(1, 1))),\n            Operation::Std,\n        ));\n        grid.set_node(3, 3, function_node);\n\n        // For an empty range (since end \u003c start), should return Some(0)\n        let result = std_dev_function(\u0026mut grid, 3, 3);\n        assert_eq!(result, Some(0));\n    }\n\n    #[test]\n    fn test_std_dev_function_invalid_cell() {\n        let mut grid = setup_invalid_grid_in_range(5, 5, Operation::Std);\n\n        // If there's an invalid cell in the range, should return None\n        let result = std_dev_function(\u0026mut grid, 3, 3);\n        assert_eq!(result, None);\n    }\n\n    #[test]\n    fn test_add_normal() {\n        let mut grid = setup_grid_with_binary_operation(5, 5, Operation::Add);\n\n        // Adding cell(1,1) = 6 and cell(2,2) = 12\n        let result = add(\u0026mut grid, 3, 3);\n        assert_eq!(result, Some(18));\n    }\n\n    #[test]\n    fn test_add_with_const() {\n        let mut grid = setup_grid_with_const_operation(5, 5, Operation::Add);\n\n        // Adding constants 10 + 5\n        let result = add(\u0026mut grid, 3, 3);\n        assert_eq!(result, Some(15));\n    }\n\n    #[test]\n    fn test_add_with_mixed() {\n        let mut grid = setup_grid_with_mixed_operation(5, 5, Operation::Add);\n\n        // Adding cell(1,1) = 6 and const 5\n        let result = add(\u0026mut grid, 3, 3);\n        assert_eq!(result, Some(11));\n    }\n\n    #[test]\n    fn test_add_invalid_cell() {\n        let mut grid = setup_grid_with_binary_operation(5, 5, Operation::Add);\n\n        // Make one of the cells invalid\n        let invalid_node = grid.get_node(1, 1);\n        invalid_node.valid = false;\n\n        // Should return None if one of the cells is invalid\n        let result = add(\u0026mut grid, 3, 3);\n        assert_eq!(result, None);\n    }\n\n    #[test]\n    fn test_add_invalid_function() {\n        let mut grid = setup_test_grid(5, 5);\n\n        // Set up a cell with an invalid function structure\n        let mut function_node = Node::new(0);\n        function_node.function = Some(Value::Cell(1, 1));\n        grid.set_node(3, 3, function_node);\n\n        // With an invalid function structure, should return None\n        let result = add(\u0026mut grid, 3, 3);\n        assert_eq!(result, None);\n    }\n\n    #[test]\n    fn test_sub_normal() {\n        let mut grid = setup_grid_with_binary_operation(5, 5, Operation::Sub);\n\n        // Subtracting cell(2,2) = 12 from cell(1,1) = 6\n        // The correct result is -6, not 6, as the subtraction appears to be first - second\n        let result = sub(\u0026mut grid, 3, 3);\n        assert_eq!(result, Some(-6));\n    }\n\n    #[test]\n    fn test_sub_with_const() {\n        let mut grid = setup_grid_with_const_operation(5, 5, Operation::Sub);\n\n        // Subtracting constants 10 - 5\n        let result = sub(\u0026mut grid, 3, 3);\n        assert_eq!(result, Some(5));\n    }\n\n    #[test]\n    fn test_sub_with_mixed() {\n        let mut grid = setup_grid_with_mixed_operation(5, 5, Operation::Sub);\n\n        // Subtracting cell(1,1) = 6 and const 5\n        let result = sub(\u0026mut grid, 3, 3);\n        assert_eq!(result, Some(1));\n    }\n\n    #[test]\n    fn test_sub_invalid_cell() {\n        let mut grid = setup_grid_with_binary_operation(5, 5, Operation::Sub);\n\n        // Make one of the cells invalid\n        let invalid_node = grid.get_node(2, 2);\n        invalid_node.valid = false;\n\n        // Should return None if one of the cells is invalid\n        let result = sub(\u0026mut grid, 3, 3);\n        assert_eq!(result, None);\n    }\n\n    #[test]\n    fn test_mul_normal() {\n        let mut grid = setup_grid_with_binary_operation(5, 5, Operation::Mul);\n\n        // Multiplying cell(1,1) = 6 and cell(2,2) = 12\n        let result = mul(\u0026mut grid, 3, 3);\n        assert_eq!(result, Some(72));\n    }\n\n    #[test]\n    fn test_mul_with_const() {\n        let mut grid = setup_grid_with_const_operation(5, 5, Operation::Mul);\n\n        // Multiplying constants 10 * 5\n        let result = mul(\u0026mut grid, 3, 3);\n        assert_eq!(result, Some(50));\n    }\n\n    #[test]\n    fn test_mul_with_mixed() {\n        let mut grid = setup_grid_with_mixed_operation(5, 5, Operation::Mul);\n\n        // Multiplying cell(1,1) = 6 and const 5\n        let result = mul(\u0026mut grid, 3, 3);\n        assert_eq!(result, Some(30));\n    }\n\n    #[test]\n    fn test_mul_invalid_cell() {\n        let mut grid = setup_grid_with_binary_operation(5, 5, Operation::Mul);\n\n        // Make one of the cells invalid\n        let invalid_node = grid.get_node(1, 1);\n        invalid_node.valid = false;\n\n        // Should return None if one of the cells is invalid\n        let result = mul(\u0026mut grid, 3, 3);\n        assert_eq!(result, None);\n    }\n\n    #[test]\n    fn test_div_normal() {\n        let mut grid = setup_grid_with_binary_operation(5, 5, Operation::Div);\n\n        // Dividing cell(1,1) = 6 by cell(2,2) = 12\n        let result = div(\u0026mut grid, 3, 3);\n        assert_eq!(result, Some(0)); // Integer division\n    }\n\n    #[test]\n    fn test_div_with_const() {\n        let mut grid = setup_grid_with_const_operation(5, 5, Operation::Div);\n\n        // Dividing constants 10 / 5\n        let result = div(\u0026mut grid, 3, 3);\n        assert_eq!(result, Some(2));\n    }\n\n    #[test]\n    fn test_div_with_mixed() {\n        let mut grid = setup_grid_with_mixed_operation(5, 5, Operation::Div);\n\n        // Dividing cell(1,1) = 6 by const 5\n        let result = div(\u0026mut grid, 3, 3);\n        assert_eq!(result, Some(1)); // Integer division\n    }\n\n    #[test]\n    fn test_div_by_zero() {\n        let mut grid = setup_test_grid(5, 5);\n\n        // Set up a cell to divide by zero\n        let mut function_node = Node::new(0);\n        function_node.function = Some(Value::Oper(\n            Some(Box::new(Value::Cell(1, 1))),\n            Some(Box::new(Value::Const(0))),\n            Operation::Div,\n        ));\n        grid.set_node(3, 3, function_node);\n\n        // Should return None for division by zero\n        let result = div(\u0026mut grid, 3, 3);\n        assert_eq!(result, None);\n    }\n\n    #[test]\n    fn test_div_invalid_cell() {\n        let mut grid = setup_grid_with_binary_operation(5, 5, Operation::Div);\n\n        // Make one of the cells invalid\n        let invalid_node = grid.get_node(2, 2);\n        invalid_node.valid = false;\n\n        // Should return None if one of the cells is invalid\n        let result = div(\u0026mut grid, 3, 3);\n        assert_eq!(result, None);\n    }\n\n    #[test]\n    fn test_slp_normal() {\n        let mut grid = setup_test_grid(5, 5);\n\n        // Set up a cell with a sleep operation\n        let mut function_node = Node::new(0);\n        function_node.function = Some(Value::Oper(\n            Some(Box::new(Value::Const(0))), // Sleep for 0 seconds for test speed\n            Some(Box::new(Value::Const(0))),\n            Operation::Slp,\n        ));\n        grid.set_node(3, 3, function_node);\n\n        // Should return the sleep time\n        let result = slp(\u0026mut grid, 3, 3);\n        assert_eq!(result, Some(0));\n    }\n\n    #[test]\n    fn test_slp_with_cell() {\n        let mut grid = setup_test_grid(5, 5);\n\n        // Set up a cell with a sleep operation\n        let mut function_node = Node::new(0);\n        function_node.function = Some(Value::Oper(\n            Some(Box::new(Value::Cell(0, 0))), // Sleep for value of cell(0,0) = 0\n            Some(Box::new(Value::Const(0))),\n            Operation::Slp,\n        ));\n        grid.set_node(3, 3, function_node);\n\n        // Should return the sleep time\n        let result = slp(\u0026mut grid, 3, 3);\n        assert_eq!(result, Some(0));\n    }\n\n    #[test]\n    fn test_slp_invalid_cell() {\n        let mut grid = setup_test_grid(5, 5);\n\n        // Set up a cell with a sleep operation\n        let mut function_node = Node::new(0);\n        function_node.function = Some(Value::Oper(\n            Some(Box::new(Value::Cell(0, 0))),\n            Some(Box::new(Value::Const(0))),\n            Operation::Slp,\n        ));\n        grid.set_node(3, 3, function_node);\n\n        // Make the cell invalid\n        let invalid_node = grid.get_node(0, 0);\n        invalid_node.valid = false;\n\n        // Should return None if the cell is invalid\n        let result = slp(\u0026mut grid, 3, 3);\n        assert_eq!(result, None);\n    }\n\n    #[test]\n    fn test_cons_normal() {\n        let mut grid = setup_test_grid(5, 5);\n\n        // Set up a cell with a cons operation\n        let mut function_node = Node::new(0);\n        function_node.function = Some(Value::Oper(\n            Some(Box::new(Value::Const(42))),\n            Some(Box::new(Value::Const(0))),\n            Operation::Cons,\n        ));\n        grid.set_node(3, 3, function_node);\n\n        // Should return the constant value\n        let result = cons(\u0026mut grid, 3, 3);\n        assert_eq!(result, Some(42));\n    }\n\n    #[test]\n    fn test_cons_with_cell() {\n        let mut grid = setup_test_grid(5, 5);\n\n        // Set up a cell with a cons operation\n        let mut function_node = Node::new(0);\n        function_node.function = Some(Value::Oper(\n            Some(Box::new(Value::Cell(1, 1))), // Get value of cell(1,1) = 6\n            Some(Box::new(Value::Const(0))),\n            Operation::Cons,\n        ));\n        grid.set_node(3, 3, function_node);\n\n        // Should return the value of the referenced cell\n        let result = cons(\u0026mut grid, 3, 3);\n        assert_eq!(result, Some(6));\n    }\n\n    #[test]\n    fn test_cons_invalid_cell() {\n        let mut grid = setup_test_grid(5, 5);\n\n        // Set up a cell with a cons operation\n        let mut function_node = Node::new(0);\n        function_node.function = Some(Value::Oper(\n            Some(Box::new(Value::Cell(1, 1))),\n            Some(Box::new(Value::Const(0))),\n            Operation::Cons,\n        ));\n        grid.set_node(3, 3, function_node);\n\n        // Make the cell invalid\n        let invalid_node = grid.get_node(1, 1);\n        invalid_node.valid = false;\n\n        // Should return None if the cell is invalid\n        let result = cons(\u0026mut grid, 3, 3);\n        assert_eq!(result, None);\n    }\n\n    #[test]\n    fn test_invalid_function_structures() {\n        let mut grid = setup_test_grid(5, 5);\n\n        // Missing first operand\n        let mut function_node = Node::new(0);\n        function_node.function = Some(Value::Oper(\n            None,\n            Some(Box::new(Value::Const(5))),\n            Operation::Add,\n        ));\n        grid.set_node(3, 3, function_node);\n\n        assert_eq!(add(\u0026mut grid, 3, 3), None);\n\n        // Missing second operand\n        let mut function_node = Node::new(0);\n        function_node.function = Some(Value::Oper(\n            Some(Box::new(Value::Const(5))),\n            None,\n            Operation::Add,\n        ));\n        grid.set_node(3, 3, function_node);\n\n        assert_eq!(add(\u0026mut grid, 3, 3), None);\n\n        // Both operands missing\n        let mut function_node = Node::new(0);\n        function_node.function = Some(Value::Oper(None, None, Operation::Add));\n        grid.set_node(3, 3, function_node);\n\n        assert_eq!(add(\u0026mut grid, 3, 3), None);\n    }\n\n    #[test]\n    fn test_nested_value_types() {\n        let mut grid = setup_test_grid(5, 5);\n\n        // Set up a cell with a nested operation\n        let mut function_node = Node::new(0);\n        function_node.function = Some(Value::Oper(\n            Some(Box::new(Value::Oper(\n                Some(Box::new(Value::Const(5))),\n                Some(Box::new(Value::Const(5))),\n                Operation::Add,\n            ))),\n            Some(Box::new(Value::Const(5))),\n            Operation::Add,\n        ));\n        grid.set_node(3, 3, function_node);\n\n        // Should return None for nested operations\n        assert_eq!(add(\u0026mut grid, 3, 3), None);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","yuvikachaudhary","Desktop","Semester 4","COP290","spreadsheet_rust","tests","functions_terminal.rs"],"content":"use project::terminal::functions::*;\nuse project::terminal::graph::Node;\nuse project::terminal::types::Coordinates;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // Helper function to create a test grid\n    fn setup_test_grid() -\u003e Vec\u003cVec\u003cNode\u003e\u003e {\n        let mut grid = vec![\n            vec![Node::default(); 4], // Row 0 (placeholder)\n            vec![Node::default(); 4], // Row 1\n            vec![Node::default(); 4], // Row 2\n            vec![Node::default(); 4], // Row 3\n        ];\n\n        // Set up node positions\n        for i in 0..4 {\n            for j in 0..4 {\n                grid[i][j].position = Coordinates {\n                    row: i as i32,\n                    col: j as i32,\n                };\n                grid[i][j].valid = true;\n            }\n        }\n\n        // Set some test values\n        // Row 1: [10, 20, 30, 40]\n        // Row 2: [5, 15, 25, 35]\n        // Row 3: [2, 8, 18, 32]\n        grid[1][1].node_value = 10;\n        grid[1][2].node_value = 20;\n        grid[1][3].node_value = 30;\n        grid[2][1].node_value = 5;\n        grid[2][2].node_value = 15;\n        grid[2][3].node_value = 25;\n        grid[3][1].node_value = 2;\n        grid[3][2].node_value = 8;\n        grid[3][3].node_value = 18;\n\n        grid\n    }\n\n    #[test]\n    fn test_sum_function() {\n        let grid = setup_test_grid();\n\n        // Test case 1: Sum of a single cell\n        let result = sum_function(\n            Coordinates { row: 1, col: 1 },\n            Coordinates { row: 1, col: 1 },\n            \u0026grid,\n        );\n        assert_eq!(result, Some(10));\n\n        // Test case 2: Sum of a row\n        let result = sum_function(\n            Coordinates { row: 1, col: 1 },\n            Coordinates { row: 1, col: 3 },\n            \u0026grid,\n        );\n        assert_eq!(result, Some(60)); // 10+20+30\n\n        // Test case 3: Sum of a column\n        let result = sum_function(\n            Coordinates { row: 1, col: 1 },\n            Coordinates { row: 3, col: 1 },\n            \u0026grid,\n        );\n        assert_eq!(result, Some(17)); // 10+5+2\n\n        // Test case 4: Sum of a rectangle\n        let result = sum_function(\n            Coordinates { row: 1, col: 1 },\n            Coordinates { row: 2, col: 2 },\n            \u0026grid,\n        );\n        assert_eq!(result, Some(50)); // 10+20+5+15\n    }\n\n    #[test]\n    fn test_avg_function() {\n        let grid = setup_test_grid();\n\n        // Test case 1: Average of a single cell\n        let result = avg_function(\n            Coordinates { row: 1, col: 1 },\n            Coordinates { row: 1, col: 1 },\n            \u0026grid,\n        );\n        assert_eq!(result, Some(10));\n\n        // Test case 2: Average of a row\n        let result = avg_function(\n            Coordinates { row: 1, col: 1 },\n            Coordinates { row: 1, col: 3 },\n            \u0026grid,\n        );\n        assert_eq!(result, Some(20)); // (10+20+30)/3\n\n        // Test case 3: Average of a rectangle\n        let result = avg_function(\n            Coordinates { row: 1, col: 1 },\n            Coordinates { row: 2, col: 2 },\n            \u0026grid,\n        );\n        assert_eq!(result, Some(12)); // (10+20+5+15)/4 = 50/4 = 12.5 -\u003e 12 (integer division)\n    }\n\n    #[test]\n    fn test_min_function() {\n        let grid = setup_test_grid();\n\n        // Test case 1: Min of a single cell\n        let result = min_function(\n            Coordinates { row: 1, col: 1 },\n            Coordinates { row: 1, col: 1 },\n            \u0026grid,\n        );\n        assert_eq!(result, Some(10));\n\n        // Test case 2: Min of a row\n        let result = min_function(\n            Coordinates { row: 1, col: 1 },\n            Coordinates { row: 1, col: 3 },\n            \u0026grid,\n        );\n        assert_eq!(result, Some(10)); // min(10, 20, 30)\n\n        // Test case 3: Min of a rectangle\n        let result = min_function(\n            Coordinates { row: 1, col: 1 },\n            Coordinates { row: 3, col: 3 },\n            \u0026grid,\n        );\n        assert_eq!(result, Some(2)); // min(10, 20, 30, 5, 15, 25, 2, 8, 18)\n    }\n\n    #[test]\n    fn test_max_function() {\n        let grid = setup_test_grid();\n\n        // Test case 1: Max of a single cell\n        let result = max_function(\n            Coordinates { row: 1, col: 1 },\n            Coordinates { row: 1, col: 1 },\n            \u0026grid,\n        );\n        assert_eq!(result, Some(10));\n\n        // Test case 2: Max of a row\n        let result = max_function(\n            Coordinates { row: 1, col: 1 },\n            Coordinates { row: 1, col: 3 },\n            \u0026grid,\n        );\n        assert_eq!(result, Some(30)); // max(10, 20, 30)\n\n        // Test case 3: Max of a rectangle\n        let result = max_function(\n            Coordinates { row: 1, col: 1 },\n            Coordinates { row: 3, col: 3 },\n            \u0026grid,\n        );\n        assert_eq!(result, Some(30)); // max(10, 20, 30, 5, 15, 25, 2, 8, 18)\n    }\n\n    #[test]\n    fn test_stdev_function() {\n        let grid = setup_test_grid();\n\n        // Test case 1: STDEV of a single cell (should be 0)\n        let result = stdev_function(\n            Coordinates { row: 1, col: 1 },\n            Coordinates { row: 1, col: 1 },\n            \u0026grid,\n        );\n        assert_eq!(result, Some(0));\n\n        // Test case 2: STDEV of a row\n        // Values: 10, 20, 30\n        // Mean: 20\n        // Variance: ((10-20)² + (20-20)² + (30-20)²)/3 = (100 + 0 + 100)/3 = 66.67\n        // STDEV: sqrt(66.67) ≈ 8.16 -\u003e 8 (with integer rounding)\n        let result = stdev_function(\n            Coordinates { row: 1, col: 1 },\n            Coordinates { row: 1, col: 3 },\n            \u0026grid,\n        );\n        assert_eq!(result, Some(8));\n\n        // Test case 3: STDEV of a 2x2 square\n        // Values: 10, 20, 5, 15\n        // Mean: 12.5\n        // Variance: ((10-12.5)² + (20-12.5)² + (5-12.5)² + (15-12.5)²)/4 = 37.5\n        // STDEV: sqrt(37.5) ≈ 6.12 -\u003e 6 (with integer rounding)\n        let result = stdev_function(\n            Coordinates { row: 1, col: 1 },\n            Coordinates { row: 2, col: 2 },\n            \u0026grid,\n        );\n        assert_eq!(result, Some(6));\n    }\n\n    #[test]\n    fn test_invalid_cells() {\n        let mut grid = setup_test_grid();\n\n        // Mark one cell as invalid\n        grid[2][2].valid = false;\n\n        // All range functions should return None if any cell is invalid\n        let coords_start = Coordinates { row: 1, col: 1 };\n        let coords_end = Coordinates { row: 2, col: 2 };\n\n        assert_eq!(sum_function(coords_start, coords_end, \u0026grid), None);\n        assert_eq!(avg_function(coords_start, coords_end, \u0026grid), None);\n        assert_eq!(min_function(coords_start, coords_end, \u0026grid), None);\n        assert_eq!(max_function(coords_start, coords_end, \u0026grid), None);\n        assert_eq!(stdev_function(coords_start, coords_end, \u0026grid), None);\n    }\n\n    #[test]\n    fn test_empty_range() {\n        // Create an empty grid (all cells have 0 value but are valid)\n        let grid = vec![vec![Node::default(); 4]; 4];\n\n        // Calculate average of empty range - should be None as count is 0\n        let result = avg_function(\n            Coordinates { row: 1, col: 1 },\n            Coordinates { row: 0, col: 0 }, // invalid range (end before start)\n            \u0026grid,\n        );\n        assert_eq!(result, None);\n\n        // Sum of empty range should be Some(0)\n        let result = sum_function(\n            Coordinates { row: 1, col: 1 },\n            Coordinates { row: 0, col: 0 }, // invalid range (end before start)\n            \u0026grid,\n        );\n        assert_eq!(result, Some(0));\n    }\n\n    #[test]\n    fn test_is_arithmetic() {\n        assert!(is_arithmetic(Operation::Add));\n        assert!(is_arithmetic(Operation::Sub));\n        assert!(is_arithmetic(Operation::Mul));\n        assert!(is_arithmetic(Operation::Div));\n\n        assert!(!is_arithmetic(Operation::Sum));\n        assert!(!is_arithmetic(Operation::Avg));\n        assert!(!is_arithmetic(Operation::Min));\n        assert!(!is_arithmetic(Operation::Max));\n        assert!(!is_arithmetic(Operation::Std));\n        assert!(!is_arithmetic(Operation::Slp));\n        assert!(!is_arithmetic(Operation::Cons));\n    }\n\n    #[test]\n    fn test_operation_equality() {\n        // Test that operations can be compared correctly\n        assert_eq!(Operation::Add, Operation::Add);\n        assert_ne!(Operation::Add, Operation::Sub);\n        assert_ne!(Operation::Sum, Operation::Avg);\n    }\n\n    #[test]\n    fn test_sum_empty_range() {\n        let grid = setup_test_grid();\n\n        // Test summing 0 cells (empty range)\n        let result = sum_function(\n            Coordinates { row: 3, col: 3 }, // Out of grid bounds\n            Coordinates { row: 3, col: 3 },\n            \u0026grid,\n        );\n        assert_eq!(result, Some(18)); // only that grid cell is present whose value is 18\n    }\n\n    #[test]\n    fn test_stdev_edge_cases() {\n        let _grid = setup_test_grid();\n\n        // Test STDEV of a range with identical values (should be 0)\n        let mut identical_grid = setup_test_grid();\n        for i in 1..3 {\n            for j in 1..3 {\n                identical_grid[i][j].node_value = 10;\n            }\n        }\n\n        let result = stdev_function(\n            Coordinates { row: 1, col: 1 },\n            Coordinates { row: 2, col: 2 },\n            \u0026identical_grid,\n        );\n        assert_eq!(result, Some(0));\n\n        // Test with extreme values that might cause integer overflow\n        let mut extreme_grid = setup_test_grid();\n        extreme_grid[1][1].node_value = i32::MAX / 2;\n        extreme_grid[1][2].node_value = i32::MIN / 2;\n\n        // This test mainly checks that the function doesn't panic\n        let result = stdev_function(\n            Coordinates { row: 1, col: 1 },\n            Coordinates { row: 1, col: 2 },\n            \u0026extreme_grid,\n        );\n        assert!(result.is_some());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","yuvikachaudhary","Desktop","Semester 4","COP290","spreadsheet_rust","tests","graph_ext.rs"],"content":"use project::extension::backend::backend::*;\nuse project::extension::backend::graph::*;\nuse project::extension::common::{Operation, Value};\n\n#[cfg(test)]\nmod node_tests {\n    use super::*;\n\n    // Helper function to create a test grid with predefined size\n    fn create_test_grid(rows: usize, cols: usize) -\u003e Grid {\n        let mut grid = Grid::new(rows + 1, cols + 1);\n        // Initialize with default nodes\n        for r in 1..=rows {\n            for c in 1..=cols {\n                grid.set_node(r, c, Node::new(0));\n            }\n        }\n        grid\n    }\n\n    #[test]\n    fn test_node_new() {\n        let node = Node::new(42);\n        assert_eq!(node.get_node_value(), Some(42));\n        assert!(node.dependents.is_empty());\n        assert_eq!(node.function, None);\n        assert!(!node.visited);\n        assert!(node.valid);\n    }\n\n    #[test]\n    fn test_get_node_value() {\n        // Test valid node\n        let mut node = Node::new(42);\n        assert_eq!(node.get_node_value(), Some(42));\n\n        // Test invalid node\n        node.valid = false;\n        assert_eq!(node.get_node_value(), None);\n    }\n\n    #[test]\n    fn test_remove_dep() {\n        let mut node = Node::new(42);\n        let cell1 = Value::Cell(1, 1);\n        let cell2 = Value::Cell(2, 2);\n\n        // Add dependencies\n        node.dependents.push(cell1.clone());\n        node.dependents.push(cell2.clone());\n        assert_eq!(node.dependents.len(), 2);\n\n        // Remove one dependency\n        node.remove_dep(cell1);\n        assert_eq!(node.dependents.len(), 1);\n        assert_eq!(node.dependents[0], cell2);\n\n        // Try to remove non-existent dependency (should do nothing)\n        node.remove_dep(Value::Cell(3, 3));\n        assert_eq!(node.dependents.len(), 1);\n    }\n\n    #[test]\n    fn test_add_dep() {\n        let mut node = Node::new(42);\n        let cell1 = Value::Cell(1, 1);\n\n        // Add dependency\n        node.add_dep(cell1.clone());\n        assert_eq!(node.dependents.len(), 1);\n        assert_eq!(node.dependents[0], cell1);\n\n        // Try to add same dependency again (should not duplicate)\n        node.add_dep(cell1.clone());\n        assert_eq!(node.dependents.len(), 1);\n\n        // Add another dependency\n        let cell2 = Value::Cell(2, 2);\n        node.add_dep(cell2.clone());\n        assert_eq!(node.dependents.len(), 2);\n        assert!(node.dependents.contains(\u0026cell1));\n        assert!(node.dependents.contains(\u0026cell2));\n    }\n\n    #[test]\n    fn test_set_dependents() {\n        let mut node = Node::new(42);\n\n        // Initial state\n        assert!(node.dependents.is_empty());\n\n        // Set dependencies\n        let deps = vec![Value::Cell(1, 1), Value::Cell(2, 2)];\n        node.set_dependents(deps.clone());\n        assert_eq!(node.dependents, deps);\n\n        // Set to empty\n        node.set_dependents(vec![]);\n        assert!(node.dependents.is_empty());\n    }\n\n    #[test]\n    fn test_break_edges_sum_operation() {\n        let mut grid = create_test_grid(5, 5);\n\n        // Set up a SUM operation: C3 = SUM(A1:B2)\n        let target = Value::Cell(3, 3);\n        let func = Some(Value::Oper(\n            Some(Box::new(Value::Cell(1, 1))),\n            Some(Box::new(Value::Cell(2, 2))),\n            Operation::Sum,\n        ));\n\n        // Add dependencies first\n        add_edges(\u0026mut grid, target.clone(), func.clone(), true);\n\n        // Verify dependencies were added\n        assert!(grid.get_node(1, 1).dependents.contains(\u0026target));\n        assert!(grid.get_node(1, 2).dependents.contains(\u0026target));\n        assert!(grid.get_node(2, 1).dependents.contains(\u0026target));\n        assert!(grid.get_node(2, 2).dependents.contains(\u0026target));\n\n        // Break the edges\n        break_edges(\u0026mut grid, target.clone(), func.clone(), false);\n\n        // Verify dependencies were removed\n        assert!(!grid.get_node(1, 1).dependents.contains(\u0026target));\n        assert!(!grid.get_node(1, 2).dependents.contains(\u0026target));\n        assert!(!grid.get_node(2, 1).dependents.contains(\u0026target));\n        assert!(!grid.get_node(2, 2).dependents.contains(\u0026target));\n    }\n\n    #[test]\n    fn test_break_edges_binary_operation() {\n        let mut grid = create_test_grid(5, 5);\n\n        // Set up a binary operation: C3 = A1 + B2\n        let target = Value::Cell(3, 3);\n        let func = Some(Value::Oper(\n            Some(Box::new(Value::Cell(1, 1))),\n            Some(Box::new(Value::Cell(2, 2))),\n            Operation::Add,\n        ));\n\n        // Add dependencies first\n        add_edges(\u0026mut grid, target.clone(), func.clone(), true);\n\n        // Verify dependencies were added\n        assert!(grid.get_node(1, 1).dependents.contains(\u0026target));\n        assert!(grid.get_node(2, 2).dependents.contains(\u0026target));\n\n        // Break the edges\n        break_edges(\u0026mut grid, target.clone(), func.clone(), false);\n\n        // Verify dependencies were removed\n        assert!(!grid.get_node(1, 1).dependents.contains(\u0026target));\n        assert!(!grid.get_node(2, 2).dependents.contains(\u0026target));\n    }\n\n    #[test]\n    fn test_add_edges_sum_operation() {\n        let mut grid = create_test_grid(5, 5);\n\n        // Set up a SUM operation: C3 = SUM(A1:B2)\n        let target = Value::Cell(3, 3);\n        let func = Some(Value::Oper(\n            Some(Box::new(Value::Cell(1, 1))),\n            Some(Box::new(Value::Cell(2, 2))),\n            Operation::Sum,\n        ));\n\n        // Add the edges\n        add_edges(\u0026mut grid, target.clone(), func.clone(), true);\n\n        // Verify all cells in the range have the target as a dependent\n        assert!(grid.get_node(1, 1).dependents.contains(\u0026target));\n        assert!(grid.get_node(1, 2).dependents.contains(\u0026target));\n        assert!(grid.get_node(2, 1).dependents.contains(\u0026target));\n        assert!(grid.get_node(2, 2).dependents.contains(\u0026target));\n    }\n\n    #[test]\n    fn test_add_edges_binary_operation() {\n        let mut grid = create_test_grid(5, 5);\n\n        // Set up a binary operation: C3 = A1 + B2\n        let target = Value::Cell(3, 3);\n        let func = Some(Value::Oper(\n            Some(Box::new(Value::Cell(1, 1))),\n            Some(Box::new(Value::Cell(2, 2))),\n            Operation::Add,\n        ));\n\n        // Add the edges\n        add_edges(\u0026mut grid, target.clone(), func.clone(), true);\n\n        // Verify both operand cells have the target as a dependent\n        assert!(grid.get_node(1, 1).dependents.contains(\u0026target));\n        assert!(grid.get_node(2, 2).dependents.contains(\u0026target));\n    }\n\n    #[test]\n    fn test_update_edges() {\n        let mut grid = create_test_grid(5, 5);\n\n        // Set up an initial operation: C3 = A1 + B2\n        let target = Value::Cell(3, 3);\n        let func1 = Some(Value::Oper(\n            Some(Box::new(Value::Cell(1, 1))),\n            Some(Box::new(Value::Cell(2, 2))),\n            Operation::Add,\n        ));\n\n        // Store the function in the grid\n        grid.get_node(3, 3).function = func1.clone();\n\n        // Add initial dependencies\n        update_edges(\u0026mut grid, target.clone(), func1.clone(), true);\n\n        // Verify initial dependencies\n        assert!(grid.get_node(1, 1).dependents.contains(\u0026target));\n        assert!(grid.get_node(2, 2).dependents.contains(\u0026target));\n\n        // Change the operation: C3 = D4 * E5\n        let func2 = Some(Value::Oper(\n            Some(Box::new(Value::Cell(4, 4))),\n            Some(Box::new(Value::Cell(5, 5))),\n            Operation::Mul,\n        ));\n\n        // Update the edges with new function\n        update_edges(\u0026mut grid, target.clone(), func2.clone(), true);\n\n        // Verify old dependencies are removed\n        assert!(!grid.get_node(1, 1).dependents.contains(\u0026target));\n        assert!(!grid.get_node(2, 2).dependents.contains(\u0026target));\n\n        // Verify new dependencies are added\n        assert!(grid.get_node(4, 4).dependents.contains(\u0026target));\n        assert!(grid.get_node(5, 5).dependents.contains(\u0026target));\n    }\n\n    #[test]\n    fn test_has_cycle_no_cycle() {\n        let mut grid = create_test_grid(5, 5);\n\n        // Set up a dependency chain: A1 -\u003e B2 -\u003e C3\n        let a1 = Value::Cell(1, 1);\n        let b2 = Value::Cell(2, 2);\n        let c3 = Value::Cell(3, 3);\n\n        grid.get_node(1, 1).add_dep(b2.clone());\n        grid.get_node(2, 2).add_dep(c3.clone());\n\n        // There should be no cycle\n        assert!(!has_cycle(\u0026mut grid, a1.clone()));\n        assert!(!has_cycle(\u0026mut grid, b2.clone()));\n        assert!(!has_cycle(\u0026mut grid, c3.clone()));\n\n        // Verify visited flags were reset\n        assert!(!grid.get_node(1, 1).visited);\n        assert!(!grid.get_node(2, 2).visited);\n        assert!(!grid.get_node(3, 3).visited);\n    }\n\n    #[test]\n    fn test_has_cycle_with_cycle() {\n        let mut grid = create_test_grid(5, 5);\n\n        // Set up a cyclic dependency: A1 -\u003e B2 -\u003e C3 -\u003e A1\n        let a1 = Value::Cell(1, 1);\n        let b2 = Value::Cell(2, 2);\n        let c3 = Value::Cell(3, 3);\n\n        grid.get_node(1, 1).add_dep(b2.clone());\n        grid.get_node(2, 2).add_dep(c3.clone());\n        grid.get_node(3, 3).add_dep(a1.clone());\n\n        // There should be a cycle detected\n        assert!(has_cycle(\u0026mut grid, a1.clone()));\n\n        // Verify visited flags were reset\n        assert!(!grid.get_node(1, 1).visited);\n        assert!(!grid.get_node(2, 2).visited);\n        assert!(!grid.get_node(3, 3).visited);\n    }\n\n    #[test]\n    fn test_reset_visited() {\n        let mut grid = create_test_grid(5, 5);\n\n        // Set up visited flags\n        grid.get_node(1, 1).visited = true;\n        grid.get_node(2, 2).visited = true;\n        grid.get_node(3, 3).visited = true;\n\n        // Set up a dependency chain: A1 -\u003e B2 -\u003e C3\n        let a1 = Value::Cell(1, 1);\n        let b2 = Value::Cell(2, 2);\n        let c3 = Value::Cell(3, 3);\n\n        grid.get_node(1, 1).add_dep(b2.clone());\n        grid.get_node(2, 2).add_dep(c3.clone());\n\n        // Reset visited flags\n        reset_visited(\u0026mut grid, a1.clone());\n\n        // Verify visited flags were reset\n        assert!(!grid.get_node(1, 1).visited);\n        assert!(!grid.get_node(2, 2).visited);\n        assert!(!grid.get_node(3, 3).visited);\n    }\n\n    #[test]\n    fn test_topological_sort() {\n        let mut grid = create_test_grid(5, 5);\n\n        // Set up a dependency chain: A1 -\u003e B2 -\u003e C3\n        let a1 = Value::Cell(1, 1);\n        let b2 = Value::Cell(2, 2);\n        let c3 = Value::Cell(3, 3);\n\n        grid.get_node(1, 1).add_dep(b2.clone());\n        grid.get_node(2, 2).add_dep(c3.clone());\n\n        let mut stack = Vec::new();\n        topological_sort(\u0026mut grid, a1.clone(), \u0026mut stack);\n\n        // The stack should contain a valid topological sort (reverse order of DFS finishing times)\n        // Expected order: [A1, B2, C3]\n        assert_eq!(stack.len(), 3);\n        assert_eq!(stack[2], a1);\n        assert_eq!(stack[1], b2);\n        assert_eq!(stack[0], c3);\n    }\n\n    #[test]\n    fn test_get_sequence() {\n        let mut grid = create_test_grid(5, 5);\n\n        // Set up a dependency graph: A1 -\u003e B2 -\u003e D4, A1 -\u003e C3\n        let a1 = Value::Cell(1, 1);\n        let b2 = Value::Cell(2, 2);\n        let c3 = Value::Cell(3, 3);\n        let d4 = Value::Cell(4, 4);\n\n        grid.get_node(1, 1).add_dep(b2.clone());\n        grid.get_node(1, 1).add_dep(c3.clone());\n        grid.get_node(2, 2).add_dep(d4.clone());\n\n        // Get the topological sequence starting from A1\n        let sequence = get_sequence(\u0026mut grid, a1.clone());\n\n        // The sequence should be in evaluation order (opposite of topological sort output)\n        // One valid order would be: [C3, D4, B2, A1]\n        assert_eq!(sequence.len(), 4);\n\n        // Verify A1 is last in the sequence (must be evaluated last)\n        assert_eq!(sequence[0], a1);\n\n        // B2 must come after D4\n        let b2_pos = sequence.iter().position(|v| v == \u0026b2).unwrap();\n        let d4_pos = sequence.iter().position(|v| v == \u0026d4).unwrap();\n        assert!(b2_pos \u003c d4_pos);\n\n        // Verify visited flags were reset\n        assert!(!grid.get_node(1, 1).visited);\n        assert!(!grid.get_node(2, 2).visited);\n        assert!(!grid.get_node(3, 3).visited);\n        assert!(!grid.get_node(4, 4).visited);\n    }\n\n    #[test]\n    fn test_integration_dependency_management() {\n        let mut grid = create_test_grid(5, 5);\n\n        // Test scenario: C3 initially depends on A1 and B2, then we change it to depend on D4\n        let a1 = Value::Cell(1, 1);\n        let b2 = Value::Cell(2, 2);\n        let c3 = Value::Cell(3, 3);\n        let d4 = Value::Cell(4, 4);\n\n        // Initial formula: C3 = A1 + B2\n        let func1 = Some(Value::Oper(\n            Some(Box::new(a1.clone())),\n            Some(Box::new(b2.clone())),\n            Operation::Add,\n        ));\n\n        // Update C3 to use this formula\n        grid.get_node(3, 3).function = func1.clone();\n        update_edges(\u0026mut grid, c3.clone(), func1.clone(), true);\n\n        // Verify dependencies\n        assert!(grid.get_node(1, 1).dependents.contains(\u0026c3));\n        assert!(grid.get_node(2, 2).dependents.contains(\u0026c3));\n\n        // Check for cycles (should be none)\n        assert!(!has_cycle(\u0026mut grid, c3.clone()));\n\n        // Get evaluation sequence\n        let sequence = get_sequence(\u0026mut grid, c3.clone());\n        assert_eq!(sequence.len(), 1);\n        assert_eq!(sequence[0], c3);\n\n        // Now change formula: C3 = D4 * 5\n        let func2 = Some(Value::Oper(\n            Some(Box::new(d4.clone())),\n            Some(Box::new(Value::Const(5))),\n            Operation::Mul,\n        ));\n\n        // Update C3 with new formula\n        grid.get_node(3, 3).function = func2.clone();\n        update_edges(\u0026mut grid, c3.clone(), func2.clone(), true);\n\n        // Verify old dependencies are removed\n        assert!(grid.get_node(1, 1).dependents.contains(\u0026c3));\n        assert!(grid.get_node(2, 2).dependents.contains(\u0026c3));\n\n        // Verify new dependency is added\n        assert!(grid.get_node(4, 4).dependents.contains(\u0026c3));\n\n        // Check for cycles (should be none)\n        assert!(!has_cycle(\u0026mut grid, c3.clone()));\n\n        // Try to create a cycle: D4 = C3 (should fail)\n        let cycle_func = Some(Value::Oper(\n            Some(Box::new(c3.clone())),\n            Some(Box::new(Value::Const(2))),\n            Operation::Mul,\n        ));\n\n        // Update D4 with formula that would create a cycle\n        grid.get_node(4, 4).function = cycle_func.clone();\n        add_edges(\u0026mut grid, d4.clone(), cycle_func.clone(), true);\n\n        // Verify cycle is detected\n        assert!(has_cycle(\u0026mut grid, d4.clone()));\n\n        // Break the cycle\n        break_edges(\u0026mut grid, d4.clone(), cycle_func.clone(), true);\n\n        // Verify cycle is gone\n        assert!(!has_cycle(\u0026mut grid, d4.clone()));\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","yuvikachaudhary","Desktop","Semester 4","COP290","spreadsheet_rust","tests","graph_terminal.rs"],"content":"use project::terminal::functions::Operation;\nuse project::terminal::graph::Node;\nuse project::terminal::types::Coordinates;\n\n#[test]\nfn test_node_get_value() {\n    let node = Node {\n        dependents: Vec::new(),\n        node_value: 42,\n        value1: Coordinates { row: 0, col: 0 },\n        value2: Coordinates { row: 0, col: 0 },\n        position: Coordinates { row: 1, col: 1 },\n        op: Operation::Add,\n        valid: true,\n        visited: false,\n    };\n\n    assert_eq!(node.get_value(), 42);\n}\n\n#[test]\nfn test_node_set_value() {\n    let mut node = Node {\n        dependents: Vec::new(),\n        node_value: 42,\n        value1: Coordinates { row: 0, col: 0 },\n        value2: Coordinates { row: 0, col: 0 },\n        position: Coordinates { row: 1, col: 1 },\n        op: Operation::Add,\n        valid: true,\n        visited: false,\n    };\n\n    node.set_value(99);\n    assert_eq!(node.node_value, 99);\n    assert_eq!(node.get_value(), 99);\n}\n\n#[test]\nfn test_node_set_position() {\n    let mut node = Node {\n        dependents: Vec::new(),\n        node_value: 42,\n        value1: Coordinates { row: 0, col: 0 },\n        value2: Coordinates { row: 0, col: 0 },\n        position: Coordinates { row: 1, col: 1 },\n        op: Operation::Add,\n        valid: true,\n        visited: false,\n    };\n\n    let new_position = Coordinates { row: 3, col: 4 };\n    node.set_position(new_position);\n\n    assert_eq!(node.position.row, 3);\n    assert_eq!(node.position.col, 4);\n}\n\n#[test]\nfn test_node_set_value1() {\n    let mut node = Node {\n        dependents: Vec::new(),\n        node_value: 42,\n        value1: Coordinates { row: 0, col: 0 },\n        value2: Coordinates { row: 0, col: 0 },\n        position: Coordinates { row: 1, col: 1 },\n        op: Operation::Add,\n        valid: true,\n        visited: false,\n    };\n\n    let new_value1 = Coordinates { row: 5, col: 6 };\n    node.set_value1(new_value1);\n\n    assert_eq!(node.value1.row, 5);\n    assert_eq!(node.value1.col, 6);\n}\n\n#[test]\nfn test_node_set_value2() {\n    let mut node = Node {\n        dependents: Vec::new(),\n        node_value: 42,\n        value1: Coordinates { row: 0, col: 0 },\n        value2: Coordinates { row: 0, col: 0 },\n        position: Coordinates { row: 1, col: 1 },\n        op: Operation::Add,\n        valid: true,\n        visited: false,\n    };\n\n    let new_value2 = Coordinates { row: 7, col: 8 };\n    node.set_value2(new_value2);\n\n    assert_eq!(node.value2.row, 7);\n    assert_eq!(node.value2.col, 8);\n}\n\n#[test]\nfn test_node_get_valid() {\n    let valid_node = Node {\n        dependents: Vec::new(),\n        node_value: 42,\n        value1: Coordinates { row: 0, col: 0 },\n        value2: Coordinates { row: 0, col: 0 },\n        position: Coordinates { row: 1, col: 1 },\n        op: Operation::Add,\n        valid: true,\n        visited: false,\n    };\n\n    let invalid_node = Node {\n        dependents: Vec::new(),\n        node_value: 42,\n        value1: Coordinates { row: 0, col: 0 },\n        value2: Coordinates { row: 0, col: 0 },\n        position: Coordinates { row: 1, col: 1 },\n        op: Operation::Add,\n        valid: false,\n        visited: false,\n    };\n\n    assert!(valid_node.get_valid());\n    assert!(!invalid_node.get_valid());\n}\n\n#[test]\nfn test_node_set_valid() {\n    let mut node = Node {\n        dependents: Vec::new(),\n        node_value: 42,\n        value1: Coordinates { row: 0, col: 0 },\n        value2: Coordinates { row: 0, col: 0 },\n        position: Coordinates { row: 1, col: 1 },\n        op: Operation::Add,\n        valid: true,\n        visited: false,\n    };\n\n    assert!(node.get_valid());\n\n    node.set_valid(false);\n    assert!(!node.get_valid());\n    assert!(!node.valid);\n\n    node.set_valid(true);\n    assert!(node.get_valid());\n    assert!(node.valid);\n}\n\n#[test]\nfn test_node_add_dep() {\n    let mut node = Node {\n        dependents: Vec::new(),\n        node_value: 42,\n        value1: Coordinates { row: 0, col: 0 },\n        value2: Coordinates { row: 0, col: 0 },\n        position: Coordinates { row: 1, col: 1 },\n        op: Operation::Add,\n        valid: true,\n        visited: false,\n    };\n\n    // Add first dependent\n    let dep1 = Coordinates { row: 2, col: 3 };\n    node.add_dep(dep1);\n\n    assert_eq!(node.dependents.len(), 1);\n    assert_eq!(node.dependents[0].row, 2);\n    assert_eq!(node.dependents[0].col, 3);\n\n    // Add second dependent\n    let dep2 = Coordinates { row: 4, col: 5 };\n    node.add_dep(dep2);\n\n    assert_eq!(node.dependents.len(), 2);\n    assert_eq!(node.dependents[1].row, 4);\n    assert_eq!(node.dependents[1].col, 5);\n\n    // Try to add duplicate dependent\n    node.add_dep(dep1);\n\n    // Should still have only 2 dependents (no duplicates)\n    assert_eq!(node.dependents.len(), 2);\n}\n\n#[test]\nfn test_node_remove_dep() {\n    let mut node = Node {\n        dependents: Vec::new(),\n        node_value: 42,\n        value1: Coordinates { row: 0, col: 0 },\n        value2: Coordinates { row: 0, col: 0 },\n        position: Coordinates { row: 1, col: 1 },\n        op: Operation::Add,\n        valid: true,\n        visited: false,\n    };\n\n    // Add dependents\n    let dep1 = Coordinates { row: 2, col: 3 };\n    let dep2 = Coordinates { row: 4, col: 5 };\n    let dep3 = Coordinates { row: 6, col: 7 };\n\n    node.add_dep(dep1);\n    node.add_dep(dep2);\n    node.add_dep(dep3);\n\n    assert_eq!(node.dependents.len(), 3);\n\n    // Remove a dependent\n    node.remove_dep(dep2);\n\n    assert_eq!(node.dependents.len(), 2);\n    assert_eq!(node.dependents[0].row, 2);\n    assert_eq!(node.dependents[0].col, 3);\n    assert_eq!(node.dependents[1].row, 6);\n    assert_eq!(node.dependents[1].col, 7);\n\n    // Try to remove a dependent that doesn't exist\n    let non_existent_dep = Coordinates { row: 8, col: 9 };\n    node.remove_dep(non_existent_dep);\n\n    // Should still have 2 dependents\n    assert_eq!(node.dependents.len(), 2);\n}\n\n#[test]\nfn test_node_get_dependents() {\n    let mut node = Node {\n        dependents: Vec::new(),\n        node_value: 42,\n        value1: Coordinates { row: 0, col: 0 },\n        value2: Coordinates { row: 0, col: 0 },\n        position: Coordinates { row: 1, col: 1 },\n        op: Operation::Add,\n        valid: true,\n        visited: false,\n    };\n\n    // Add dependents\n    let dep1 = Coordinates { row: 2, col: 3 };\n    let dep2 = Coordinates { row: 4, col: 5 };\n\n    node.add_dep(dep1);\n    node.add_dep(dep2);\n\n    let deps = node.get_dependents();\n\n    assert_eq!(deps.len(), 2);\n    assert_eq!(deps[0].row, 2);\n    assert_eq!(deps[0].col, 3);\n    assert_eq!(deps[1].row, 4);\n    assert_eq!(deps[1].col, 5);\n}\n\n#[test]\nfn test_node_set_dependents() {\n    let mut node = Node {\n        dependents: Vec::new(),\n        node_value: 42,\n        value1: Coordinates { row: 0, col: 0 },\n        value2: Coordinates { row: 0, col: 0 },\n        position: Coordinates { row: 1, col: 1 },\n        op: Operation::Add,\n        valid: true,\n        visited: false,\n    };\n\n    // Create a list of dependents\n    let mut deps = Vec::new();\n    deps.push(Coordinates { row: 2, col: 3 });\n    deps.push(Coordinates { row: 4, col: 5 });\n    deps.push(Coordinates { row: 6, col: 7 });\n\n    // Set the dependents\n    node.set_dependents(deps);\n\n    assert_eq!(node.dependents.len(), 3);\n    assert_eq!(node.dependents[0].row, 2);\n    assert_eq!(node.dependents[0].col, 3);\n    assert_eq!(node.dependents[1].row, 4);\n    assert_eq!(node.dependents[1].col, 5);\n    assert_eq!(node.dependents[2].row, 6);\n    assert_eq!(node.dependents[2].col, 7);\n\n    // Override with a new list\n    let mut new_deps = Vec::new();\n    new_deps.push(Coordinates { row: 8, col: 9 });\n\n    node.set_dependents(new_deps);\n\n    assert_eq!(node.dependents.len(), 1);\n    assert_eq!(node.dependents[0].row, 8);\n    assert_eq!(node.dependents[0].col, 9);\n}\n\n// Helper function to create a default Node for testing\nfn create_test_node() -\u003e Node {\n    Node {\n        dependents: Vec::new(),\n        node_value: 0,\n        value1: Coordinates { row: 0, col: 0 },\n        value2: Coordinates { row: 0, col: 0 },\n        position: Coordinates { row: 0, col: 0 },\n        op: Operation::Add,\n        valid: true,\n        visited: false,\n    }\n}\n\n#[test]\nfn test_node_combined_operations() {\n    let mut node = create_test_node();\n\n    // Test multiple operations in sequence\n    node.set_value(42);\n    assert_eq!(node.get_value(), 42);\n\n    node.set_position(Coordinates { row: 1, col: 2 });\n    assert_eq!(node.position.row, 1);\n    assert_eq!(node.position.col, 2);\n\n    node.add_dep(Coordinates { row: 3, col: 4 });\n    node.add_dep(Coordinates { row: 5, col: 6 });\n    assert_eq!(node.dependents.len(), 2);\n\n    node.remove_dep(Coordinates { row: 3, col: 4 });\n    assert_eq!(node.dependents.len(), 1);\n    assert_eq!(node.dependents[0].row, 5);\n    assert_eq!(node.dependents[0].col, 6);\n\n    node.set_valid(false);\n    assert!(!node.get_valid());\n\n    // Test that setting dependents replaces existing ones\n    let mut new_deps = Vec::new();\n    new_deps.push(Coordinates { row: 7, col: 8 });\n    new_deps.push(Coordinates { row: 9, col: 10 });\n\n    node.set_dependents(new_deps);\n    assert_eq!(node.get_dependents().len(), 2);\n    assert_eq!(node.get_dependents()[0].row, 7);\n    assert_eq!(node.get_dependents()[0].col, 8);\n    assert_eq!(node.get_dependents()[1].row, 9);\n    assert_eq!(node.get_dependents()[1].col, 10);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","yuvikachaudhary","Desktop","Semester 4","COP290","spreadsheet_rust","tests","parser_ext.rs"],"content":"use project::extension::common::{Operation, Value};\nuse project::extension::parser::parser;\n\n#[test]\nfn test_validate_cell_assignment() {\n    // Test assigning a constant to a cell\n    let rows = 10;\n    let cols = 10;\n\n    // Test valid cell assignment\n    let result = parser::validate(\"A1=5\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n\n    if let Some((cell, operation)) = result {\n        assert_eq!(cell, Some(Value::Cell(1, 1)));\n        if let Some(Value::Oper(box1, box2, op)) = operation {\n            assert_eq!(*box1.unwrap(), Value::Const(5));\n            assert_eq!(*box2.unwrap(), Value::Const(0));\n            assert!(matches!(op, Operation::Cons));\n        } else {\n            panic!(\"Expected Value::Oper for operation\");\n        }\n    }\n\n    // Test invalid cell (out of range)\n    // let result = parser::validate(\"Z99=5\", \u0026cols, \u0026rows);\n    // assert!(result.is_none());\n}\n\n#[test]\nfn test_validate_arithmetic_operations() {\n    let rows = 10;\n    let cols = 10;\n\n    // Test addition\n    let result = parser::validate(\"B2=A1+5\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n\n    if let Some((cell, operation)) = result {\n        assert_eq!(cell, Some(Value::Cell(2, 2)));\n        if let Some(Value::Oper(box1, box2, op)) = operation {\n            assert_eq!(*box1.unwrap(), Value::Cell(1, 1));\n            assert_eq!(*box2.unwrap(), Value::Const(5));\n            assert!(matches!(op, Operation::Add));\n        }\n    }\n\n    // Test subtraction\n    let result = parser::validate(\"C3=10-D4\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n\n    if let Some((cell, operation)) = result {\n        assert_eq!(cell, Some(Value::Cell(3, 3)));\n        if let Some(Value::Oper(box1, box2, op)) = operation {\n            assert_eq!(*box1.unwrap(), Value::Const(10));\n            assert_eq!(*box2.unwrap(), Value::Cell(4, 4));\n            assert!(matches!(op, Operation::Sub));\n        }\n    }\n\n    // Test multiplication\n    let result = parser::validate(\"E5=F6*G7\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n\n    // Test division\n    let result = parser::validate(\"H8=100/I9\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n}\n\n#[test]\nfn test_validate_range_operations() {\n    let rows = 10;\n    let cols = 10;\n\n    // Test SUM\n    let result = parser::validate(\"D1=SUM(A1:C3)\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n\n    if let Some((cell, operation)) = result {\n        assert_eq!(cell, Some(Value::Cell(1, 4)));\n        if let Some(Value::Oper(box1, box2, op)) = operation {\n            assert_eq!(*box1.unwrap(), Value::Cell(1, 1));\n            assert_eq!(*box2.unwrap(), Value::Cell(3, 3));\n            assert!(matches!(op, Operation::Sum));\n        }\n    }\n\n    // Test AVG\n    let result = parser::validate(\"E1=AVG(A1:C3)\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n\n    if let Some((cell, operation)) = result {\n        assert_eq!(cell, Some(Value::Cell(1, 5)));\n        if let Some(Value::Oper(_box1, _box2, op)) = operation {\n            assert!(matches!(op, Operation::Avg));\n        }\n    }\n\n    // Test MIN\n    let result = parser::validate(\"F1=MIN(A1:C3)\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n\n    if let Some((_cell, operation)) = result {\n        if let Some(Value::Oper(_, _, op)) = operation {\n            assert!(matches!(op, Operation::Min));\n        }\n    }\n\n    // Test MAX\n    let result = parser::validate(\"G1=MAX(A1:C3)\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n\n    if let Some((_cell, operation)) = result {\n        if let Some(Value::Oper(_, _, op)) = operation {\n            assert!(matches!(op, Operation::Max));\n        }\n    }\n\n    // Test STDEV\n    let result = parser::validate(\"H1=STDEV(A1:C3)\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n\n    if let Some((_cell, operation)) = result {\n        if let Some(Value::Oper(_, _, op)) = operation {\n            assert!(matches!(op, Operation::Std));\n        }\n    }\n\n    // Test invalid range (start \u003e end)\n    let result = parser::validate(\"I1=SUM(C3:A1)\", \u0026cols, \u0026rows);\n    assert!(result.is_none());\n}\n\n#[test]\nfn test_validate_special_commands() {\n    let rows = 10;\n    let cols = 10;\n\n    // Test undo command\n    let result = parser::validate(\"undo\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n\n    if let Some((cell, operation)) = result {\n        assert!(cell.is_none());\n        if let Some(Value::Oper(box1, box2, op)) = operation {\n            assert!(box1.is_none());\n            assert!(box2.is_none());\n            assert!(matches!(op, Operation::Undo));\n        }\n    }\n\n    // Test redo command\n    let result = parser::validate(\"redo\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n\n    if let Some((cell, operation)) = result {\n        assert!(cell.is_none());\n        if let Some(Value::Oper(_, _, op)) = operation {\n            assert!(matches!(op, Operation::Redo));\n        }\n    }\n\n    // Test directional commands\n    let result = parser::validate(\"w\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n    if let Some((_, Some(Value::Oper(_, _, op)))) = result {\n        assert!(matches!(op, Operation::Up));\n    }\n\n    let result = parser::validate(\"s\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n    if let Some((_, Some(Value::Oper(_, _, op)))) = result {\n        assert!(matches!(op, Operation::Down));\n    }\n\n    let result = parser::validate(\"a\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n    if let Some((_, Some(Value::Oper(_, _, op)))) = result {\n        assert!(matches!(op, Operation::Left));\n    }\n\n    let result = parser::validate(\"d\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n    if let Some((_, Some(Value::Oper(_, _, op)))) = result {\n        assert!(matches!(op, Operation::Right));\n    }\n\n    // Test quit command\n    let result = parser::validate(\"q\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n    if let Some((_, Some(Value::Oper(_, _, op)))) = result {\n        assert!(matches!(op, Operation::Quit));\n    }\n}\n\n#[test]\nfn test_validate_save_web_commands() {\n    let rows = 10;\n    let cols = 10;\n\n    // Test save command\n    let result = parser::validate(\"save myfile.json\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n\n    if let Some((cell, operation)) = result {\n        assert!(cell.is_none());\n        if let Some(Value::Oper(box1, box2, Operation::Save(filename))) = operation {\n            assert!(box1.is_none());\n            assert!(box2.is_none());\n            assert_eq!(filename, \"myfile.json\");\n        }\n    }\n\n    // Test web command\n    let result = parser::validate(\"web index.html\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n\n    if let Some((cell, operation)) = result {\n        assert!(cell.is_none());\n        if let Some(Value::Oper(box1, box2, Operation::Web(filename))) = operation {\n            assert!(box1.is_none());\n            assert!(box2.is_none());\n            assert_eq!(filename, \"index.html\");\n        }\n    }\n\n    // Test web_start command\n    let result = parser::validate(\"web_start\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n\n    if let Some((_, Some(Value::Oper(_, _, op)))) = result {\n        assert!(matches!(op, Operation::WebStart));\n    }\n}\n\n#[test]\nfn test_validate_scroll_to() {\n    let rows = 10;\n    let cols = 10;\n\n    // Test valid scroll_to command\n    let result = parser::validate(\"scroll_to B5\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n\n    if let Some((cell, operation)) = result {\n        assert_eq!(cell, Some(Value::Cell(5, 2)));\n        if let Some(Value::Oper(_, _, op)) = operation {\n            assert!(matches!(op, Operation::ScrollTo));\n        }\n    }\n\n    // Test invalid scroll_to (out of bounds)\n    let result = parser::validate(\"scroll_to Z99\", \u0026cols, \u0026rows);\n    assert!(result.is_none());\n}\n\n#[test]\nfn test_validate_output_commands() {\n    let rows = 10;\n    let cols = 10;\n\n    // Test enable_output command\n    let result = parser::validate(\"enable_output\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n\n    if let Some((_, Some(Value::Oper(_, _, op)))) = result {\n        assert!(matches!(op, Operation::EnableOutput));\n    }\n\n    // Test disable_output command\n    let result = parser::validate(\"disable_output\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n\n    if let Some((_, Some(Value::Oper(_, _, op)))) = result {\n        assert!(matches!(op, Operation::DisableOutput));\n    }\n}\n\n#[test]\nfn test_validate_invalid_commands() {\n    let rows = 10;\n    let cols = 10;\n\n    // Test completely invalid command\n    let result = parser::validate(\"this is not a valid command\", \u0026cols, \u0026rows);\n    assert!(result.is_none());\n\n    // Test command with missing equals sign\n    let result = parser::validate(\"A1 5\", \u0026cols, \u0026rows);\n    assert!(result.is_none());\n\n    // Test invalid function name\n    let result = parser::validate(\"A1=INVALID(B1:C3)\", \u0026cols, \u0026rows);\n    let expected_value = Some((Some(Value::Cell(1, 1)), None));\n    assert_eq!(result, expected_value);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","yuvikachaudhary","Desktop","Semester 4","COP290","spreadsheet_rust","tests","parser_terminal.rs"],"content":"use project::terminal::functions::Operation;\nuse project::terminal::functions::Value;\nuse project::terminal::parser;\n\n#[test]\nfn test_validate_cell_assignment() {\n    // Test assigning a constant to a cell\n    let rows = 10;\n    let cols = 10;\n\n    // Test valid cell assignment\n    let result = parser::validate(\"A1=5\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n\n    // Test invalid cell (out of range)\n    // let result = parser::validate(\"Z99=5\", \u0026cols, \u0026rows);\n    // assert!(result.is_none());\n}\n\n#[test]\nfn test_validate_arithmetic_operations() {\n    let rows = 10;\n    let cols = 10;\n\n    // Test addition\n    let result = parser::validate(\"B2=A1+5\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n\n    // Test subtraction\n    let result = parser::validate(\"C3=10-D4\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n\n    if let Some((cell, _operation)) = result {\n        assert_eq!(cell, Some(Value::Cell(3, 3)));\n    }\n\n    // Test multiplication\n    let result = parser::validate(\"E5=F6*G7\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n\n    // Test division\n    let result = parser::validate(\"H8=100/I9\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n}\n\n#[test]\nfn test_validate_range_operations() {\n    let rows = 10;\n    let cols = 10;\n\n    // Test SUM\n    let result = parser::validate(\"D1=SUM(A1:C3)\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n\n    if let Some((cell, _operation)) = result {\n        assert_eq!(cell, Some(Value::Cell(4, 1)));\n    }\n\n    // Test AVG\n    let result = parser::validate(\"E1=AVG(A1:C3)\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n\n    if let Some((cell, operation)) = result {\n        assert_eq!(cell, Some(Value::Cell(5, 1)));\n        if let Some(Value::Oper(_box1, _box2, op)) = operation {\n            assert!(matches!(op, Operation::Avg));\n        }\n    }\n\n    // Test MIN\n    let result = parser::validate(\"F1=MIN(A1:C3)\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n\n    if let Some((_cell, operation)) = result {\n        if let Some(Value::Oper(_, _, op)) = operation {\n            assert!(matches!(op, Operation::Min));\n        }\n    }\n\n    // Test MAX\n    let result = parser::validate(\"G1=MAX(A1:C3)\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n\n    if let Some((_cell, operation)) = result {\n        if let Some(Value::Oper(_, _, op)) = operation {\n            assert!(matches!(op, Operation::Max));\n        }\n    }\n\n    // Test STDEV\n    let result = parser::validate(\"H1=STDEV(A1:C3)\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n\n    if let Some((_cell, operation)) = result {\n        if let Some(Value::Oper(_, _, op)) = operation {\n            assert!(matches!(op, Operation::Std));\n        }\n    }\n\n    // Test invalid range (start \u003e end)\n    let result = parser::validate(\"I1=SUM(C3:A1)\", \u0026cols, \u0026rows);\n    assert!(result.is_none());\n}\n\n#[test]\nfn test_validate_scroll_to() {\n    let rows = 10;\n    let cols = 10;\n\n    // Test valid scroll_to command\n    let result = parser::validate(\"scroll_to B5\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n\n    if let Some((cell, operation)) = result {\n        assert_eq!(cell, Some(Value::Cell(2, 5)));\n        if let Some(Value::Oper(_, _, op)) = operation {\n            assert!(matches!(op, Operation::Scrollto));\n        }\n    }\n\n    // Test invalid scroll_to (out of bounds)\n    let result = parser::validate(\"scroll_to Z99\", \u0026cols, \u0026rows);\n    assert!(result.is_none());\n}\n\n#[test]\nfn test_validate_output_commands() {\n    let rows = 10;\n    let cols = 10;\n\n    // Test enable_output command\n    let result = parser::validate(\"enable_output\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n\n    if let Some((_, Some(Value::Oper(_, _, op)))) = result {\n        assert!(matches!(op, Operation::EnableOutput));\n    }\n\n    // Test disable_output command\n    let result = parser::validate(\"disable_output\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n\n    if let Some((_, Some(Value::Oper(_, _, op)))) = result {\n        assert!(matches!(op, Operation::DisableOutput));\n    }\n}\n\n#[test]\nfn test_validate_invalid_commands() {\n    let rows = 10;\n    let cols = 10;\n\n    // Test completely invalid command\n    let result = parser::validate(\"this is not a valid command\", \u0026cols, \u0026rows);\n    assert!(result.is_none());\n\n    // Test command with missing equals sign\n    let result = parser::validate(\"A1 5\", \u0026cols, \u0026rows);\n    assert!(result.is_none());\n\n    // Test invalid function name\n    let result = parser::validate(\"A1=INVALID(B1:C3)\", \u0026cols, \u0026rows);\n    let expected_value = Some((Some(Value::Cell(1, 1)), None));\n    assert_eq!(result, expected_value);\n}\n\n#[test]\nfn test_is_cell() {\n    let rows = 10;\n    let cols = 10;\n\n    // Valid cells\n    assert_eq!(parser::is_cell(\"A1\", \u0026rows, \u0026cols), Some(Value::Cell(1, 1)));\n    assert_eq!(parser::is_cell(\"B5\", \u0026rows, \u0026cols), Some(Value::Cell(2, 5)));\n    assert_eq!(\n        parser::is_cell(\"J10\", \u0026rows, \u0026cols),\n        Some(Value::Cell(10, 10))\n    );\n\n    // Invalid cells\n    assert_eq!(parser::is_cell(\"Z1\", \u0026rows, \u0026cols), None); // Column out of range\n    assert_eq!(parser::is_cell(\"A20\", \u0026rows, \u0026cols), None); // Row out of range\n    assert_eq!(parser::is_cell(\"1A\", \u0026rows, \u0026cols), None); // Invalid format\n    assert_eq!(parser::is_cell(\"AA1\", \u0026rows, \u0026cols), None); // Two-letter column\n}\n\n#[test]\nfn test_is_const() {\n    // Valid integers\n    assert_eq!(parser::is_const(\"0\"), Some(Value::Const(0)));\n    assert_eq!(parser::is_const(\"42\"), Some(Value::Const(42)));\n    assert_eq!(parser::is_const(\"-10\"), Some(Value::Const(-10)));\n\n    // Invalid integers\n    assert_eq!(parser::is_const(\"\"), None); // Empty string\n    assert_eq!(parser::is_const(\"a\"), None); // Non-numeric\n    assert_eq!(parser::is_const(\"3.14\"), None); // Float, not integer\n}\n\n#[test]\nfn test_is_cell_or_const() {\n    let rows = 10;\n    let cols = 10;\n\n    // Test constant values\n    assert_eq!(\n        parser::is_cell_or_const(\"42\", \u0026rows, \u0026cols),\n        Some(Value::Const(42))\n    );\n    assert_eq!(\n        parser::is_cell_or_const(\"-5\", \u0026rows, \u0026cols),\n        Some(Value::Const(-5))\n    );\n\n    // Test cell references\n    assert_eq!(\n        parser::is_cell_or_const(\"A1\", \u0026rows, \u0026cols),\n        Some(Value::Cell(1, 1))\n    );\n    assert_eq!(\n        parser::is_cell_or_const(\"J10\", \u0026rows, \u0026cols),\n        Some(Value::Cell(10, 10))\n    );\n\n    // // Test invalid inputs\n    assert_eq!(parser::is_cell_or_const(\"ZZ99\", \u0026rows, \u0026cols), None);\n    assert_eq!(parser::is_cell_or_const(\"3.14\", \u0026rows, \u0026cols), None);\n}\n\n#[test]\nfn test_validate_complex_arithmetic() {\n    let rows = 10;\n    let cols = 10;\n\n    // Test negative numbers in operations\n    let result = parser::validate(\"A1=-5+B2\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n\n    // Test cell references with cells\n    let result = parser::validate(\"C3=A1+B2\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n\n    // Test multiple digit constants\n    let result = parser::validate(\"D4=123+456\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n\n    // Test all operators with different combinations\n    let operations = [\n        (\"E1=15+25\", Operation::Add),\n        (\"E2=30-10\", Operation::Sub),\n        (\"E3=5*6\", Operation::Mul),\n        (\"E4=20/4\", Operation::Div),\n    ];\n\n    for (cmd, _expected_op) in operations {\n        let result = parser::validate(cmd, \u0026cols, \u0026rows);\n        assert!(result.is_some());\n        if let Some((_, Some(Value::Oper(_, _, op)))) = result {\n            assert!(matches!(op, _expected_op));\n        } else {\n            panic!(\"Expected operation for {}\", cmd);\n        }\n    }\n}\n\n#[test]\nfn test_missing_special_commands() {\n    let rows = 10;\n    let cols = 10;\n\n    // Test all scroll_to variations\n    let result = parser::validate(\"scroll_to A1\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n    if let Some((cell, Some(Value::Oper(_, _, op)))) = result {\n        assert_eq!(cell, Some(Value::Cell(1, 1)));\n        assert!(matches!(op, Operation::Scrollto));\n    }\n\n    // Test with extra whitespace\n    let result = parser::validate(\"  scroll_to  C3  \", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n\n    // Test invalid cell for scroll_to\n    let result = parser::validate(\"scroll_to Z99\", \u0026cols, \u0026rows);\n    assert!(result.is_none());\n\n    // Test invalid format for scroll_to\n    let result = parser::validate(\"scroll_toA1\", \u0026cols, \u0026rows);\n    assert!(result.is_none());\n}\n\n#[test]\nfn test_command_validation_edge_cases() {\n    let rows = 10;\n    let cols = 10;\n\n    // Test missing closing parenthesis\n    let result = parser::validate(\"A1=SUM(B1:C2\", \u0026cols, \u0026rows);\n    assert!(result.is_none());\n\n    // Test invalid chars in cell names\n    let result = parser::validate(\"A@1=5\", \u0026cols, \u0026rows);\n    if let Some((cell, Some(Value::Oper(_, _, _op)))) = result {\n        assert!(cell.is_none());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","yuvikachaudhary","Desktop","Semester 4","COP290","spreadsheet_rust","tests","spreadsheet_terminal.rs"],"content":"#[allow(unused_imports)]\nuse project::terminal::functions::{Operation, Value};\nuse project::terminal::graph::Node;\nuse project::terminal::spreadsheet::*;\nuse project::terminal::types::Coordinates;\n#[allow(unused_imports)]\nuse std::collections::HashMap;\n#[allow(unused_imports)]\nuse std::io::{self, Write};\n\n// Existing tests\n\n#[test]\nfn test_column_decoder() {\n    // Test single-letter columns\n    assert_eq!(column_decoder(1), \"A\");\n    assert_eq!(column_decoder(26), \"Z\");\n\n    // Test double-letter columns\n    assert_eq!(column_decoder(27), \"AA\");\n    assert_eq!(column_decoder(28), \"AB\");\n    assert_eq!(column_decoder(52), \"AZ\");\n    assert_eq!(column_decoder(53), \"BA\");\n\n    // Test triple-letter columns\n    assert_eq!(column_decoder(703), \"AAA\");\n    assert_eq!(column_decoder(18278), \"ZZZ\"); // MAX_COLUMN\n}\n\n// New edge cases for column_decoder\n#[test]\nfn test_column_decoder_edge_cases() {\n    // Edge cases\n    assert_eq!(column_decoder(702), \"ZZ\");\n    assert_eq!(column_decoder(677), \"ZA\");\n    assert_eq!(column_decoder(676), \"YZ\");\n}\n\n#[test]\nfn test_process_first() {\n    // Valid arguments\n    let args = vec![\n        String::from(\"program_name\"),\n        String::from(\"100\"),\n        String::from(\"100\"),\n    ];\n    let mut is_disabled = false;\n    assert!(process_first(args.len(), \u0026args, \u0026mut is_disabled));\n\n    // Invalid number of arguments\n    let invalid_args = vec![String::from(\"program_name\"), String::from(\"100\")];\n    assert!(!process_first(\n        invalid_args.len(),\n        \u0026invalid_args,\n        \u0026mut is_disabled\n    ));\n\n    // Non-numeric arguments\n    let non_numeric_args = vec![\n        String::from(\"program_name\"),\n        String::from(\"abc\"),\n        String::from(\"100\"),\n    ];\n    assert!(!process_first(\n        non_numeric_args.len(),\n        \u0026non_numeric_args,\n        \u0026mut is_disabled\n    ));\n\n    // Out of range arguments (too large)\n    let large_args = vec![\n        String::from(\"program_name\"),\n        String::from(\"1000\"), // Exceeds MAX_ROW\n        String::from(\"100\"),\n    ];\n    assert!(!process_first(\n        large_args.len(),\n        \u0026large_args,\n        \u0026mut is_disabled\n    ));\n\n    let large_col_args = vec![\n        String::from(\"program_name\"),\n        String::from(\"100\"),\n        String::from(\"18279\"), // Exceeds MAX_COLUMN\n    ];\n    assert!(!process_first(\n        large_col_args.len(),\n        \u0026large_col_args,\n        \u0026mut is_disabled\n    ));\n\n    // Out of range arguments (too small)\n    let zero_args = vec![\n        String::from(\"program_name\"),\n        String::from(\"0\"), // Below valid range\n        String::from(\"100\"),\n    ];\n    assert!(!process_first(\n        zero_args.len(),\n        \u0026zero_args,\n        \u0026mut is_disabled\n    ));\n}\n\n// Additional test for process_first with boundary values\n#[test]\nfn test_process_first_boundary_values() {\n    let mut is_disabled = false;\n\n    // Test with minimum valid values\n    let min_args = vec![\n        String::from(\"program_name\"),\n        String::from(\"1\"),\n        String::from(\"1\"),\n    ];\n    assert!(process_first(min_args.len(), \u0026min_args, \u0026mut is_disabled));\n\n    // Test with maximum valid values\n    let max_args = vec![\n        String::from(\"program_name\"),\n        String::from(\"999\"),   // MAX_ROW\n        String::from(\"18278\"), // MAX_COLUMN\n    ];\n    assert!(process_first(max_args.len(), \u0026max_args, \u0026mut is_disabled));\n\n    // Test with too many arguments\n    let too_many_args = vec![\n        String::from(\"program_name\"),\n        String::from(\"100\"),\n        String::from(\"100\"),\n        String::from(\"extra\"),\n    ];\n    assert!(!process_first(\n        too_many_args.len(),\n        \u0026too_many_args,\n        \u0026mut is_disabled\n    ));\n\n    // Test with empty strings\n    let empty_args = vec![\n        String::from(\"program_name\"),\n        String::from(\"\"),\n        String::from(\"100\"),\n    ];\n    assert!(!process_first(\n        empty_args.len(),\n        \u0026empty_args,\n        \u0026mut is_disabled\n    ));\n}\n\n// Mock creating a grid for testing\nfn create_test_grid(rows: usize, cols: usize) -\u003e Vec\u003cVec\u003cNode\u003e\u003e {\n    let mut grid = Vec::with_capacity(rows + 1);\n    for i in 0..=rows {\n        let mut row = Vec::with_capacity(cols + 1);\n        for j in 0..=cols {\n            let mut node = Node {\n                node_value: 0,\n                valid: false,\n                dependents: Vec::new(),\n                value1: Coordinates { row: 0, col: 0 },\n                value2: Coordinates { row: 0, col: 0 },\n                position: Coordinates {\n                    row: i as i32,\n                    col: j as i32,\n                },\n                op: Operation::Add, // Default operation\n                visited: false,\n            };\n            if i \u003e 0 \u0026\u0026 j \u003e 0 {\n                // Set some example values\n                node.node_value = 0;\n                node.valid = true;\n            }\n            row.push(node);\n        }\n        grid.push(row);\n    }\n\n    // Add some invalid cells for testing\n    if rows \u003e= 5 \u0026\u0026 cols \u003e= 5 {\n        grid[3][3].valid = false;\n    }\n\n    grid\n}\n\n#[test]\nfn test_process_command_navigation() {\n    let rows = 30;\n    let cols = 30;\n    let mut grid = create_test_grid(rows, cols);\n    let mut start_x = 10;\n    let mut start_y = 10;\n    let mut is_disabled = false;\n\n    // Test movement commands\n    assert_eq!(\n        process_command(\n            \"w\",\n            \u0026mut start_x,\n            \u0026mut start_y,\n            rows,\n            cols,\n            \u0026mut is_disabled,\n            \u0026mut grid\n        ),\n        1\n    );\n    assert_eq!(start_x, 1); // Move up 10 rows but not below 1\n\n    start_x = 15;\n    assert_eq!(\n        process_command(\n            \"w\",\n            \u0026mut start_x,\n            \u0026mut start_y,\n            rows,\n            cols,\n            \u0026mut is_disabled,\n            \u0026mut grid\n        ),\n        1\n    );\n    assert_eq!(start_x, 5); // Move up 10 rows\n\n    assert_eq!(\n        process_command(\n            \"s\",\n            \u0026mut start_x,\n            \u0026mut start_y,\n            rows,\n            cols,\n            \u0026mut is_disabled,\n            \u0026mut grid\n        ),\n        1\n    );\n    assert_eq!(start_x, 15); // Move down 10 rows\n\n    assert_eq!(\n        process_command(\n            \"a\",\n            \u0026mut start_x,\n            \u0026mut start_y,\n            rows,\n            cols,\n            \u0026mut is_disabled,\n            \u0026mut grid\n        ),\n        1\n    );\n    assert_eq!(start_y, 1); // Move left 10 columns but not below 1\n\n    start_y = 15;\n    assert_eq!(\n        process_command(\n            \"a\",\n            \u0026mut start_x,\n            \u0026mut start_y,\n            rows,\n            cols,\n            \u0026mut is_disabled,\n            \u0026mut grid\n        ),\n        1\n    );\n    assert_eq!(start_y, 5); // Move left 10 columns\n\n    assert_eq!(\n        process_command(\n            \"d\",\n            \u0026mut start_x,\n            \u0026mut start_y,\n            rows,\n            cols,\n            \u0026mut is_disabled,\n            \u0026mut grid\n        ),\n        1\n    );\n    assert_eq!(start_y, 15); // Move right 10 columns\n\n    // Test output toggle commands\n    // We'll need to simulate a command that would toggle output\n    // Since we don't have direct access to the parser implementation, this is a placeholder\n    // You'll need to update this based on your actual implementation\n    let disable_output_cmd = \"disable_output\"; // Replace with your actual command syntax\n    if let 1 = process_command(\n        disable_output_cmd,\n        \u0026mut start_x,\n        \u0026mut start_y,\n        rows,\n        cols,\n        \u0026mut is_disabled,\n        \u0026mut grid,\n    ) {\n        assert!(is_disabled);\n    }\n\n    let enable_output_cmd = \"enable_output\"; // Replace with your actual command syntax\n    if let 1 = process_command(\n        enable_output_cmd,\n        \u0026mut start_x,\n        \u0026mut start_y,\n        rows,\n        cols,\n        \u0026mut is_disabled,\n        \u0026mut grid,\n    ) {\n        assert!(!is_disabled);\n    }\n\n    // Test quit command\n    assert_eq!(\n        process_command(\n            \"q\",\n            \u0026mut start_x,\n            \u0026mut start_y,\n            rows,\n            cols,\n            \u0026mut is_disabled,\n            \u0026mut grid\n        ),\n        0\n    );\n}\n\n// New test for navigation at grid boundaries\n#[test]\nfn test_navigation_at_grid_boundaries() {\n    let rows = 15;\n    let cols = 15;\n    let mut grid = create_test_grid(rows, cols);\n    let mut is_disabled = false;\n\n    // Test at top boundary\n    let mut start_x = 1;\n    let mut start_y = 8;\n    assert_eq!(\n        process_command(\n            \"w\",\n            \u0026mut start_x,\n            \u0026mut start_y,\n            rows,\n            cols,\n            \u0026mut is_disabled,\n            \u0026mut grid\n        ),\n        1\n    );\n    assert_eq!(start_x, 1); // Should remain at 1, not go below\n\n    // Test at bottom boundary\n    start_x = rows - 8;\n    assert_eq!(\n        process_command(\n            \"s\",\n            \u0026mut start_x,\n            \u0026mut start_y,\n            rows,\n            cols,\n            \u0026mut is_disabled,\n            \u0026mut grid\n        ),\n        1\n    );\n    assert_eq!(start_x, 7);\n\n    // Another move down should be constrained to show the last rows\n    assert_eq!(\n        process_command(\n            \"s\",\n            \u0026mut start_x,\n            \u0026mut start_y,\n            rows,\n            cols,\n            \u0026mut is_disabled,\n            \u0026mut grid\n        ),\n        1\n    );\n    assert_eq!(start_x, rows - 8); // Constrained to show the last 9 rows\n\n    // Test at left boundary\n    start_x = 8;\n    start_y = 1;\n    assert_eq!(\n        process_command(\n            \"a\",\n            \u0026mut start_x,\n            \u0026mut start_y,\n            rows,\n            cols,\n            \u0026mut is_disabled,\n            \u0026mut grid\n        ),\n        1\n    );\n    assert_eq!(start_y, 1); // Should remain at 1, not go below\n\n    // Test at right boundary\n    start_y = cols - 8;\n    assert_eq!(\n        process_command(\n            \"d\",\n            \u0026mut start_x,\n            \u0026mut start_y,\n            rows,\n            cols,\n            \u0026mut is_disabled,\n            \u0026mut grid\n        ),\n        1\n    );\n    assert_eq!(start_y, cols - 8);\n\n    // Another move right should be constrained to show the last columns\n    assert_eq!(\n        process_command(\n            \"d\",\n            \u0026mut start_x,\n            \u0026mut start_y,\n            rows,\n            cols,\n            \u0026mut is_disabled,\n            \u0026mut grid\n        ),\n        1\n    );\n    assert_eq!(start_y, cols - 8); // Constrained to show the last 9 columns\n}\n\n// Test invalid commands\n#[test]\nfn test_invalid_commands() {\n    let rows = 20;\n    let cols = 20;\n    let mut grid = create_test_grid(rows, cols);\n    let mut start_x = 10;\n    let mut start_y = 10;\n    let mut is_disabled = false;\n\n    // Test completely invalid command\n    assert_eq!(\n        process_command(\n            \"invalid_command\",\n            \u0026mut start_x,\n            \u0026mut start_y,\n            rows,\n            cols,\n            \u0026mut is_disabled,\n            \u0026mut grid\n        ),\n        3 // Expected to return code 3 for unrecognized command\n    );\n\n    // Test command with invalid syntax\n    assert_eq!(\n        process_command(\n            \"A1 = invalid_operation(B2, C3)\",\n            \u0026mut start_x,\n            \u0026mut start_y,\n            rows,\n            cols,\n            \u0026mut is_disabled,\n            \u0026mut grid\n        ),\n        3 // Expected to return code 3 for unrecognized command\n    );\n}\n\n// This is a more involved test that requires mocking the parser\n// and getting_things_updated functions\n#[test]\nfn test_process_command_cell_operations() {\n    // This test is more complex and depends on your implementation details\n    // You'll need to expand this based on your actual parser and backend functions\n\n    let rows = 30;\n    let cols = 30;\n    let mut grid = create_test_grid(rows, cols);\n    let mut start_x = 10;\n    let mut start_y = 10;\n    let mut is_disabled = false;\n\n    // Test scrollto operation\n    // Replace with your actual command syntax\n    let scrollto_cmd = \"A5 = scroll_to B2\";\n\n    // For this test to work correctly, you'll need to ensure your parser handles this command\n    // and recognizes it as a scrollto operation\n    let result = process_command(\n        scrollto_cmd,\n        \u0026mut start_x,\n        \u0026mut start_y,\n        rows,\n        cols,\n        \u0026mut is_disabled,\n        \u0026mut grid,\n    );\n\n    // If your parser correctly identifies this as a scrollto operation, it should:\n    // 1. Update start_x to the row value\n    // 2. Update start_y to the column value\n    // 3. Return status code 1\n\n    // This is a placeholder assertion - you'll need to update based on actual behavior\n    if result == 1 {\n        // Check if scrollto was successful (values would be set based on your implementation)\n        // The expected values depend on how your parser interprets the command\n    }\n\n    // Test basic cell operations\n    // These depend heavily on your parser implementation\n    let _basic_op_cmd = \"B2 = C3 + 5\";\n    // This test requires knowing how your parser and getting_things_updated function work\n}\n\n// New test for cell operations based on actual parser examples\n#[test]\nfn test_cell_operations_with_mock() {\n    // This test creates a simulated environment to test cell operations\n    // Assuming the parser syntax is like: \"A1 = add(B2, C3)\"\n    let rows = 30;\n    let cols = 30;\n    let mut grid = create_test_grid(rows, cols);\n    let mut start_x = 5;\n    let mut start_y = 5;\n    let mut is_disabled = false;\n\n    // These commands need to match your actual parser syntax\n    // Modify them based on your implementation\n\n    // Basic arithmetic operations\n    let add_cmd = \"A1 = B2+C3\";\n    let sub_cmd = \"D4 = E5-F6\";\n    let mul_cmd = \"G7 = H8*I9\";\n    let div_cmd = \"J10 = K11/L12\";\n\n    // Process commands and check status codes\n    // The expected return values depend on your implementation\n    let add_result = process_command(\n        add_cmd,\n        \u0026mut start_x,\n        \u0026mut start_y,\n        rows,\n        cols,\n        \u0026mut is_disabled,\n        \u0026mut grid,\n    );\n\n    let sub_result = process_command(\n        sub_cmd,\n        \u0026mut start_x,\n        \u0026mut start_y,\n        rows,\n        cols,\n        \u0026mut is_disabled,\n        \u0026mut grid,\n    );\n\n    let mul_result = process_command(\n        mul_cmd,\n        \u0026mut start_x,\n        \u0026mut start_y,\n        rows,\n        cols,\n        \u0026mut is_disabled,\n        \u0026mut grid,\n    );\n\n    let div_result = process_command(\n        div_cmd,\n        \u0026mut start_x,\n        \u0026mut start_y,\n        rows,\n        cols,\n        \u0026mut is_disabled,\n        \u0026mut grid,\n    );\n\n    // Check status codes based on your expected behavior\n    // This is a basic check to ensure the commands are processed\n    assert!(add_result \u003e= 1 \u0026\u0026 add_result \u003c= 5);\n    assert!(sub_result \u003e= 1 \u0026\u0026 sub_result \u003c= 5);\n    assert!(mul_result \u003e= 1 \u0026\u0026 mul_result \u003c= 5);\n    assert!(div_result \u003e= 1 \u0026\u0026 div_result \u003c= 5);\n}\n\n#[test]\nfn test_display_status() {\n    // This is mainly a visual function that writes to stdout\n    // We can test that it doesn't panic, but testing the actual output\n    // requires capturing stdout which is complex in Rust unit tests\n\n    // Test all status codes\n    display_status(1, 0.25);\n    display_status(2, 0.50);\n    display_status(3, 0.75);\n    display_status(4, 1.00);\n    display_status(5, 1.25);\n    display_status(6, 1.50); // Unknown status code\n\n    // If we reach here without panicking, the test passes\n    assert!(true);\n}\n\n// New test for display_status with extreme values\n#[test]\nfn test_display_status_edge_cases() {\n    // Test with very small time\n    display_status(1, 0.0001);\n\n    // Test with zero time\n    display_status(1, 0.0);\n\n    // Test with large time\n    display_status(1, 99999.9999);\n\n    // Test negative status code (should be handled gracefully)\n    display_status(-1, 1.0);\n\n    // If we reach here without panicking, the test passes\n    assert!(true);\n}\n\n#[test]\nfn test_print_grid() {\n    // Similar to display_status, this mainly outputs to stdout\n    // We can test that it doesn't panic with various inputs\n\n    let rows = 20;\n    let cols = 20;\n    let mut grid = create_test_grid(rows, cols);\n\n    // Test different view windows\n    print_grid(1, 1, rows, cols, \u0026mut grid);\n    print_grid(5, 5, rows, cols, \u0026mut grid);\n    print_grid(rows, cols, rows, cols, \u0026mut grid); // Edge of grid\n\n    // Test with a small grid that's smaller than the view window\n    let small_rows = 5;\n    let small_cols = 5;\n    let mut small_grid = create_test_grid(small_rows, small_cols);\n    print_grid(1, 1, small_rows, small_cols, \u0026mut small_grid);\n\n    // If we reach here without panicking, the test passes\n    assert!(true);\n}\n\n// New test for print_grid with edge cases\n#[test]\nfn test_print_grid_edge_cases() {\n    let rows = 15;\n    let cols = 15;\n    let mut grid = create_test_grid(rows, cols);\n\n    // Test boundary conditions\n    print_grid(rows - 8, cols - 8, rows, cols, \u0026mut grid); // Near the edge\n    print_grid(rows, cols, rows, cols, \u0026mut grid); // At the edge\n\n    // Test with view window that would extend beyond grid boundaries\n    print_grid(rows - 5, cols - 5, rows, cols, \u0026mut grid);\n\n    // Test with single row/column visibility\n    print_grid(rows, 1, rows, cols, \u0026mut grid);\n    print_grid(1, cols, rows, cols, \u0026mut grid);\n\n    // Test with starting position at the exact boundary\n    print_grid(rows + 1, cols + 1, rows, cols, \u0026mut grid);\n\n    // If we reach here without panicking, the test passes\n    assert!(true);\n}\n\n// Test the output toggle functionality\n#[test]\nfn test_output_toggle() {\n    let rows = 20;\n    let cols = 20;\n    let mut grid = create_test_grid(rows, cols);\n    let mut start_x = 10;\n    let mut start_y = 10;\n    let mut is_disabled = false;\n\n    // Test initial state\n    assert!(!is_disabled);\n\n    // Test with your actual disable output command\n    // Replace with your actual syntax\n    let disable_output_cmd = \"output disable\";\n\n    let result = process_command(\n        disable_output_cmd,\n        \u0026mut start_x,\n        \u0026mut start_y,\n        rows,\n        cols,\n        \u0026mut is_disabled,\n        \u0026mut grid,\n    );\n\n    // If command is correctly parsed, check that is_disabled is now true\n    if result == 1 {\n        assert!(is_disabled);\n    }\n\n    // Test with your actual enable output command\n    // Replace with your actual syntax\n    let enable_output_cmd = \"output enable\";\n\n    let result = process_command(\n        enable_output_cmd,\n        \u0026mut start_x,\n        \u0026mut start_y,\n        rows,\n        cols,\n        \u0026mut is_disabled,\n        \u0026mut grid,\n    );\n\n    // If command is correctly parsed, check that is_disabled is now false\n    if result == 1 {\n        assert!(!is_disabled);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","yuvikachaudhary","Desktop","Semester 4","COP290","spreadsheet_rust","tests","types_terminal.rs"],"content":"use project::terminal::types::*;\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_coordinates_creation() {\n        let coord = Coordinates { row: 2, col: 3 };\n        assert_eq!(coord.row, 2);\n        assert_eq!(coord.col, 3);\n    }\n\n    #[test]\n    fn test_coordinates_display() {\n        let coord = Coordinates { row: 5, col: 7 };\n        let output = format!(\"{}\", coord);\n        assert_eq!(output, \"(5, 7)\");\n    }\n\n    #[test]\n    fn test_coordinates_equality() {\n        let coord1 = Coordinates { row: 1, col: 1 };\n        let coord2 = Coordinates { row: 1, col: 1 };\n        let coord3 = Coordinates { row: 0, col: 0 };\n\n        assert_eq!(coord1, coord2);\n        assert_ne!(coord1, coord3);\n    }\n\n    #[test]\n    fn test_coordinates_clone_and_copy() {\n        let coord1 = Coordinates { row: 10, col: 20 };\n        let coord2 = coord1; // Copy trait in action\n        let coord3 = coord1.clone(); // Clone trait\n\n        assert_eq!(coord1, coord2);\n        assert_eq!(coord1, coord3);\n    }\n\n    #[test]\n    fn test_coordinates_default() {\n        let coord = Coordinates::default();\n        assert_eq!(coord.row, 0);\n        assert_eq!(coord.col, 0);\n    }\n}\n","traces":[],"covered":0,"coverable":0}]};
        var previousData = {"files":[{"path":["/","Users","yuvikachaudhary","Desktop","Semester 4","COP290","spreadsheet_rust","src","extension","backend","backend.rs"],"content":"#![allow(dead_code)]\nuse std::fs;\nconst UNDO_LIMIT: usize = 1000;\nuse crate::extension::backend::functions::*;\nuse crate::extension::backend::graph::Node;\nuse crate::extension::backend::graph::get_sequence;\nuse crate::extension::backend::graph::has_cycle;\nuse crate::extension::backend::graph::update_edges;\nuse crate::extension::common::{Operation, Value};\nuse crate::extension::parser::*;\nuse serde::{Deserialize, Serialize};\n//init_backend(r,c) -\u003e generate a grid of all nodes : returns void\n//execute(value::cell, value::oper) -\u003e update_edges(Node, value::oper), hasCycle(Box\u003c\u003e, value::cell), get_sequence(Box\u003c\u003e, value::cell), update_grid(sequence) -\u003e return status\n//update_grid(sequence) -\u003e loop assign to Node = \u003cfunctions\u003e(Box\u003c\u003e, value::oper -\u003e return bool\n//process_command(r,c, string, value::Cell) -\u003e parser, execute(value::cell, value::oper): return status\n//get_value(value::cell): returns a cell_value\n/// Control Unit for data processing and updating values in Spreadsheeet.\n/// The `Grid` struct is designed to store and manage a grid of `Cell` objects.\n///Data structure to represent sheet\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct Grid {\n    rows: usize,\n    columns: usize,\n    pub cells_vec: Vec\u003cVec\u003cNode\u003e\u003e,\n}\n///Data structure to represent status of command\n#[derive(PartialEq, Debug)]\npub enum Status {\n    Success,\n    UnrecognizedCmd,\n    CircularDependency,\n    PrintEnabled,\n    PrintDisabled,\n    ScrollTo(usize, usize),\n    Up,\n    Down,\n    Left,\n    Right,\n    Quit,\n    Web(String),\n    WebStart,\n}\n\nimpl Grid {\n    ///Function to initialize grid. Arguments are size of grid.\n    pub fn new(rows: usize, columns: usize) -\u003e Self {\n        Grid {\n            rows,\n            columns,\n            cells_vec: vec![vec![Node::new(0); columns]; rows],\n        }\n    }\n    pub fn set_node(\u0026mut self, row: usize, col: usize, node: Node) {\n        self.cells_vec[row][col] = node;\n    }\n    pub fn get_row_size(\u0026self) -\u003e usize {\n        self.rows\n    }\n    pub fn get_column_size(\u0026self) -\u003e usize {\n        self.columns\n    }\n    pub fn get_node(\u0026mut self, row: usize, column: usize) -\u003e \u0026mut Node {\n        \u0026mut self.cells_vec[row][column]\n    }\n    pub fn get_node_value(\u0026self, row: usize, column: usize) -\u003e Option\u003cisize\u003e {\n        self.cells_vec[row][column].get_node_value()\n    }\n    // pub fn get_node_mut(\u0026mut self, row: usize, column: usize) -\u003e \u0026mut Node {\n    //     \u0026mut self.cells_vec[row][column]\n    // }\n}\n\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct Valgrid {\n    pub rows: usize,\n    pub columns: usize,\n    pub cells: Vec\u003cVec\u003cOption\u003cisize\u003e\u003e\u003e,\n}\n\n///Struct that contains data structure as well as methods\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct Backend {\n    pub grid: Grid,\n    undo_stack: Vec\u003cGrid\u003e,\n    redo_stack: Vec\u003cGrid\u003e,\n}\n\nimpl Backend {\n    ///Initializes Backend\n    pub fn init_backend(rows: usize, columns: usize) -\u003e Self {\n        Backend {\n            grid: Grid::new(rows + 1, columns + 1),\n            undo_stack: Vec::new(),\n            redo_stack: Vec::new(),\n        }\n    }\n    ///Returns the value of cell\n    pub fn get_node_value(\u0026self, cell: Value) -\u003e Option\u003cisize\u003e {\n        match cell {\n            Value::Cell(row, col) =\u003e self.grid.get_node_value(row, col),\n            _ =\u003e panic!(\"Expected a Cell value\"),\n        }\n    }\n    pub fn get_valgrid(\u0026self) -\u003e Valgrid {\n        Valgrid {\n            rows: self.grid.get_row_size(),\n            columns: self.grid.get_column_size(),\n            cells: self\n                .grid\n                .cells_vec\n                .iter()\n                .map(|row| {\n                    row.iter()\n                        .map(|cell| {\n                            if cell.valid {\n                                Some(cell.node_value)\n                            } else {\n                                None\n                            }\n                        })\n                        .collect()\n                })\n                .collect(),\n        }\n    }\n    ///Iterates over the sequence of topological sort and updates values\n    fn update_grid(\u0026mut self, sequence: Vec\u003cValue\u003e) {\n        for cell in sequence {\n            if let Some(Value::Oper(_box1, _box2, oper)) =\n                self.grid.get_node(cell.row(), cell.col()).function.clone()\n            {\n                match oper {\n                    Operation::Sum =\u003e {\n                        let sum = sum_function(\u0026mut self.grid, cell.row(), cell.col());\n                        match sum {\n                            Some(val) =\u003e {\n                                self.grid.cells_vec[cell.row()][cell.col()].node_value = val;\n                                self.grid.cells_vec[cell.row()][cell.col()].valid = true;\n                            }\n                            None =\u003e {\n                                self.grid.cells_vec[cell.row()][cell.col()].valid = false;\n                            }\n                        }\n                    }\n                    Operation::Min =\u003e {\n                        let min = min_function(\u0026mut self.grid, cell.row(), cell.col());\n                        match min {\n                            Some(val) =\u003e {\n                                self.grid.cells_vec[cell.row()][cell.col()].node_value = val;\n                                self.grid.cells_vec[cell.row()][cell.col()].valid = true;\n                            }\n                            None =\u003e {\n                                self.grid.cells_vec[cell.row()][cell.col()].valid = false;\n                            }\n                        }\n                    }\n                    Operation::Max =\u003e {\n                        let max = max_function(\u0026mut self.grid, cell.row(), cell.col());\n                        match max {\n                            Some(val) =\u003e {\n                                self.grid.cells_vec[cell.row()][cell.col()].node_value = val;\n                                self.grid.cells_vec[cell.row()][cell.col()].valid = true;\n                            }\n                            None =\u003e {\n                                self.grid.cells_vec[cell.row()][cell.col()].valid = false;\n                            }\n                        }\n                    }\n                    Operation::Avg =\u003e {\n                        let avg = avg_function(\u0026mut self.grid, cell.row(), cell.col());\n                        match avg {\n                            Some(val) =\u003e {\n                                self.grid.cells_vec[cell.row()][cell.col()].node_value = val;\n                                self.grid.cells_vec[cell.row()][cell.col()].valid = true;\n                            }\n                            None =\u003e {\n                                self.grid.cells_vec[cell.row()][cell.col()].valid = false;\n                            }\n                        }\n                    }\n                    Operation::Std =\u003e {\n                        let std_dev = std_dev_function(\u0026mut self.grid, cell.row(), cell.col());\n                        match std_dev {\n                            Some(val) =\u003e {\n                                self.grid.cells_vec[cell.row()][cell.col()].node_value = val;\n                                self.grid.cells_vec[cell.row()][cell.col()].valid = true;\n                            }\n                            None =\u003e {\n                                self.grid.cells_vec[cell.row()][cell.col()].valid = false;\n                            }\n                        }\n                    }\n                    Operation::Add =\u003e {\n                        let ans = add(\u0026mut self.grid, cell.row(), cell.col());\n                        match ans {\n                            Some(val) =\u003e {\n                                self.grid.cells_vec[cell.row()][cell.col()].node_value = val;\n                                self.grid.cells_vec[cell.row()][cell.col()].valid = true;\n                            }\n                            None =\u003e {\n                                self.grid.cells_vec[cell.row()][cell.col()].valid = false;\n                            }\n                        }\n                    }\n                    Operation::Sub =\u003e {\n                        let ans = sub(\u0026mut self.grid, cell.row(), cell.col());\n                        match ans {\n                            Some(val) =\u003e {\n                                self.grid.cells_vec[cell.row()][cell.col()].node_value = val;\n                                self.grid.cells_vec[cell.row()][cell.col()].valid = true;\n                            }\n                            None =\u003e {\n                                self.grid.cells_vec[cell.row()][cell.col()].valid = false;\n                            }\n                        }\n                    }\n                    Operation::Mul =\u003e {\n                        let ans = mul(\u0026mut self.grid, cell.row(), cell.col());\n                        match ans {\n                            Some(val) =\u003e {\n                                self.grid.cells_vec[cell.row()][cell.col()].node_value = val;\n                                self.grid.cells_vec[cell.row()][cell.col()].valid = true;\n                            }\n                            None =\u003e {\n                                self.grid.cells_vec[cell.row()][cell.col()].valid = false;\n                            }\n                        }\n                    }\n                    Operation::Div =\u003e {\n                        let ans = div(\u0026mut self.grid, cell.row(), cell.col());\n                        match ans {\n                            Some(val) =\u003e {\n                                self.grid.cells_vec[cell.row()][cell.col()].node_value = val;\n                                self.grid.cells_vec[cell.row()][cell.col()].valid = true;\n                            }\n                            None =\u003e {\n                                self.grid.cells_vec[cell.row()][cell.col()].valid = false;\n                            }\n                        }\n                    }\n                    Operation::Slp =\u003e {\n                        let ans = slp(\u0026mut self.grid, cell.row(), cell.col());\n                        match ans {\n                            Some(val) =\u003e {\n                                self.grid.cells_vec[cell.row()][cell.col()].node_value = val;\n                                self.grid.cells_vec[cell.row()][cell.col()].valid = true;\n                            }\n                            None =\u003e {\n                                self.grid.cells_vec[cell.row()][cell.col()].valid = false;\n                            }\n                        }\n                    }\n                    Operation::Cons =\u003e {\n                        let ans = cons(\u0026mut self.grid, cell.row(), cell.col());\n                        match ans {\n                            Some(val) =\u003e {\n                                self.grid.cells_vec[cell.row()][cell.col()].node_value = val;\n                                self.grid.cells_vec[cell.row()][cell.col()].valid = true;\n                            }\n                            None =\u003e {\n                                self.grid.cells_vec[cell.row()][cell.col()].valid = false;\n                            }\n                        }\n                    }\n                    _ =\u003e {\n                        // Handle other operations if needed\n                    }\n                }\n            }\n        }\n    }\n\n    ///Checks for cycles and accordingly updates dependencies\n    fn execute(\u0026mut self, cell: Value, func: Option\u003cValue\u003e) -\u003e Status {\n        //I want that if func has first and second box as value::const type, then just update graph and evaluate expression by sending Operation as well\n        if let Some(Value::Oper(Some(box1), Some(box2), _oper)) = func.clone() {\n            if let (Value::Const(_val1), Value::Const(_val2)) = (*box1, *box2) {\n                update_edges(\u0026mut self.grid, cell.clone(), func.clone(), true); //debug check //add break edges\n                // change cell's parameters here\n                let node = self.grid.get_node(cell.row(), cell.col());\n                node.function = func.clone();\n                let sequence = get_sequence(\u0026mut self.grid, cell.clone());\n                self.update_grid(sequence.clone());\n            } else {\n                update_edges(\u0026mut self.grid, cell.clone(), func.clone(), true);\n                if has_cycle(\u0026mut self.grid, cell.clone()) {\n                    update_edges(\u0026mut self.grid, cell.clone(), func.clone(), false);\n                    return Status::CircularDependency;\n                }\n                // change cell's parameters here\n                let node = self.grid.get_node(cell.row(), cell.col());\n                node.function = func.clone();\n                let sequence = get_sequence(\u0026mut self.grid, cell.clone());\n                self.update_grid(sequence.clone());\n            }\n        }\n        Status::Success\n    }\n    ///Takes command from frontend, calls the Parser, and sends the decoded command to execute function\n    pub fn process_command(\u0026mut self, rows: usize, columns: usize, cmd: String) -\u003e Status {\n        match parser::validate(\u0026cmd, \u0026columns, \u0026rows) {\n            Some((None, Some(Value::Oper(None, None, op)))) =\u003e match op {\n                Operation::EnableOutput =\u003e Status::PrintEnabled,\n                Operation::DisableOutput =\u003e Status::PrintDisabled,\n                Operation::Left =\u003e Status::Left,\n                Operation::Right =\u003e Status::Right,\n                Operation::Up =\u003e Status::Up,\n                Operation::Down =\u003e Status::Down,\n                Operation::Quit =\u003e Status::Quit,\n                Operation::Web(path) =\u003e Status::Web(path),\n                Operation::WebStart =\u003e Status::WebStart,\n                Operation::Save(path) =\u003e {\n                    if self.serial(\u0026path).is_err() {\n                        return Status::UnrecognizedCmd;\n                    }\n                    Status::Success\n                }\n                Operation::Undo =\u003e {\n                    if let Some(prev_grid) = self.undo_stack.pop() {\n                        self.redo_stack.push(self.grid.clone());\n                        self.grid = prev_grid;\n                        Status::Success\n                    } else {\n                        Status::UnrecognizedCmd\n                    }\n                }\n                Operation::Redo =\u003e {\n                    if let Some(next_grid) = self.redo_stack.pop() {\n                        self.undo_stack.push(self.grid.clone());\n                        if self.undo_stack.len() \u003e UNDO_LIMIT {\n                            self.undo_stack.remove(0); // drop oldest\n                        }\n                        self.grid = next_grid;\n                        Status::Success\n                    } else {\n                        Status::UnrecognizedCmd\n                    }\n                }\n                _ =\u003e Status::UnrecognizedCmd,\n            },\n            Some((\n                Some(Value::Cell(col, row)),\n                Some(Value::Oper(None, None, Operation::ScrollTo)),\n            )) =\u003e Status::ScrollTo(col, row),\n            Some((Some(Value::Cell(col, row)), Some(Value::Oper(box1, box2, op)))) =\u003e {\n                // change here\n                // either have to change parser or change the inside parts of box1 and box2\n                self.undo_stack.push(self.grid.clone());\n                if self.undo_stack.len() \u003e UNDO_LIMIT {\n                    self.undo_stack.remove(0);\n                }\n                self.redo_stack.clear(); // clear redo stack on new action\n                self.execute(Value::Cell(col, row), Some(Value::Oper(box1, box2, op)))\n            }\n            _ =\u003e Status::UnrecognizedCmd,\n        }\n    }\n\n    pub fn get_grid(\u0026self) -\u003e \u0026Grid {\n        \u0026self.grid\n    }\n\n    pub fn serial(\u0026self, path: \u0026str) -\u003e Result\u003c(), String\u003e {\n        let json = serde_json::to_string_pretty(self)\n            .map_err(|e| format!(\"Serialization error: {}\", e))?;\n        std::fs::write(path, json).map_err(|e| format!(\"File write error: {}\", e))\n    }\n\n    pub fn deserial(path: \u0026str) -\u003e Result\u003cSelf, String\u003e {\n        let json = fs::read_to_string(path).map_err(|e| format!(\"File read error: {}\", e))?;\n        serde_json::from_str(\u0026json).map_err(|e| format!(\"Deserialization error: {}\", e))\n    }\n\n    pub fn deserial_text(text: String) -\u003e Result\u003cSelf, String\u003e {\n        serde_json::from_str(\u0026text).map_err(|e| format!(\"Deserialization error: {}\", e))\n    }\n}\n","traces":[{"line":46,"address":[],"length":0,"stats":{"Line":85}},{"line":50,"address":[],"length":0,"stats":{"Line":85}},{"line":53,"address":[],"length":0,"stats":{"Line":1369}},{"line":54,"address":[],"length":0,"stats":{"Line":1369}},{"line":56,"address":[],"length":0,"stats":{"Line":6}},{"line":57,"address":[],"length":0,"stats":{"Line":6}},{"line":59,"address":[],"length":0,"stats":{"Line":6}},{"line":60,"address":[],"length":0,"stats":{"Line":6}},{"line":62,"address":[],"length":0,"stats":{"Line":906}},{"line":63,"address":[],"length":0,"stats":{"Line":906}},{"line":65,"address":[],"length":0,"stats":{"Line":1424}},{"line":66,"address":[],"length":0,"stats":{"Line":1424}},{"line":90,"address":[],"length":0,"stats":{"Line":31}},{"line":92,"address":[],"length":0,"stats":{"Line":31}},{"line":93,"address":[],"length":0,"stats":{"Line":31}},{"line":94,"address":[],"length":0,"stats":{"Line":31}},{"line":98,"address":[],"length":0,"stats":{"Line":24}},{"line":99,"address":[],"length":0,"stats":{"Line":24}},{"line":100,"address":[],"length":0,"stats":{"Line":23}},{"line":101,"address":[],"length":0,"stats":{"Line":1}},{"line":104,"address":[],"length":0,"stats":{"Line":1}},{"line":106,"address":[],"length":0,"stats":{"Line":1}},{"line":107,"address":[],"length":0,"stats":{"Line":1}},{"line":108,"address":[],"length":0,"stats":{"Line":1}},{"line":127,"address":[],"length":0,"stats":{"Line":56}},{"line":128,"address":[],"length":0,"stats":{"Line":168}},{"line":129,"address":[],"length":0,"stats":{"Line":56}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":56}},{"line":134,"address":[],"length":0,"stats":{"Line":2}},{"line":135,"address":[],"length":0,"stats":{"Line":2}},{"line":136,"address":[],"length":0,"stats":{"Line":1}},{"line":137,"address":[],"length":0,"stats":{"Line":1}},{"line":138,"address":[],"length":0,"stats":{"Line":1}},{"line":140,"address":[],"length":0,"stats":{"Line":1}},{"line":141,"address":[],"length":0,"stats":{"Line":1}},{"line":146,"address":[],"length":0,"stats":{"Line":1}},{"line":147,"address":[],"length":0,"stats":{"Line":1}},{"line":148,"address":[],"length":0,"stats":{"Line":1}},{"line":149,"address":[],"length":0,"stats":{"Line":1}},{"line":150,"address":[],"length":0,"stats":{"Line":1}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":1}},{"line":159,"address":[],"length":0,"stats":{"Line":1}},{"line":160,"address":[],"length":0,"stats":{"Line":1}},{"line":161,"address":[],"length":0,"stats":{"Line":1}},{"line":162,"address":[],"length":0,"stats":{"Line":1}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":2}},{"line":171,"address":[],"length":0,"stats":{"Line":2}},{"line":172,"address":[],"length":0,"stats":{"Line":1}},{"line":173,"address":[],"length":0,"stats":{"Line":1}},{"line":174,"address":[],"length":0,"stats":{"Line":1}},{"line":176,"address":[],"length":0,"stats":{"Line":1}},{"line":177,"address":[],"length":0,"stats":{"Line":1}},{"line":182,"address":[],"length":0,"stats":{"Line":2}},{"line":183,"address":[],"length":0,"stats":{"Line":2}},{"line":184,"address":[],"length":0,"stats":{"Line":1}},{"line":185,"address":[],"length":0,"stats":{"Line":1}},{"line":186,"address":[],"length":0,"stats":{"Line":1}},{"line":188,"address":[],"length":0,"stats":{"Line":1}},{"line":189,"address":[],"length":0,"stats":{"Line":1}},{"line":194,"address":[],"length":0,"stats":{"Line":3}},{"line":195,"address":[],"length":0,"stats":{"Line":3}},{"line":196,"address":[],"length":0,"stats":{"Line":2}},{"line":197,"address":[],"length":0,"stats":{"Line":2}},{"line":198,"address":[],"length":0,"stats":{"Line":2}},{"line":200,"address":[],"length":0,"stats":{"Line":1}},{"line":201,"address":[],"length":0,"stats":{"Line":1}},{"line":206,"address":[],"length":0,"stats":{"Line":2}},{"line":207,"address":[],"length":0,"stats":{"Line":2}},{"line":208,"address":[],"length":0,"stats":{"Line":1}},{"line":209,"address":[],"length":0,"stats":{"Line":1}},{"line":210,"address":[],"length":0,"stats":{"Line":1}},{"line":212,"address":[],"length":0,"stats":{"Line":1}},{"line":213,"address":[],"length":0,"stats":{"Line":1}},{"line":218,"address":[],"length":0,"stats":{"Line":2}},{"line":219,"address":[],"length":0,"stats":{"Line":2}},{"line":220,"address":[],"length":0,"stats":{"Line":1}},{"line":221,"address":[],"length":0,"stats":{"Line":1}},{"line":222,"address":[],"length":0,"stats":{"Line":1}},{"line":224,"address":[],"length":0,"stats":{"Line":1}},{"line":225,"address":[],"length":0,"stats":{"Line":1}},{"line":230,"address":[],"length":0,"stats":{"Line":2}},{"line":231,"address":[],"length":0,"stats":{"Line":2}},{"line":232,"address":[],"length":0,"stats":{"Line":1}},{"line":233,"address":[],"length":0,"stats":{"Line":1}},{"line":234,"address":[],"length":0,"stats":{"Line":1}},{"line":236,"address":[],"length":0,"stats":{"Line":1}},{"line":237,"address":[],"length":0,"stats":{"Line":1}},{"line":242,"address":[],"length":0,"stats":{"Line":2}},{"line":243,"address":[],"length":0,"stats":{"Line":2}},{"line":244,"address":[],"length":0,"stats":{"Line":1}},{"line":245,"address":[],"length":0,"stats":{"Line":1}},{"line":246,"address":[],"length":0,"stats":{"Line":1}},{"line":248,"address":[],"length":0,"stats":{"Line":1}},{"line":249,"address":[],"length":0,"stats":{"Line":1}},{"line":254,"address":[],"length":0,"stats":{"Line":37}},{"line":255,"address":[],"length":0,"stats":{"Line":37}},{"line":256,"address":[],"length":0,"stats":{"Line":37}},{"line":257,"address":[],"length":0,"stats":{"Line":37}},{"line":258,"address":[],"length":0,"stats":{"Line":37}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":57}},{"line":276,"address":[],"length":0,"stats":{"Line":114}},{"line":277,"address":[],"length":0,"stats":{"Line":131}},{"line":278,"address":[],"length":0,"stats":{"Line":37}},{"line":280,"address":[],"length":0,"stats":{"Line":37}},{"line":281,"address":[],"length":0,"stats":{"Line":37}},{"line":282,"address":[],"length":0,"stats":{"Line":37}},{"line":283,"address":[],"length":0,"stats":{"Line":37}},{"line":285,"address":[],"length":0,"stats":{"Line":20}},{"line":286,"address":[],"length":0,"stats":{"Line":20}},{"line":287,"address":[],"length":0,"stats":{"Line":1}},{"line":288,"address":[],"length":0,"stats":{"Line":1}},{"line":291,"address":[],"length":0,"stats":{"Line":19}},{"line":292,"address":[],"length":0,"stats":{"Line":19}},{"line":293,"address":[],"length":0,"stats":{"Line":19}},{"line":294,"address":[],"length":0,"stats":{"Line":19}},{"line":297,"address":[],"length":0,"stats":{"Line":56}},{"line":300,"address":[],"length":0,"stats":{"Line":61}},{"line":301,"address":[],"length":0,"stats":{"Line":61}},{"line":302,"address":[],"length":0,"stats":{"Line":2}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":2}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":2}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":57}},{"line":348,"address":[],"length":0,"stats":{"Line":57}},{"line":349,"address":[],"length":0,"stats":{"Line":57}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":2}},{"line":359,"address":[],"length":0,"stats":{"Line":1403}},{"line":360,"address":[],"length":0,"stats":{"Line":1403}},{"line":363,"address":[],"length":0,"stats":{"Line":1}},{"line":364,"address":[],"length":0,"stats":{"Line":2}},{"line":365,"address":[],"length":0,"stats":{"Line":2}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":2}},{"line":370,"address":[],"length":0,"stats":{"Line":6}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}}],"covered":132,"coverable":174},{"path":["/","Users","yuvikachaudhary","Desktop","Semester 4","COP290","spreadsheet_rust","src","extension","backend","functions.rs"],"content":"use crate::extension::backend::backend::Grid;\nuse crate::extension::common::*;\n\n/// Functions module for the spreadsheet extension backend.\n/// This provides the core computational functions used in cell formulas.\n/// Finds the maximum value in a range of cells.\n///\n/// # Arguments\n///\n/// * `grid` - A mutable reference to the spreadsheet grid containing all cells\n/// * `row` - The row index of the cell containing this function\n/// * `col` - The column index of the cell containing this function\n///\n/// # Returns\n///\n/// * `Some(isize)` - The maximum value found in the specified range if all cells are valid\n/// * `None` - If any cell in the range is invalid or has an error\n///\n/// # Details\n///\n/// Iterates through all cells in the range specified by the cell's function parameters\n/// (which should be Value::Cell coordinates for the top-left and bottom-right corners)\n/// and returns the maximum value. If any cell in the range is invalid, returns None.\npub fn max_function(grid: \u0026mut Grid, row: usize, col: usize) -\u003e Option\u003cisize\u003e {\n    let mut max_val = isize::MIN;\n    let node = grid.get_node(row, col);\n    if let Some(Value::Oper(Some(box1), Some(box2), _oper)) = node.function.clone() {\n        if let (Value::Cell(row1, col1), Value::Cell(row2, col2)) = (*box1, *box2) {\n            for i in row1..=row2 {\n                for j in col1..=col2 {\n                    let current_node = grid.get_node(i, j);\n                    if !current_node.valid {\n                        return None;\n                    } else if current_node.node_value \u003e max_val {\n                        max_val = current_node.node_value;\n                    }\n                }\n            }\n        }\n    }\n    Some(max_val)\n}\n\n/// Finds the minimum value in a range of cells.\n///\n/// # Arguments\n///\n/// * `grid` - A mutable reference to the spreadsheet grid containing all cells\n/// * `row` - The row index of the cell containing this function\n/// * `col` - The column index of the cell containing this function\n///\n/// # Returns\n///\n/// * `Some(isize)` - The minimum value found in the specified range if all cells are valid\n/// * `None` - If any cell in the range is invalid or has an error\n///\n/// # Details\n///\n/// Iterates through all cells in the range specified by the cell's function parameters\n/// (which should be Value::Cell coordinates for the top-left and bottom-right corners)\n/// and returns the minimum value. If any cell in the range is invalid, returns None.\npub fn min_function(grid: \u0026mut Grid, row: usize, col: usize) -\u003e Option\u003cisize\u003e {\n    let mut min_val = isize::MAX;\n    let node = grid.get_node(row, col);\n    if let Some(Value::Oper(Some(box1), Some(box2), _oper)) = node.function.clone() {\n        if let (Value::Cell(row1, col1), Value::Cell(row2, col2)) = (*box1, *box2) {\n            for i in row1..=row2 {\n                for j in col1..=col2 {\n                    let current_node = grid.get_node(i, j);\n                    if !current_node.valid {\n                        return None;\n                    } else if current_node.node_value \u003c min_val {\n                        min_val = current_node.node_value;\n                    }\n                }\n            }\n        }\n    }\n    Some(min_val)\n}\n\n/// Calculates the sum of all values in a range of cells.\n///\n/// # Arguments\n///\n/// * `grid` - A mutable reference to the spreadsheet grid containing all cells\n/// * `row` - The row index of the cell containing this function\n/// * `col` - The column index of the cell containing this function\n///\n/// # Returns\n///\n/// * `Some(isize)` - The sum of all values in the specified range if all cells are valid\n/// * `None` - If any cell in the range is invalid or has an error\n///\n/// # Details\n///\n/// Iterates through all cells in the range specified by the cell's function parameters\n/// (which should be Value::Cell coordinates for the top-left and bottom-right corners)\n/// and adds their values. If any cell in the range is invalid, returns None.\npub fn sum_function(grid: \u0026mut Grid, row: usize, col: usize) -\u003e Option\u003cisize\u003e {\n    let mut sum_val = 0;\n    let node = grid.get_node(row, col);\n    if let Some(Value::Oper(Some(box1), Some(box2), _oper)) = node.function.clone() {\n        if let (Value::Cell(row1, col1), Value::Cell(row2, col2)) = (*box1, *box2) {\n            for i in row1..=row2 {\n                for j in col1..=col2 {\n                    let current_node = grid.get_node(i, j);\n                    if !current_node.valid {\n                        return None;\n                    } else {\n                        sum_val += current_node.node_value;\n                    }\n                }\n            }\n        }\n    }\n    Some(sum_val)\n}\n\n/// Calculates the average (mean) of all values in a range of cells.\n///\n/// # Arguments\n///\n/// * `grid` - A mutable reference to the spreadsheet grid containing all cells\n/// * `row` - The row index of the cell containing this function\n/// * `col` - The column index of the cell containing this function\n///\n/// # Returns\n///\n/// * `Some(isize)` - The average of all values in the specified range if all cells are valid\n/// * `None` - If any cell in the range is invalid or if the range is empty\n///\n/// # Details\n///\n/// Iterates through all cells in the range, adds their values, and divides by the count.\n/// Returns None if any cell is invalid or if the range is empty (to prevent division by zero).\n/// The result is truncated to an integer (as it returns isize).\npub fn avg_function(grid: \u0026mut Grid, row: usize, col: usize) -\u003e Option\u003cisize\u003e {\n    let mut sum_val = 0;\n    let mut count = 0;\n    let node = grid.get_node(row, col);\n    if let Some(Value::Oper(Some(box1), Some(box2), _oper)) = node.function.clone() {\n        if let (Value::Cell(row1, col1), Value::Cell(row2, col2)) = (*box1, *box2) {\n            for i in row1..=row2 {\n                for j in col1..=col2 {\n                    let current_node = grid.get_node(i, j);\n                    if !current_node.valid {\n                        return None;\n                    }\n                    sum_val += current_node.node_value;\n                    count += 1;\n                }\n            }\n        }\n    }\n    if count == 0 {\n        None\n    } else {\n        Some(sum_val / count)\n    }\n}\n\n/// Calculates the standard deviation of values in a range of cells.\n///\n/// # Arguments\n///\n/// * `grid` - A mutable reference to the spreadsheet grid containing all cells\n/// * `row` - The row index of the cell containing this function\n/// * `col` - The column index of the cell containing this function\n///\n/// # Returns\n///\n/// * `Some(isize)` - The standard deviation of values in the specified range if all cells are valid\n/// * `None` - If any cell in the range is invalid or the calculation cannot be performed\n/// * `Some(0)` - If the range is empty\n///\n/// # Details\n///\n/// Uses a two-pass algorithm:\n/// 1. First pass: Calculate the mean of all values\n/// 2. Second pass: Calculate the sum of squared differences from the mean\n///\n/// Then divides the sum of squared differences by the count to get the variance,\n/// takes the square root, and rounds to the nearest integer.\npub fn std_dev_function(grid: \u0026mut Grid, row: usize, col: usize) -\u003e Option\u003cisize\u003e {\n    let node = grid.get_node(row, col);\n    if let Some(Value::Oper(Some(box1), Some(box2), _)) = node.function.clone() {\n        if let (Value::Cell(row1, col1), Value::Cell(row2, col2)) = (*box1, *box2) {\n            let mut sum = 0f64;\n            let mut count = 0;\n\n            // First pass: sum and count valid nodes\n            for i in row1..=row2 {\n                for j in col1..=col2 {\n                    let node_ref = grid.get_node(i, j);\n                    if node_ref.valid {\n                        sum += node_ref.node_value as f64;\n                        count += 1;\n                    } else {\n                        return None;\n                    }\n                }\n            }\n\n            if count == 0 {\n                return Some(0);\n            }\n\n            let mean = sum / count as f64;\n\n            // Second pass: compute variance\n            let mut variance = 0f64;\n            for i in row1..=row2 {\n                for j in col1..=col2 {\n                    let node_ref = grid.get_node(i, j);\n                    if !node_ref.valid {\n                        return None;\n                    }\n                    let val = node_ref.node_value as f64;\n                    variance += (val - mean) * (val - mean);\n                }\n            }\n\n            let stdev = (variance / count as f64).sqrt().round() as isize;\n            return Some(stdev);\n        }\n    }\n    None\n}\n\n/// Performs addition of two values.\n///\n/// # Arguments\n///\n/// * `grid` - A mutable reference to the spreadsheet grid containing all cells\n/// * `row` - The row index of the cell containing this function\n/// * `col` - The column index of the cell containing this function\n///\n/// # Returns\n///\n/// * `Some(isize)` - The result of adding the two values if both are valid\n/// * `None` - If either value is invalid or an error occurs\n///\n/// # Details\n///\n/// Extracts the two operands from the cell's function (which can be cell references or constants),\n/// verifies they are valid, and returns their sum.\npub fn add(grid: \u0026mut Grid, row: usize, col: usize) -\u003e Option\u003cisize\u003e {\n    let node = grid.get_node(row, col);\n    if let Some(Value::Oper(Some(box1), Some(box2), _oper)) = node.function.clone() {\n        let val1 = match *box1 {\n            Value::Cell(row, col) =\u003e {\n                let node = grid.get_node(row, col);\n                if !node.valid {\n                    return None;\n                }\n                node.node_value\n            }\n            Value::Const(c) =\u003e c,\n            _ =\u003e return None,\n        };\n\n        let val2 = match *box2 {\n            Value::Cell(row, col) =\u003e {\n                let node = grid.get_node(row, col);\n                if !node.valid {\n                    return None;\n                }\n                node.node_value\n            }\n            Value::Const(c) =\u003e c,\n            _ =\u003e return None,\n        };\n\n        Some(val1 + val2)\n    } else {\n        None\n    }\n}\n\n/// Performs subtraction of two values.\n///\n/// # Arguments\n///\n/// * `grid` - A mutable reference to the spreadsheet grid containing all cells\n/// * `row` - The row index of the cell containing this function\n/// * `col` - The column index of the cell containing this function\n///\n/// # Returns\n///\n/// * `Some(isize)` - The result of subtracting the second value from the first if both are valid\n/// * `None` - If either value is invalid or an error occurs\n///\n/// # Details\n///\n/// Extracts the two operands from the cell's function (which can be cell references or constants),\n/// verifies they are valid, and returns the result of subtracting the second from the first.\npub fn sub(grid: \u0026mut Grid, row: usize, col: usize) -\u003e Option\u003cisize\u003e {\n    let node = grid.get_node(row, col);\n    if let Some(Value::Oper(Some(box1), Some(box2), _oper)) = node.function.clone() {\n        let val1 = match *box1 {\n            Value::Cell(row, col) =\u003e {\n                let node = grid.get_node(row, col);\n                if !node.valid {\n                    return None;\n                }\n                node.node_value\n            }\n            Value::Const(c) =\u003e c,\n            _ =\u003e return None,\n        };\n\n        let val2 = match *box2 {\n            Value::Cell(row, col) =\u003e {\n                let node = grid.get_node(row, col);\n                if !node.valid {\n                    return None;\n                }\n                node.node_value\n            }\n            Value::Const(c) =\u003e c,\n            _ =\u003e return None,\n        };\n\n        Some(val1 - val2)\n    } else {\n        None\n    }\n}\n\n/// Performs multiplication of two values.\n///\n/// # Arguments\n///\n/// * `grid` - A mutable reference to the spreadsheet grid containing all cells\n/// * `row` - The row index of the cell containing this function\n/// * `col` - The column index of the cell containing this function\n///\n/// # Returns\n///\n/// * `Some(isize)` - The result of multiplying the two values if both are valid\n/// * `None` - If either value is invalid or an error occurs\n///\n/// # Details\n///\n/// Extracts the two operands from the cell's function (which can be cell references or constants),\n/// verifies they are valid, and returns their product.\npub fn mul(grid: \u0026mut Grid, row: usize, col: usize) -\u003e Option\u003cisize\u003e {\n    let node = grid.get_node(row, col);\n    if let Some(Value::Oper(Some(box1), Some(box2), _oper)) = node.function.clone() {\n        let val1 = match *box1 {\n            Value::Cell(row, col) =\u003e {\n                let node = grid.get_node(row, col);\n                if !node.valid {\n                    return None;\n                }\n                node.node_value\n            }\n            Value::Const(c) =\u003e c,\n            _ =\u003e return None,\n        };\n\n        let val2 = match *box2 {\n            Value::Cell(row, col) =\u003e {\n                let node = grid.get_node(row, col);\n                if !node.valid {\n                    return None;\n                }\n                node.node_value\n            }\n            Value::Const(c) =\u003e c,\n            _ =\u003e return None,\n        };\n\n        Some(val1 * val2)\n    } else {\n        None\n    }\n}\n\n/// Performs division of two values.\n///\n/// # Arguments\n///\n/// * `grid` - A mutable reference to the spreadsheet grid containing all cells\n/// * `row` - The row index of the cell containing this function\n/// * `col` - The column index of the cell containing this function\n///\n/// # Returns\n///\n/// * `Some(isize)` - The result of dividing the first value by the second if both are valid\n/// * `None` - If either value is invalid, the divisor is zero, or another error occurs\n///\n/// # Details\n///\n/// Extracts the two operands from the cell's function (which can be cell references or constants),\n/// verifies they are valid, checks that the divisor is not zero, and returns the result of\n/// dividing the first value by the second.\npub fn div(grid: \u0026mut Grid, row: usize, col: usize) -\u003e Option\u003cisize\u003e {\n    let node = grid.get_node(row, col);\n    if let Some(Value::Oper(Some(box1), Some(box2), _oper)) = node.function.clone() {\n        let val1 = match *box1 {\n            Value::Cell(row, col) =\u003e {\n                let node = grid.get_node(row, col);\n                if !node.valid {\n                    return None;\n                }\n                node.node_value\n            }\n            Value::Const(c) =\u003e c,\n            _ =\u003e return None,\n        };\n\n        let val2 = match *box2 {\n            Value::Cell(row, col) =\u003e {\n                let node = grid.get_node(row, col);\n                if !node.valid {\n                    return None;\n                }\n                node.node_value\n            }\n            Value::Const(c) =\u003e c,\n            _ =\u003e return None,\n        };\n\n        if val2 != 0 {\n            Some(val1 / val2)\n        } else {\n            None // only this case possible\n        }\n    } else {\n        None\n    }\n}\n\n/// Performs a sleep operation, pausing execution for a specified number of seconds.\n///\n/// # Arguments\n///\n/// * `grid` - A mutable reference to the spreadsheet grid containing all cells\n/// * `row` - The row index of the cell containing this function\n/// * `col` - The column index of the cell containing this function\n///\n/// # Returns\n///\n/// * `Some(isize)` - The value that was slept for (in seconds) if valid\n/// * `None` - If the sleep value is invalid or an error occurs\n///\n/// # Details\n///\n/// Extracts the sleep duration from the cell's function (which can be a cell reference or constant),\n/// verifies it is valid, sleeps for that many seconds, and then returns the same value.\npub fn slp(grid: \u0026mut Grid, row: usize, col: usize) -\u003e Option\u003cisize\u003e {\n    let node = grid.get_node(row, col);\n    if let Some(Value::Oper(Some(box1), Some(_box2), _oper)) = node.function.clone() {\n        // check value1\n        let val1 = match *box1 {\n            Value::Cell(row, col) =\u003e {\n                let node = grid.get_node(row, col);\n                if !node.valid {\n                    return None;\n                }\n                node.node_value\n            }\n            Value::Const(c) =\u003e c,\n            _ =\u003e return None,\n        };\n        // sleep for that amount of time\n        std::thread::sleep(std::time::Duration::from_secs(val1 as u64));\n        // return value to be set to the cell\n        Some(val1)\n    } else {\n        None\n    }\n}\n\n/// Sets a constant value in a cell.\n///\n/// # Arguments\n///\n/// * `grid` - A mutable reference to the spreadsheet grid containing all cells\n/// * `row` - The row index of the cell containing this function\n/// * `col` - The column index of the cell containing this function\n///\n/// # Returns\n///\n/// * `Some(isize)` - The constant value if valid\n/// * `None` - If the value is invalid or an error occurs\n///\n/// # Details\n///\n/// Extracts the constant value from the cell's function (which can be a cell reference or constant),\n/// verifies it is valid, and returns the value to be assigned to the cell.\npub fn cons(grid: \u0026mut Grid, row: usize, col: usize) -\u003e Option\u003cisize\u003e {\n    // let sleep_time = 0;\n    // sleep_time\n    let node = grid.get_node(row, col);\n    if let Some(Value::Oper(Some(box1), Some(_box2), _oper)) = node.function.clone() {\n        // check value1\n        let val1 = match *box1 {\n            Value::Cell(row, col) =\u003e {\n                let node = grid.get_node(row, col);\n                if !node.valid {\n                    return None;\n                }\n                node.node_value\n            }\n            Value::Const(c) =\u003e c,\n            _ =\u003e return None,\n        };\n        // return value to be set to the cell\n        Some(val1)\n    } else {\n        None\n    }\n}\n// slp and cons -\u003e left\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":5}},{"line":25,"address":[],"length":0,"stats":{"Line":5}},{"line":26,"address":[],"length":0,"stats":{"Line":5}},{"line":27,"address":[],"length":0,"stats":{"Line":9}},{"line":28,"address":[],"length":0,"stats":{"Line":8}},{"line":29,"address":[],"length":0,"stats":{"Line":13}},{"line":30,"address":[],"length":0,"stats":{"Line":27}},{"line":31,"address":[],"length":0,"stats":{"Line":18}},{"line":32,"address":[],"length":0,"stats":{"Line":18}},{"line":33,"address":[],"length":0,"stats":{"Line":1}},{"line":34,"address":[],"length":0,"stats":{"Line":33}},{"line":35,"address":[],"length":0,"stats":{"Line":16}},{"line":41,"address":[],"length":0,"stats":{"Line":4}},{"line":62,"address":[],"length":0,"stats":{"Line":4}},{"line":63,"address":[],"length":0,"stats":{"Line":4}},{"line":64,"address":[],"length":0,"stats":{"Line":4}},{"line":65,"address":[],"length":0,"stats":{"Line":8}},{"line":66,"address":[],"length":0,"stats":{"Line":8}},{"line":67,"address":[],"length":0,"stats":{"Line":13}},{"line":68,"address":[],"length":0,"stats":{"Line":27}},{"line":69,"address":[],"length":0,"stats":{"Line":18}},{"line":70,"address":[],"length":0,"stats":{"Line":18}},{"line":71,"address":[],"length":0,"stats":{"Line":1}},{"line":72,"address":[],"length":0,"stats":{"Line":21}},{"line":73,"address":[],"length":0,"stats":{"Line":4}},{"line":79,"address":[],"length":0,"stats":{"Line":3}},{"line":100,"address":[],"length":0,"stats":{"Line":5}},{"line":101,"address":[],"length":0,"stats":{"Line":5}},{"line":102,"address":[],"length":0,"stats":{"Line":5}},{"line":103,"address":[],"length":0,"stats":{"Line":10}},{"line":104,"address":[],"length":0,"stats":{"Line":10}},{"line":105,"address":[],"length":0,"stats":{"Line":14}},{"line":106,"address":[],"length":0,"stats":{"Line":27}},{"line":107,"address":[],"length":0,"stats":{"Line":18}},{"line":108,"address":[],"length":0,"stats":{"Line":18}},{"line":109,"address":[],"length":0,"stats":{"Line":2}},{"line":111,"address":[],"length":0,"stats":{"Line":16}},{"line":117,"address":[],"length":0,"stats":{"Line":3}},{"line":138,"address":[],"length":0,"stats":{"Line":5}},{"line":139,"address":[],"length":0,"stats":{"Line":5}},{"line":140,"address":[],"length":0,"stats":{"Line":5}},{"line":141,"address":[],"length":0,"stats":{"Line":5}},{"line":142,"address":[],"length":0,"stats":{"Line":10}},{"line":143,"address":[],"length":0,"stats":{"Line":10}},{"line":144,"address":[],"length":0,"stats":{"Line":14}},{"line":145,"address":[],"length":0,"stats":{"Line":27}},{"line":146,"address":[],"length":0,"stats":{"Line":18}},{"line":147,"address":[],"length":0,"stats":{"Line":18}},{"line":148,"address":[],"length":0,"stats":{"Line":2}},{"line":150,"address":[],"length":0,"stats":{"Line":16}},{"line":151,"address":[],"length":0,"stats":{"Line":16}},{"line":156,"address":[],"length":0,"stats":{"Line":3}},{"line":157,"address":[],"length":0,"stats":{"Line":1}},{"line":159,"address":[],"length":0,"stats":{"Line":2}},{"line":185,"address":[],"length":0,"stats":{"Line":5}},{"line":186,"address":[],"length":0,"stats":{"Line":5}},{"line":187,"address":[],"length":0,"stats":{"Line":10}},{"line":188,"address":[],"length":0,"stats":{"Line":10}},{"line":189,"address":[],"length":0,"stats":{"Line":5}},{"line":190,"address":[],"length":0,"stats":{"Line":5}},{"line":193,"address":[],"length":0,"stats":{"Line":14}},{"line":194,"address":[],"length":0,"stats":{"Line":27}},{"line":195,"address":[],"length":0,"stats":{"Line":18}},{"line":196,"address":[],"length":0,"stats":{"Line":34}},{"line":197,"address":[],"length":0,"stats":{"Line":16}},{"line":198,"address":[],"length":0,"stats":{"Line":16}},{"line":200,"address":[],"length":0,"stats":{"Line":2}},{"line":205,"address":[],"length":0,"stats":{"Line":3}},{"line":206,"address":[],"length":0,"stats":{"Line":1}},{"line":209,"address":[],"length":0,"stats":{"Line":2}},{"line":212,"address":[],"length":0,"stats":{"Line":2}},{"line":213,"address":[],"length":0,"stats":{"Line":6}},{"line":214,"address":[],"length":0,"stats":{"Line":18}},{"line":215,"address":[],"length":0,"stats":{"Line":12}},{"line":216,"address":[],"length":0,"stats":{"Line":12}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":12}},{"line":220,"address":[],"length":0,"stats":{"Line":12}},{"line":224,"address":[],"length":0,"stats":{"Line":2}},{"line":225,"address":[],"length":0,"stats":{"Line":2}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":12}},{"line":249,"address":[],"length":0,"stats":{"Line":12}},{"line":250,"address":[],"length":0,"stats":{"Line":20}},{"line":251,"address":[],"length":0,"stats":{"Line":13}},{"line":252,"address":[],"length":0,"stats":{"Line":6}},{"line":253,"address":[],"length":0,"stats":{"Line":6}},{"line":254,"address":[],"length":0,"stats":{"Line":6}},{"line":255,"address":[],"length":0,"stats":{"Line":2}},{"line":257,"address":[],"length":0,"stats":{"Line":4}},{"line":259,"address":[],"length":0,"stats":{"Line":1}},{"line":260,"address":[],"length":0,"stats":{"Line":1}},{"line":263,"address":[],"length":0,"stats":{"Line":5}},{"line":264,"address":[],"length":0,"stats":{"Line":2}},{"line":265,"address":[],"length":0,"stats":{"Line":2}},{"line":266,"address":[],"length":0,"stats":{"Line":2}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":2}},{"line":271,"address":[],"length":0,"stats":{"Line":3}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":4}},{"line":298,"address":[],"length":0,"stats":{"Line":6}},{"line":299,"address":[],"length":0,"stats":{"Line":6}},{"line":300,"address":[],"length":0,"stats":{"Line":12}},{"line":301,"address":[],"length":0,"stats":{"Line":12}},{"line":302,"address":[],"length":0,"stats":{"Line":5}},{"line":303,"address":[],"length":0,"stats":{"Line":5}},{"line":304,"address":[],"length":0,"stats":{"Line":5}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":5}},{"line":309,"address":[],"length":0,"stats":{"Line":1}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":4}},{"line":314,"address":[],"length":0,"stats":{"Line":4}},{"line":315,"address":[],"length":0,"stats":{"Line":4}},{"line":316,"address":[],"length":0,"stats":{"Line":4}},{"line":317,"address":[],"length":0,"stats":{"Line":2}},{"line":319,"address":[],"length":0,"stats":{"Line":2}},{"line":321,"address":[],"length":0,"stats":{"Line":2}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":6}},{"line":349,"address":[],"length":0,"stats":{"Line":6}},{"line":350,"address":[],"length":0,"stats":{"Line":12}},{"line":351,"address":[],"length":0,"stats":{"Line":10}},{"line":352,"address":[],"length":0,"stats":{"Line":5}},{"line":353,"address":[],"length":0,"stats":{"Line":5}},{"line":354,"address":[],"length":0,"stats":{"Line":5}},{"line":355,"address":[],"length":0,"stats":{"Line":2}},{"line":357,"address":[],"length":0,"stats":{"Line":3}},{"line":359,"address":[],"length":0,"stats":{"Line":1}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":4}},{"line":364,"address":[],"length":0,"stats":{"Line":2}},{"line":365,"address":[],"length":0,"stats":{"Line":2}},{"line":366,"address":[],"length":0,"stats":{"Line":2}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":2}},{"line":371,"address":[],"length":0,"stats":{"Line":2}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":7}},{"line":400,"address":[],"length":0,"stats":{"Line":7}},{"line":401,"address":[],"length":0,"stats":{"Line":14}},{"line":402,"address":[],"length":0,"stats":{"Line":14}},{"line":403,"address":[],"length":0,"stats":{"Line":6}},{"line":404,"address":[],"length":0,"stats":{"Line":6}},{"line":405,"address":[],"length":0,"stats":{"Line":6}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":6}},{"line":410,"address":[],"length":0,"stats":{"Line":1}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":5}},{"line":415,"address":[],"length":0,"stats":{"Line":4}},{"line":416,"address":[],"length":0,"stats":{"Line":4}},{"line":417,"address":[],"length":0,"stats":{"Line":4}},{"line":418,"address":[],"length":0,"stats":{"Line":2}},{"line":420,"address":[],"length":0,"stats":{"Line":2}},{"line":422,"address":[],"length":0,"stats":{"Line":3}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":4}},{"line":429,"address":[],"length":0,"stats":{"Line":1}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":453,"address":[],"length":0,"stats":{"Line":5}},{"line":454,"address":[],"length":0,"stats":{"Line":5}},{"line":455,"address":[],"length":0,"stats":{"Line":10}},{"line":457,"address":[],"length":0,"stats":{"Line":8}},{"line":458,"address":[],"length":0,"stats":{"Line":4}},{"line":459,"address":[],"length":0,"stats":{"Line":4}},{"line":460,"address":[],"length":0,"stats":{"Line":4}},{"line":461,"address":[],"length":0,"stats":{"Line":2}},{"line":463,"address":[],"length":0,"stats":{"Line":2}},{"line":465,"address":[],"length":0,"stats":{"Line":1}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":471,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":494,"address":[],"length":0,"stats":{"Line":40}},{"line":497,"address":[],"length":0,"stats":{"Line":40}},{"line":498,"address":[],"length":0,"stats":{"Line":80}},{"line":500,"address":[],"length":0,"stats":{"Line":79}},{"line":501,"address":[],"length":0,"stats":{"Line":2}},{"line":502,"address":[],"length":0,"stats":{"Line":2}},{"line":503,"address":[],"length":0,"stats":{"Line":2}},{"line":504,"address":[],"length":0,"stats":{"Line":1}},{"line":506,"address":[],"length":0,"stats":{"Line":1}},{"line":508,"address":[],"length":0,"stats":{"Line":38}},{"line":509,"address":[],"length":0,"stats":{"Line":0}},{"line":512,"address":[],"length":0,"stats":{"Line":0}},{"line":514,"address":[],"length":0,"stats":{"Line":0}}],"covered":167,"coverable":194},{"path":["/","Users","yuvikachaudhary","Desktop","Semester 4","COP290","spreadsheet_rust","src","extension","backend","graph.rs"],"content":"#![allow(dead_code)]\n//topo sort\n//node\n//adding\n//breaking\n//cycle\n//reset\nuse crate::extension::backend::backend::Grid;\nuse crate::extension::common::Operation;\nuse crate::extension::common::Value;\nuse serde::{Deserialize, Serialize};\n///Data structure for strong data of each cell\n/// Contains Dependency list, value, function and a few booleans\n/// `Node` struct represents a cell in the spreadsheet with its dependencies\n///\n/// Stores the cell's value, function, and dependency information\n///\n/// # Fields\n///\n/// * `dependents` - Vector of cells that depend on this cell\n/// * `node_value` - Current value of the cell\n/// * `function` - Function/operation assigned to this cell\n/// * `visited` - Flag used during graph traversal algorithms\n/// * `valid` - Flag indicating whether the cell value is valid\n\n#[derive(Serialize, Deserialize, Debug, Clone)]\n//clone trait used due to vec![vec![Cell::new(0); columns]; rows]\npub struct Node {\n    pub dependents: Vec\u003cValue\u003e,\n    pub node_value: isize,\n    pub function: Option\u003cValue\u003e,\n    pub visited: bool,\n    pub valid: bool,\n}\n\nimpl Node {\n    ///Initialises a Node\n    pub fn new(val: isize) -\u003e Self {\n        Node {\n            dependents: Vec::new(),\n            node_value: val,\n            function: None,\n            visited: false,\n            valid: true,\n        }\n    }\n    pub fn get_node_value(\u0026self) -\u003e Option\u003cisize\u003e {\n        if self.valid {\n            Some(self.node_value)\n        } else {\n            None\n        }\n    }\n    pub fn remove_dep(\u0026mut self, cell: Value) {\n        self.dependents.retain(|x| x != \u0026cell);\n    }\n    pub fn add_dep(\u0026mut self, cell: Value) {\n        if !self.dependents.contains(\u0026cell) {\n            self.dependents.push(cell);\n        }\n    }\n    pub fn set_dependents(\u0026mut self, dependents: Vec\u003cValue\u003e) {\n        self.dependents = dependents;\n    }\n}\n\n// update_edges\n// has_cycle\n// get_sequence\n\n// flag -\u003e true: break previous dependencies\n/// Function to break edges concerned with target cell in the graph depending on flag\npub fn break_edges(grid: \u0026mut Grid, target: Value, func: Option\u003cValue\u003e, flag: bool) {\n    // break edges\n    let old_func: Option\u003cValue\u003e = if flag {\n        // break old dependencies (stored in grid)\n        grid.get_node(target.row(), target.col()).function.clone()\n    } else {\n        func\n    };\n    if let Some(Value::Oper(box1, box2, oper)) = old_func {\n        match oper {\n            Operation::Sum | Operation::Avg | Operation::Max | Operation::Min =\u003e {\n                if let Some(Value::Cell(row1, col1)) = box1.as_deref() {\n                    if let Some(Value::Cell(row2, col2)) = box2.as_deref() {\n                        for i in *row1..=*row2 {\n                            for j in *col1..=*col2 {\n                                let node = grid.get_node(i, j);\n                                node.remove_dep(target.clone());\n                            }\n                        }\n                    }\n                }\n            }\n            Operation::Add | Operation::Sub | Operation::Mul | Operation::Div =\u003e {\n                if let Some(boxed_val) = box1 {\n                    if let Value::Cell(row1, col1) = \u0026*boxed_val {\n                        let node1 = grid.get_node(*row1, *col1);\n                        node1.remove_dep(target.clone());\n                    }\n                }\n                if let Some(boxed_val) = box2 {\n                    if let Value::Cell(row1, col1) = \u0026*boxed_val {\n                        let node1 = grid.get_node(*row1, *col1);\n                        node1.remove_dep(target.clone());\n                    }\n                }\n            }\n            Operation::Cons | Operation::Slp =\u003e {\n                // C\n                if let Some(Value::Cell(row1, col1)) = box1.as_deref() {\n                    let node1 = grid.get_node(*row1, *col1);\n                    node1.remove_dep(target.clone());\n                }\n                // V -\u003e do nothing\n            }\n            _ =\u003e {}\n        }\n    }\n}\n\n// flag -\u003e true: add new dependencies\n/// Function to add edges concerned with target cell in the graph depending on flag\npub fn add_edges(grid: \u0026mut Grid, target: Value, func: Option\u003cValue\u003e, flag: bool) {\n    // add edges\n    let old_func: Option\u003cValue\u003e = if flag {\n        // add new dependencies\n        func\n    } else {\n        grid.get_node(target.row(), target.col()).function.clone()\n    };\n\n    if let Some(Value::Oper(box1, box2, oper)) = old_func {\n        match oper {\n            Operation::Sum | Operation::Avg | Operation::Max | Operation::Min =\u003e {\n                if let Some(Value::Cell(row1, col1)) = box1.as_deref() {\n                    if let Some(Value::Cell(row2, col2)) = box2.as_deref() {\n                        for i in *row1..=*row2 {\n                            for j in *col1..=*col2 {\n                                let node = grid.get_node(i, j);\n                                node.add_dep(target.clone());\n                            }\n                        }\n                    }\n                }\n            }\n            Operation::Add | Operation::Sub | Operation::Mul | Operation::Div =\u003e {\n                if let Some(boxed_val) = box1 {\n                    if let Value::Cell(row1, col1) = \u0026*boxed_val {\n                        let node1 = grid.get_node(*row1, *col1);\n                        node1.add_dep(target.clone());\n                    }\n                }\n                if let Some(boxed_val) = box2 {\n                    if let Value::Cell(row1, col1) = \u0026*boxed_val {\n                        let node1 = grid.get_node(*row1, *col1);\n                        node1.add_dep(target.clone());\n                    }\n                }\n            }\n            Operation::Cons | Operation::Slp =\u003e {\n                // C\n                if let Some(Value::Cell(row1, col1)) = box1.as_deref() {\n                    let node1 = grid.get_node(*row1, *col1);\n                    node1.add_dep(target.clone());\n                }\n                // V -\u003e do nothing\n            }\n            _ =\u003e {}\n        }\n    }\n}\n\n/// Updates the edges of the graph based on target and function values.\n/// flag is true when previous dependencies are to be broken and new dependecies are to be added\n/// flag is false when only new dependencies are to be added and previous dependencies are to be broken (Circular dependency case)\npub fn update_edges(grid: \u0026mut Grid, target: Value, func: Option\u003cValue\u003e, flag: bool) {\n    // so here in update edges -\u003e func will contain the 3 value tuple (new)\n    // target will always be a cell\n    if let Value::Cell(_, _) = target {\n        if let Some(Value::Oper(ref _box1, ref _box2, ref _oper)) = func {\n            // passing target row col to access the node in functions\n            break_edges(grid, target.clone(), func.clone(), flag);\n            add_edges(grid, target.clone(), func.clone(), flag);\n        }\n    }\n}\n\n/// Checks for circular dependency in graph using DFS\npub fn has_cycle(grid: \u0026mut Grid, target: Value) -\u003e bool {\n    let mut stack = vec![target.clone()];\n    let node = grid.get_node(target.row(), target.col());\n    node.visited = true;\n    while let Some(Value::Cell(row, col)) = stack.pop() {\n        let dependents = grid.get_node(row, col).dependents.clone();\n        for dep in dependents {\n            if let Value::Cell(dep_r, dep_c) = dep {\n                let dep_node = grid.get_node(dep_r, dep_c);\n                if dep_node.visited {\n                    // cycle detected\n                    reset_visited(grid, target.clone());\n                    return true;\n                } else {\n                    dep_node.visited = true;\n                    stack.push(dep);\n                }\n            }\n        }\n    }\n    reset_visited(grid, target.clone());\n    false\n}\n\n/// This function does dfs in order to efficiently reset visited flags to false\npub fn reset_visited(grid: \u0026mut Grid, start: Value) {\n    if let Value::Cell(row, col) = start {\n        let mut stack = vec![start];\n        grid.get_node(row, col).visited = false;\n\n        while let Some(Value::Cell(r, c)) = stack.pop() {\n            let dependents = grid.get_node(r, c).dependents.clone();\n\n            for dep in dependents {\n                if let Value::Cell(dep_r, dep_c) = dep {\n                    let dep_node = grid.get_node(dep_r, dep_c);\n                    if dep_node.visited {\n                        dep_node.visited = false;\n                        stack.push(dep);\n                    }\n                }\n            }\n        }\n    }\n}\n\n/// Returns the sequence of topological sort starting from target cell\npub fn get_sequence(grid: \u0026mut Grid, target: Value) -\u003e Vec\u003cValue\u003e {\n    let mut stack = Vec::new();\n    topological_sort(grid, target.clone(), \u0026mut stack);\n    stack.reverse();\n    reset_visited(grid, target.clone());\n    stack\n}\n\npub fn topological_sort(grid: \u0026mut Grid, target: Value, stack: \u0026mut Vec\u003cValue\u003e) {\n    if let Value::Cell(row, col) = target {\n        let node = grid.get_node(row, col);\n        if node.visited {\n            return;\n        }\n        node.visited = true;\n\n        for dep in node.dependents.clone() {\n            topological_sort(grid, dep, stack);\n            // if let Value::Cell(dep_row, dep_col) = dep {\n            //     topological_sort(grid, Value::Cell(dep_row, dep_col), stack);\n            // }\n        }\n        stack.push(target);\n    }\n}\n","traces":[{"line":38,"address":[],"length":0,"stats":{"Line":1459}},{"line":40,"address":[],"length":0,"stats":{"Line":1459}},{"line":47,"address":[],"length":0,"stats":{"Line":1427}},{"line":48,"address":[],"length":0,"stats":{"Line":1427}},{"line":49,"address":[],"length":0,"stats":{"Line":1417}},{"line":51,"address":[],"length":0,"stats":{"Line":10}},{"line":54,"address":[],"length":0,"stats":{"Line":17}},{"line":55,"address":[],"length":0,"stats":{"Line":47}},{"line":57,"address":[],"length":0,"stats":{"Line":75}},{"line":58,"address":[],"length":0,"stats":{"Line":149}},{"line":59,"address":[],"length":0,"stats":{"Line":74}},{"line":62,"address":[],"length":0,"stats":{"Line":2}},{"line":63,"address":[],"length":0,"stats":{"Line":2}},{"line":73,"address":[],"length":0,"stats":{"Line":65}},{"line":75,"address":[],"length":0,"stats":{"Line":130}},{"line":77,"address":[],"length":0,"stats":{"Line":62}},{"line":79,"address":[],"length":0,"stats":{"Line":3}},{"line":81,"address":[],"length":0,"stats":{"Line":20}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":2}},{"line":85,"address":[],"length":0,"stats":{"Line":2}},{"line":86,"address":[],"length":0,"stats":{"Line":3}},{"line":87,"address":[],"length":0,"stats":{"Line":10}},{"line":88,"address":[],"length":0,"stats":{"Line":4}},{"line":89,"address":[],"length":0,"stats":{"Line":4}},{"line":96,"address":[],"length":0,"stats":{"Line":14}},{"line":97,"address":[],"length":0,"stats":{"Line":7}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":14}},{"line":103,"address":[],"length":0,"stats":{"Line":4}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":2}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":67}},{"line":126,"address":[],"length":0,"stats":{"Line":134}},{"line":128,"address":[],"length":0,"stats":{"Line":66}},{"line":130,"address":[],"length":0,"stats":{"Line":1}},{"line":133,"address":[],"length":0,"stats":{"Line":134}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":16}},{"line":137,"address":[],"length":0,"stats":{"Line":16}},{"line":138,"address":[],"length":0,"stats":{"Line":32}},{"line":139,"address":[],"length":0,"stats":{"Line":80}},{"line":140,"address":[],"length":0,"stats":{"Line":28}},{"line":141,"address":[],"length":0,"stats":{"Line":28}},{"line":148,"address":[],"length":0,"stats":{"Line":34}},{"line":149,"address":[],"length":0,"stats":{"Line":17}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":34}},{"line":155,"address":[],"length":0,"stats":{"Line":13}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":44}},{"line":164,"address":[],"length":0,"stats":{"Line":2}},{"line":165,"address":[],"length":0,"stats":{"Line":2}},{"line":169,"address":[],"length":0,"stats":{"Line":2}},{"line":177,"address":[],"length":0,"stats":{"Line":62}},{"line":180,"address":[],"length":0,"stats":{"Line":62}},{"line":181,"address":[],"length":0,"stats":{"Line":124}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":28}},{"line":191,"address":[],"length":0,"stats":{"Line":28}},{"line":192,"address":[],"length":0,"stats":{"Line":28}},{"line":193,"address":[],"length":0,"stats":{"Line":28}},{"line":194,"address":[],"length":0,"stats":{"Line":97}},{"line":195,"address":[],"length":0,"stats":{"Line":36}},{"line":196,"address":[],"length":0,"stats":{"Line":55}},{"line":197,"address":[],"length":0,"stats":{"Line":11}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":3}},{"line":202,"address":[],"length":0,"stats":{"Line":3}},{"line":204,"address":[],"length":0,"stats":{"Line":8}},{"line":205,"address":[],"length":0,"stats":{"Line":8}},{"line":210,"address":[],"length":0,"stats":{"Line":25}},{"line":211,"address":[],"length":0,"stats":{"Line":25}},{"line":215,"address":[],"length":0,"stats":{"Line":87}},{"line":216,"address":[],"length":0,"stats":{"Line":174}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":287}},{"line":221,"address":[],"length":0,"stats":{"Line":100}},{"line":223,"address":[],"length":0,"stats":{"Line":132}},{"line":224,"address":[],"length":0,"stats":{"Line":16}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":13}},{"line":227,"address":[],"length":0,"stats":{"Line":13}},{"line":228,"address":[],"length":0,"stats":{"Line":13}},{"line":237,"address":[],"length":0,"stats":{"Line":58}},{"line":238,"address":[],"length":0,"stats":{"Line":58}},{"line":239,"address":[],"length":0,"stats":{"Line":58}},{"line":240,"address":[],"length":0,"stats":{"Line":58}},{"line":241,"address":[],"length":0,"stats":{"Line":58}},{"line":242,"address":[],"length":0,"stats":{"Line":58}},{"line":245,"address":[],"length":0,"stats":{"Line":64}},{"line":246,"address":[],"length":0,"stats":{"Line":128}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":64}},{"line":253,"address":[],"length":0,"stats":{"Line":10}},{"line":254,"address":[],"length":0,"stats":{"Line":5}},{"line":259,"address":[],"length":0,"stats":{"Line":64}}],"covered":86,"coverable":109},{"path":["/","Users","yuvikachaudhary","Desktop","Semester 4","COP290","spreadsheet_rust","src","extension","backend","mod.rs"],"content":"#![allow(clippy::module_inception)]\npub mod backend;\npub mod functions;\npub mod graph;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","yuvikachaudhary","Desktop","Semester 4","COP290","spreadsheet_rust","src","extension","common.rs"],"content":"use serde::{Deserialize, Serialize};\n\n/// Represents a value that can appear in a spreadsheet.\n//Clone required for `Vec\u003cValue\u003e`(in graph.rs) to implement `Clone`\n#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]\npub enum Value {\n    Cell(usize, usize),\n    Const(isize),\n    Oper(Option\u003cBox\u003cValue\u003e\u003e, Option\u003cBox\u003cValue\u003e\u003e, Operation), //value1 and value2, and the operation or command, respectively\n}\n\nimpl Value {\n    /// return row of Cell\n    pub fn row(\u0026self) -\u003e usize {\n        match self {\n            Value::Cell(row, _) =\u003e *row,\n            _ =\u003e 0,\n        }\n    }\n    /// return column of Cell\n    pub fn col(\u0026self) -\u003e usize {\n        match self {\n            Value::Cell(_, col) =\u003e *col,\n            _ =\u003e 0,\n        }\n    }\n\n    pub fn assign_row(\u0026mut self, new_row: usize) {\n        if let Value::Cell(row, _) = self {\n            *row = new_row;\n        }\n    }\n\n    pub fn assign_col(\u0026mut self, new_col: usize) {\n        if let Value::Cell(_, col) = self {\n            *col = new_col;\n        }\n    }\n}\n\n#[derive(Debug, Clone, PartialEq)]\n//Needed as Value has implemented a clone\n//Oper(Box\u003cValue\u003e, Box\u003cValue\u003e, Operation), //value1 and value2, and the operation or command, respectively\n//   |                                  ^^^^^^^^^ the trait `Clone` is not implemented for `Operation`\n#[derive(Serialize, Deserialize)]\npub enum Operation {\n    Cons,\n    Add,\n    Sub,\n    Mul,\n    Div,\n    Min,\n    Max,\n    Avg,\n    Sum,\n    Std,\n    Slp,\n    EnableOutput,\n    DisableOutput,\n    ScrollTo,\n    Left,\n    Right,\n    Up,\n    Down,\n    Quit,\n    Web(String),\n    Save(String),\n    Undo,\n    Redo,\n    WebStart,\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":379}},{"line":15,"address":[],"length":0,"stats":{"Line":379}},{"line":16,"address":[],"length":0,"stats":{"Line":378}},{"line":17,"address":[],"length":0,"stats":{"Line":1}},{"line":21,"address":[],"length":0,"stats":{"Line":379}},{"line":22,"address":[],"length":0,"stats":{"Line":379}},{"line":23,"address":[],"length":0,"stats":{"Line":378}},{"line":24,"address":[],"length":0,"stats":{"Line":1}},{"line":28,"address":[],"length":0,"stats":{"Line":10}},{"line":29,"address":[],"length":0,"stats":{"Line":19}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":10}},{"line":35,"address":[],"length":0,"stats":{"Line":19}},{"line":36,"address":[],"length":0,"stats":{"Line":0}}],"covered":12,"coverable":14},{"path":["/","Users","yuvikachaudhary","Desktop","Semester 4","COP290","spreadsheet_rust","src","extension","frontend","mod.rs"],"content":"pub mod terminal;\npub mod web;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","yuvikachaudhary","Desktop","Semester 4","COP290","spreadsheet_rust","src","extension","frontend","terminal.rs"],"content":"#![allow(dead_code)]\nuse crate::extension::common::Value;\nuse std::cmp;\nuse std::fs;\nuse std::io;\nuse std::io::Write;\nuse std::process::Command;\n\n//init_frontend(r, c) -\u003e init_backend(r, c), Print_grid(), run_counter(): returns void\n//print grid() -\u003e get_value(value::cell) : returns void\n//run_counter -\u003e while loop for argument, process_command(r,c, string), Print_grid() : return void\n//display_status\nuse crate::extension::backend::backend::*;\nuse std::time::{Duration, Instant};\n\n/// Terminal interface for the spreadsheet application.\n///\n/// This struct manages the user interface for the terminal version\n/// of the spreadsheet, handling display, user input, and interaction\n/// with the backend.\npub struct Frontend {\n    pub start: Value,\n    pub dimension: Value,\n    pub backend: Backend,\n    pub print_enabled: bool,\n}\n\n/// Converts a column number to an Excel-style column label.\n///\n/// # Arguments\n///\n/// * `j` - The column number (1-based index) to convert\n///\n/// # Returns\n///\n/// A String representation of the column (e.g., 1 -\u003e \"A\", 27 -\u003e \"AA\")\npub fn column_decoder(mut j: usize) -\u003e String {\n    let mut cc = Vec::new();\n    while j \u003e 0 {\n        j -= 1;\n        cc.push((b'A' + (j % 26) as u8) as char);\n        j /= 26;\n    }\n    cc.reverse();\n    cc.into_iter().collect()\n}\n\nimpl Frontend {\n    /// Displays the grid in a tabular format.\n    ///\n    /// Shows the current viewable area of the spreadsheet with row and column headers.\n    /// If print_enabled is set to false, this function returns without printing the grid.\n    pub fn print_grid(\u0026self) {\n        if !self.print_enabled {\n            return;\n        }\n        let location = self.start.clone();\n        let dimension = self.dimension.clone();\n        if let (Value::Cell(start_x, start_y), Value::Cell(rows, cols)) = (location, dimension) {\n            let max_x = cmp::min(9 + start_x, rows);\n            let max_y = cmp::min(9 + start_y, cols);\n            for i in start_x - 1..=max_x {\n                for j in start_y - 1..=max_y {\n                    if i == start_x - 1 \u0026\u0026 j == start_y - 1 {\n                        print!(\"{:\u003e12}\", \" \");\n                    } else if i == start_x - 1 {\n                        print!(\"{:\u003e12}\", column_decoder(j));\n                    } else if j == start_y - 1 {\n                        print!(\"{:\u003e12}\", i);\n                    } else {\n                        match self.backend.get_grid().get_node_value(i, j) {\n                            Some(value) =\u003e print!(\"{:\u003e12}\", value),\n                            None =\u003e print!(\"{:\u003e12}\", \"ERR\"),\n                        }\n                    }\n                }\n                println!();\n            }\n        } else {\n            eprintln!(\"Invalid location or dimension values provided.\");\n        }\n    }\n\n    pub fn init_frontend(rows: usize, columns: usize, path: \u0026str) -\u003e Self {\n        if path.is_empty() {\n            let backend = Backend::init_backend(rows, columns);\n            Frontend {\n                start: Value::Cell(1, 1),\n                dimension: Value::Cell(rows, columns),\n                backend,\n                print_enabled: true,\n            }\n        } else {\n            let backend = match Backend::deserial(path) {\n                Ok(backend) =\u003e backend,\n                Err(e) =\u003e {\n                    eprintln!(\"Failed to deserialize backend: {}\", e);\n                    Backend::init_backend(rows, columns)\n                }\n            };\n            let rows = backend.get_grid().get_row_size() - 1;\n            let columns = backend.get_grid().get_column_size() - 1;\n            Frontend {\n                start: Value::Cell(1, 1),\n                dimension: Value::Cell(rows, columns),\n                backend,\n                print_enabled: true,\n            }\n        }\n    }\n\n    /// Starts the frontend interface.\n    ///\n    /// Initializes the display with a success status and starts the command input loop.\n    pub fn run_frontend(\u0026mut self) {\n        // self.display(Status::Success, Duration::from_secs(0).as_secs_f64());\n        self.run_counter();\n    }\n\n    /// Executes actions based on status returned from the backend.\n    ///\n    /// # Arguments\n    ///\n    /// * `status` - The status returned from processing a command\n    ///\n    /// Handles navigation commands (up, down, left, right), display settings,\n    /// and custom commands like ScrollTo and Web.\n    pub fn execute_status(\u0026mut self, status: \u0026Status) {\n        match status {\n            Status::Left =\u003e {\n                if self.start.col() \u003e 10 {\n                    self.start.assign_col(self.start.col() - 10);\n                } else {\n                    self.start.assign_col(1);\n                }\n            }\n            Status::Right =\u003e {\n                if (self.start.col() as isize) \u003c (self.dimension.col() as isize) - 10 {\n                    self.start.assign_col(self.start.col() + 10);\n                } else {\n                    self.start.assign_col(self.dimension.col() - 9); //debug\n                }\n            }\n            Status::Up =\u003e {\n                if self.start.row() \u003e 10 {\n                    self.start.assign_row(self.start.row() - 10);\n                } else {\n                    self.start.assign_row(1);\n                }\n            }\n            Status::Down =\u003e {\n                if (self.start.row() as isize) \u003c (self.dimension.row() as isize) - 10 {\n                    self.start.assign_row(self.start.row() + 10);\n                } else {\n                    self.start.assign_row(self.dimension.row() - 9);\n                }\n            }\n            Status::PrintDisabled =\u003e {\n                self.print_enabled = false;\n            }\n            Status::PrintEnabled =\u003e {\n                self.print_enabled = true;\n            }\n            Status::ScrollTo(row, col) =\u003e {\n                self.start.assign_row(*row);\n                self.start.assign_col(*col);\n            }\n            Status::Web(path) =\u003e {\n                println!(\"Web path: {}\", path);\n                let contents = fs::read_to_string(path).expect(\"Failed to read file\");\n                fs::write(\"mysheet.json\", contents).expect(\"Failed to write to file\");\n                Command::new(\"trunk\")\n                    .arg(\"serve\")\n                    .arg(\"--open\")\n                    .arg(\"--port\")\n                    .arg(\"8000\")\n                    .env(\"LOAD\", \"1\")\n                    .spawn()\n                    .expect(\"Failed to start trunk\")\n                    .wait()\n                    .expect(\"Failed to wait for trunk process\");\n            }\n            Status::WebStart =\u003e {\n                let path = \"mysheet.json\";\n                if let Err(e) = self.backend.serial(path) {\n                    eprintln!(\"Failed to save backend: {}\", e);\n                } else {\n                    println!(\"Backend state saved to '{}'\", path);\n                }\n\n                // Now launch the web app\n                Command::new(\"trunk\")\n                    .arg(\"serve\")\n                    .arg(\"--open\")\n                    .arg(\"--port\")\n                    .arg(\"8000\")\n                    .env(\"LOAD\", \"1\") // Your web.rs already reads this\n                    .spawn()\n                    .expect(\"Failed to start trunk\")\n                    .wait()\n                    .expect(\"Failed to wait for trunk process\");\n            }\n            _ =\u003e (),\n        }\n    }\n\n    /// Displays the grid and status message with execution time.\n    ///\n    /// # Arguments\n    ///\n    /// * `status` - The status to display\n    /// * `elapsed_time` - Time taken to execute the command in seconds\n    ///\n    /// Prints the grid (if enabled) followed by a status message and prompt.\n    pub fn display(\u0026self, status: Status, elapsed_time: f64) {\n        self.print_grid();\n        match status {\n            Status::Success =\u003e print!(\"[{:.2}] (ok) \u003e \", elapsed_time),\n            Status::UnrecognizedCmd =\u003e print!(\"[{:.2}] (unrecognized command) \u003e \", elapsed_time),\n            Status::CircularDependency =\u003e print!(\"[{:.2}] (cycle not allowed) \u003e \", elapsed_time),\n            Status::PrintEnabled =\u003e print!(\"[{:.2}] (ok) \u003e \", elapsed_time),\n            Status::PrintDisabled =\u003e print!(\"[{:.2}] (ok) \u003e \", elapsed_time),\n            Status::ScrollTo(_, _) =\u003e print!(\"[{:.2}] (ok) \u003e \", elapsed_time),\n            Status::Up =\u003e print!(\"[{:.2}] (ok) \u003e \", elapsed_time),\n            Status::Down =\u003e print!(\"[{:.2}] (ok) \u003e \", elapsed_time),\n            Status::Left =\u003e print!(\"[{:.2}] (ok) \u003e \", elapsed_time),\n            Status::Right =\u003e print!(\"[{:.2}] (ok) \u003e \", elapsed_time),\n            _ =\u003e (),\n        }\n        io::stdout().flush().unwrap();\n    }\n\n    /// Main input loop for the terminal interface.\n    ///\n    /// Continuously reads commands from stdin, processes them through the backend,\n    /// updates the display based on status, and measures execution time.\n    /// Loop exits when a Quit status is received.\n    pub fn run_counter(\u0026mut self) {\n        let mut input = String::new();\n        let stdin = std::io::stdin();\n\n        loop {\n            input.clear();\n\n            if stdin.read_line(\u0026mut input).is_err() {\n                self.display(\n                    Status::UnrecognizedCmd,\n                    Duration::from_secs(0).as_secs_f64(),\n                );\n                continue;\n            }\n            let start_time = Instant::now();\n            let command = input.trim().to_string();\n            // let status = Status::Success;\n            // if command == (\"save\".to_string()) {\n            //     self.backend.serial(\"tester.json\").expect(\"Failed to save file\");\n\n            // } else {\n            let status =\n                self.backend\n                    .process_command(self.dimension.row(), self.dimension.col(), command);\n            // }\n            if status == Status::Quit {\n                break;\n            }\n            self.execute_status(\u0026status);\n            let elapsed_time = start_time.elapsed();\n            self.display(status, elapsed_time.as_secs_f64());\n        }\n    }\n}\n","traces":[{"line":37,"address":[],"length":0,"stats":{"Line":152}},{"line":38,"address":[],"length":0,"stats":{"Line":152}},{"line":39,"address":[],"length":0,"stats":{"Line":476}},{"line":40,"address":[],"length":0,"stats":{"Line":162}},{"line":41,"address":[],"length":0,"stats":{"Line":162}},{"line":42,"address":[],"length":0,"stats":{"Line":162}},{"line":44,"address":[],"length":0,"stats":{"Line":152}},{"line":45,"address":[],"length":0,"stats":{"Line":152}},{"line":53,"address":[],"length":0,"stats":{"Line":16}},{"line":54,"address":[],"length":0,"stats":{"Line":16}},{"line":55,"address":[],"length":0,"stats":{"Line":1}},{"line":57,"address":[],"length":0,"stats":{"Line":15}},{"line":58,"address":[],"length":0,"stats":{"Line":15}},{"line":59,"address":[],"length":0,"stats":{"Line":29}},{"line":60,"address":[],"length":0,"stats":{"Line":14}},{"line":61,"address":[],"length":0,"stats":{"Line":14}},{"line":62,"address":[],"length":0,"stats":{"Line":168}},{"line":63,"address":[],"length":0,"stats":{"Line":1848}},{"line":64,"address":[],"length":0,"stats":{"Line":1862}},{"line":65,"address":[],"length":0,"stats":{"Line":14}},{"line":66,"address":[],"length":0,"stats":{"Line":1834}},{"line":67,"address":[],"length":0,"stats":{"Line":140}},{"line":68,"address":[],"length":0,"stats":{"Line":1820}},{"line":69,"address":[],"length":0,"stats":{"Line":140}},{"line":71,"address":[],"length":0,"stats":{"Line":1400}},{"line":72,"address":[],"length":0,"stats":{"Line":1398}},{"line":73,"address":[],"length":0,"stats":{"Line":2}},{"line":77,"address":[],"length":0,"stats":{"Line":154}},{"line":80,"address":[],"length":0,"stats":{"Line":1}},{"line":84,"address":[],"length":0,"stats":{"Line":12}},{"line":85,"address":[],"length":0,"stats":{"Line":12}},{"line":86,"address":[],"length":0,"stats":{"Line":11}},{"line":88,"address":[],"length":0,"stats":{"Line":11}},{"line":89,"address":[],"length":0,"stats":{"Line":11}},{"line":94,"address":[],"length":0,"stats":{"Line":1}},{"line":95,"address":[],"length":0,"stats":{"Line":1}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":19}},{"line":129,"address":[],"length":0,"stats":{"Line":19}},{"line":131,"address":[],"length":0,"stats":{"Line":5}},{"line":132,"address":[],"length":0,"stats":{"Line":2}},{"line":134,"address":[],"length":0,"stats":{"Line":1}},{"line":138,"address":[],"length":0,"stats":{"Line":5}},{"line":139,"address":[],"length":0,"stats":{"Line":2}},{"line":141,"address":[],"length":0,"stats":{"Line":1}},{"line":145,"address":[],"length":0,"stats":{"Line":5}},{"line":146,"address":[],"length":0,"stats":{"Line":2}},{"line":148,"address":[],"length":0,"stats":{"Line":1}},{"line":152,"address":[],"length":0,"stats":{"Line":5}},{"line":153,"address":[],"length":0,"stats":{"Line":2}},{"line":155,"address":[],"length":0,"stats":{"Line":1}},{"line":158,"address":[],"length":0,"stats":{"Line":2}},{"line":159,"address":[],"length":0,"stats":{"Line":2}},{"line":161,"address":[],"length":0,"stats":{"Line":2}},{"line":162,"address":[],"length":0,"stats":{"Line":2}},{"line":164,"address":[],"length":0,"stats":{"Line":3}},{"line":165,"address":[],"length":0,"stats":{"Line":3}},{"line":166,"address":[],"length":0,"stats":{"Line":3}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":10}},{"line":216,"address":[],"length":0,"stats":{"Line":10}},{"line":217,"address":[],"length":0,"stats":{"Line":10}},{"line":218,"address":[],"length":0,"stats":{"Line":1}},{"line":219,"address":[],"length":0,"stats":{"Line":1}},{"line":220,"address":[],"length":0,"stats":{"Line":1}},{"line":221,"address":[],"length":0,"stats":{"Line":1}},{"line":222,"address":[],"length":0,"stats":{"Line":1}},{"line":223,"address":[],"length":0,"stats":{"Line":1}},{"line":224,"address":[],"length":0,"stats":{"Line":1}},{"line":225,"address":[],"length":0,"stats":{"Line":1}},{"line":226,"address":[],"length":0,"stats":{"Line":1}},{"line":227,"address":[],"length":0,"stats":{"Line":1}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":10}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}}],"covered":71,"coverable":111},{"path":["/","Users","yuvikachaudhary","Desktop","Semester 4","COP290","spreadsheet_rust","src","extension","mod.rs"],"content":"pub mod backend;\npub mod common;\npub mod frontend;\npub mod parser;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","yuvikachaudhary","Desktop","Semester 4","COP290","spreadsheet_rust","src","extension","parser","mod.rs"],"content":"#![allow(clippy::module_inception)]\npub mod parser;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","yuvikachaudhary","Desktop","Semester 4","COP290","spreadsheet_rust","src","extension","parser","parser.rs"],"content":"#![allow(dead_code)]\n/// Module responsible for validating and parsing commands given to the spreadsheet.\n///\n/// This includes:\n/// - Recognizing valid cell identifiers\n/// - Parsing constants and expressions\n/// - Constructing a `Value` AST representing operations or values\n/// - Supporting arithmetic, sleep, and range-based operations like SUM, AVG, etc.\nuse crate::extension::common::Operation;\nuse crate::extension::common::Value;\n\nfn is_cell(exp: \u0026str, columns: \u0026usize, rows: \u0026usize) -\u003e Option\u003cValue\u003e {\n    let mut col = 0;\n    let mut row = 0;\n\n    let chars: Vec\u003cchar\u003e = exp.chars().collect();\n    let mut i = 0;\n    while i \u003c 3 {\n        if chars[i].is_alphabetic() {\n            col = col * 26 + (chars[i] as u8 - b'A') as usize + 1;\n        } else {\n            break;\n        }\n        i += 1;\n    }\n    if exp.chars().count() - i \u003e 3 || i == 0 {\n        return None;\n    }\n    while i \u003c exp.chars().count() {\n        if chars[i].is_numeric() {\n            row = row * 10 + (chars[i] as u8 - b'0') as usize;\n        } else {\n            return None;\n        }\n        i += 1;\n    }\n    if row \u003e *rows || col \u003e *columns {\n        return None;\n    }\n    Some(Value::Cell(row, col))\n}\n\nfn is_const(exp: \u0026str) -\u003e Option\u003cValue\u003e {\n    // let mut ans = 0;\n    // for c in exp.chars() {\n    //     if c.is_numeric() {\n    //         ans = ans*10 + (c as u8 - '0' as u8) as usize;\n    //     } else {\n    //         return None;\n    //     }\n    // }\n    // return Some(Value::Const(ans));\n    match exp.parse::\u003cisize\u003e() {\n        Ok(ans) =\u003e Some(Value::Const(ans)),\n        Err(_) =\u003e None,\n    }\n}\n\nfn is_cell_or_const(exp: \u0026str, rows: \u0026usize, columns: \u0026usize) -\u003e Option\u003cValue\u003e {\n    if let Some(constant) = is_const(exp) {\n        Some(constant)\n    } else if let Some(cell) = is_cell(exp, rows, columns) {\n        return Some(cell);\n    } else {\n        return None;\n    }\n}\n\npub fn validate(\n    cmd: \u0026str,\n    rows: \u0026usize,\n    columns: \u0026usize,\n) -\u003e Option\u003c(Option\u003cValue\u003e, Option\u003cValue\u003e)\u003e {\n    match cmd.trim() {\n        \"undo\" =\u003e return Some((None, Some(Value::Oper(None, None, Operation::Undo)))),\n        \"redo\" =\u003e return Some((None, Some(Value::Oper(None, None, Operation::Redo)))),\n        \"web_start\" =\u003e return Some((None, Some(Value::Oper(None, None, Operation::WebStart)))),\n        \"enable_output\" =\u003e {\n            return Some((None, Some(Value::Oper(None, None, Operation::EnableOutput))));\n        }\n        \"disable_output\" =\u003e {\n            return Some((\n                None,\n                Some(Value::Oper(None, None, Operation::DisableOutput)),\n            ));\n        }\n        \"w\" =\u003e {\n            return Some((None, Some(Value::Oper(None, None, Operation::Up))));\n        }\n        \"s\" =\u003e {\n            return Some((None, Some(Value::Oper(None, None, Operation::Down))));\n        }\n        \"a\" =\u003e {\n            return Some((None, Some(Value::Oper(None, None, Operation::Left))));\n        }\n        \"d\" =\u003e {\n            return Some((None, Some(Value::Oper(None, None, Operation::Right))));\n        }\n        \"q\" =\u003e {\n            return Some((None, Some(Value::Oper(None, None, Operation::Quit))));\n        }\n        _ =\u003e {} // Continue with the regular parsing for other commands\n    }\n\n    if cmd.trim().starts_with(\"scroll_to \") {\n        let cell_name = cmd.trim()[\"scroll_to \".len()..].trim().to_string();\n        let cell = is_cell(\u0026cell_name, rows, columns);\n        if let Some(cell) = cell {\n            return Some((\n                Some(cell),\n                Some(Value::Oper(None, None, Operation::ScrollTo)),\n            ));\n        } else {\n            // println!(\"Invalid cell name\");\n            return None;\n        }\n    }\n\n    if cmd.trim().starts_with(\"save \") {\n        let file_name = cmd.trim()[\"save \".len()..].trim().to_string();\n        return Some((\n            None,\n            Some(Value::Oper(None, None, Operation::Save(file_name))),\n        ));\n    }\n\n    if cmd.trim().starts_with(\"web \") {\n        let file_name = cmd.trim()[\"web \".len()..].trim().to_string();\n        return Some((\n            None,\n            Some(Value::Oper(None, None, Operation::Web(file_name))),\n        ));\n    }\n\n    let Some((cell, exp)) = cmd.split_once('=') else {\n        // eprintln!(\"Could not find a valid exp being assigned to a valid cell\");\n        return None;\n    };\n\n    let cell = String::from(cell).trim().to_string();\n    let cell = is_cell(\u0026cell, rows, columns);\n\n    let Some((operation, range)) = exp.split_once('(') else {\n        // basic math operations or constant (0-4)\n        let val = (String::from(exp)).trim().to_string();\n        let operators = [\"+\", \"-\", \"*\", \"/\"];\n        for (i, c) in val.chars().enumerate() {\n            if i == 0 \u0026\u0026 c == '-' {\n                continue;\n            }\n            if operators.contains(\u0026c.to_string().as_str()) {\n                let op1_str = val[..i].trim();\n                let op2_str = val[i + 1..].trim();\n                let op1 = is_cell_or_const(op1_str, rows, columns)?;\n                let op2 = is_cell_or_const(op2_str, rows, columns)?;\n\n                match c {\n                    '+' =\u003e {\n                        return Some((\n                            cell,\n                            Some(Value::Oper(\n                                Some(Box::new(op1)),\n                                Some(Box::new(op2)),\n                                Operation::Add,\n                            )),\n                        ));\n                    }\n                    '-' =\u003e {\n                        return Some((\n                            cell,\n                            Some(Value::Oper(\n                                Some(Box::new(op1)),\n                                Some(Box::new(op2)),\n                                Operation::Sub,\n                            )),\n                        ));\n                    }\n                    '*' =\u003e {\n                        return Some((\n                            cell,\n                            Some(Value::Oper(\n                                Some(Box::new(op1)),\n                                Some(Box::new(op2)),\n                                Operation::Mul,\n                            )),\n                        ));\n                    }\n                    '/' =\u003e {\n                        return Some((\n                            cell,\n                            Some(Value::Oper(\n                                Some(Box::new(op1)),\n                                Some(Box::new(op2)),\n                                Operation::Div,\n                            )),\n                        ));\n                    }\n                    _ =\u003e {\n                        // eprintln!(\"Invalid operation\");\n                        return None;\n                    } //This case is not possible, just for compilation\n                }\n            }\n        }\n\n        let val = is_cell_or_const(\u0026val, rows, columns)?; //for the moment, assuming the RHS to be a constant or cell\n        // println!(\"{} {}\", cmd, cmd); //---------------debugger\n        return Some((\n            cell,\n            Some(Value::Oper(\n                Some(Box::new(val)),\n                Some(Box::new(Value::Const(0))),\n                Operation::Cons,\n            )),\n        ));\n    };\n    let range = range.strip_suffix(')')?.to_string(); //removing the closing bracket\n\n    let Some((start, end)) = range.split_once(':') else {\n        // SLEEP (the keyword 'SLEEP' is not checked for, it is taken fro granted)\n        let val = range;\n        let val = is_cell_or_const(\u0026val, rows, columns);\n        if let Some(val) = val {\n            return Some((\n                cell,\n                Some(Value::Oper(\n                    Some(Box::new(val)),\n                    Some(Box::new(Value::Const(0))),\n                    Operation::Slp,\n                )),\n            ));\n        }\n        return Some((cell, None));\n    };\n    let start = String::from(start);\n    let end = String::from(end);\n    let start = is_cell(\u0026start, rows, columns)?;\n    let end = is_cell(\u0026end, rows, columns)?;\n    if let (Value::Cell(r, c), Value::Cell(r2, c2)) = (\u0026start, \u0026end) {\n        if r \u003e r2 || c \u003e c2 {\n            // eprintln!(\"Invalid range, start is greater than end\");\n            return None;\n        }\n    } else {\n        return None;\n    }\n    match operation {\n        \"SUM\" =\u003e Some((\n            cell,\n            Some(Value::Oper(\n                Some(Box::new(start)),\n                Some(Box::new(end)),\n                Operation::Sum,\n            )),\n        )),\n        \"AVG\" =\u003e Some((\n            cell,\n            Some(Value::Oper(\n                Some(Box::new(start)),\n                Some(Box::new(end)),\n                Operation::Avg,\n            )),\n        )),\n        \"STDEV\" =\u003e Some((\n            cell,\n            Some(Value::Oper(\n                Some(Box::new(start)),\n                Some(Box::new(end)),\n                Operation::Std,\n            )),\n        )),\n        \"MIN\" =\u003e Some((\n            cell,\n            Some(Value::Oper(\n                Some(Box::new(start)),\n                Some(Box::new(end)),\n                Operation::Min,\n            )),\n        )),\n        \"MAX\" =\u003e Some((\n            cell,\n            Some(Value::Oper(\n                Some(Box::new(start)),\n                Some(Box::new(end)),\n                Operation::Max,\n            )),\n        )),\n        _ =\u003e {\n            // eprintln!(\"Invalid operation\");\n            Some((cell, None))\n        }\n    }\n}\n\n// assignment - cell, value - done\n// basic math - cells, values\n// sleep - cell, value - done\n// range operations - cells, values - done\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":128}},{"line":13,"address":[],"length":0,"stats":{"Line":128}},{"line":14,"address":[],"length":0,"stats":{"Line":128}},{"line":16,"address":[],"length":0,"stats":{"Line":128}},{"line":17,"address":[],"length":0,"stats":{"Line":128}},{"line":18,"address":[],"length":0,"stats":{"Line":256}},{"line":19,"address":[],"length":0,"stats":{"Line":384}},{"line":20,"address":[],"length":0,"stats":{"Line":128}},{"line":22,"address":[],"length":0,"stats":{"Line":128}},{"line":24,"address":[],"length":0,"stats":{"Line":128}},{"line":26,"address":[],"length":0,"stats":{"Line":256}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":257}},{"line":30,"address":[],"length":0,"stats":{"Line":258}},{"line":31,"address":[],"length":0,"stats":{"Line":129}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":129}},{"line":37,"address":[],"length":0,"stats":{"Line":255}},{"line":38,"address":[],"length":0,"stats":{"Line":2}},{"line":40,"address":[],"length":0,"stats":{"Line":126}},{"line":43,"address":[],"length":0,"stats":{"Line":68}},{"line":53,"address":[],"length":0,"stats":{"Line":68}},{"line":54,"address":[],"length":0,"stats":{"Line":43}},{"line":55,"address":[],"length":0,"stats":{"Line":25}},{"line":59,"address":[],"length":0,"stats":{"Line":68}},{"line":60,"address":[],"length":0,"stats":{"Line":111}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":50}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":89}},{"line":74,"address":[],"length":0,"stats":{"Line":89}},{"line":75,"address":[],"length":0,"stats":{"Line":91}},{"line":76,"address":[],"length":0,"stats":{"Line":89}},{"line":77,"address":[],"length":0,"stats":{"Line":86}},{"line":78,"address":[],"length":0,"stats":{"Line":84}},{"line":79,"address":[],"length":0,"stats":{"Line":1}},{"line":81,"address":[],"length":0,"stats":{"Line":83}},{"line":82,"address":[],"length":0,"stats":{"Line":1}},{"line":83,"address":[],"length":0,"stats":{"Line":1}},{"line":84,"address":[],"length":0,"stats":{"Line":1}},{"line":87,"address":[],"length":0,"stats":{"Line":82}},{"line":88,"address":[],"length":0,"stats":{"Line":1}},{"line":90,"address":[],"length":0,"stats":{"Line":81}},{"line":91,"address":[],"length":0,"stats":{"Line":1}},{"line":93,"address":[],"length":0,"stats":{"Line":80}},{"line":94,"address":[],"length":0,"stats":{"Line":1}},{"line":96,"address":[],"length":0,"stats":{"Line":79}},{"line":97,"address":[],"length":0,"stats":{"Line":1}},{"line":99,"address":[],"length":0,"stats":{"Line":78}},{"line":100,"address":[],"length":0,"stats":{"Line":1}},{"line":102,"address":[],"length":0,"stats":{"Line":77}},{"line":105,"address":[],"length":0,"stats":{"Line":77}},{"line":106,"address":[],"length":0,"stats":{"Line":2}},{"line":107,"address":[],"length":0,"stats":{"Line":2}},{"line":108,"address":[],"length":0,"stats":{"Line":3}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":1}},{"line":119,"address":[],"length":0,"stats":{"Line":75}},{"line":120,"address":[],"length":0,"stats":{"Line":1}},{"line":121,"address":[],"length":0,"stats":{"Line":1}},{"line":122,"address":[],"length":0,"stats":{"Line":1}},{"line":123,"address":[],"length":0,"stats":{"Line":1}},{"line":127,"address":[],"length":0,"stats":{"Line":74}},{"line":128,"address":[],"length":0,"stats":{"Line":1}},{"line":129,"address":[],"length":0,"stats":{"Line":1}},{"line":130,"address":[],"length":0,"stats":{"Line":1}},{"line":131,"address":[],"length":0,"stats":{"Line":1}},{"line":135,"address":[],"length":0,"stats":{"Line":70}},{"line":137,"address":[],"length":0,"stats":{"Line":3}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":18}},{"line":145,"address":[],"length":0,"stats":{"Line":52}},{"line":146,"address":[],"length":0,"stats":{"Line":52}},{"line":147,"address":[],"length":0,"stats":{"Line":155}},{"line":148,"address":[],"length":0,"stats":{"Line":155}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":103}},{"line":152,"address":[],"length":0,"stats":{"Line":14}},{"line":153,"address":[],"length":0,"stats":{"Line":14}},{"line":154,"address":[],"length":0,"stats":{"Line":28}},{"line":155,"address":[],"length":0,"stats":{"Line":14}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":5}},{"line":160,"address":[],"length":0,"stats":{"Line":5}},{"line":161,"address":[],"length":0,"stats":{"Line":5}},{"line":162,"address":[],"length":0,"stats":{"Line":5}},{"line":163,"address":[],"length":0,"stats":{"Line":5}},{"line":164,"address":[],"length":0,"stats":{"Line":5}},{"line":169,"address":[],"length":0,"stats":{"Line":3}},{"line":170,"address":[],"length":0,"stats":{"Line":3}},{"line":171,"address":[],"length":0,"stats":{"Line":3}},{"line":172,"address":[],"length":0,"stats":{"Line":3}},{"line":173,"address":[],"length":0,"stats":{"Line":3}},{"line":174,"address":[],"length":0,"stats":{"Line":3}},{"line":179,"address":[],"length":0,"stats":{"Line":3}},{"line":180,"address":[],"length":0,"stats":{"Line":3}},{"line":181,"address":[],"length":0,"stats":{"Line":3}},{"line":182,"address":[],"length":0,"stats":{"Line":3}},{"line":183,"address":[],"length":0,"stats":{"Line":3}},{"line":184,"address":[],"length":0,"stats":{"Line":3}},{"line":189,"address":[],"length":0,"stats":{"Line":3}},{"line":190,"address":[],"length":0,"stats":{"Line":3}},{"line":191,"address":[],"length":0,"stats":{"Line":3}},{"line":192,"address":[],"length":0,"stats":{"Line":3}},{"line":193,"address":[],"length":0,"stats":{"Line":3}},{"line":194,"address":[],"length":0,"stats":{"Line":3}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":76}},{"line":208,"address":[],"length":0,"stats":{"Line":38}},{"line":209,"address":[],"length":0,"stats":{"Line":38}},{"line":210,"address":[],"length":0,"stats":{"Line":38}},{"line":211,"address":[],"length":0,"stats":{"Line":38}},{"line":212,"address":[],"length":0,"stats":{"Line":38}},{"line":213,"address":[],"length":0,"stats":{"Line":38}},{"line":217,"address":[],"length":0,"stats":{"Line":18}},{"line":219,"address":[],"length":0,"stats":{"Line":16}},{"line":221,"address":[],"length":0,"stats":{"Line":2}},{"line":222,"address":[],"length":0,"stats":{"Line":2}},{"line":223,"address":[],"length":0,"stats":{"Line":4}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":16}},{"line":238,"address":[],"length":0,"stats":{"Line":15}},{"line":239,"address":[],"length":0,"stats":{"Line":15}},{"line":240,"address":[],"length":0,"stats":{"Line":29}},{"line":242,"address":[],"length":0,"stats":{"Line":1}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":3}},{"line":249,"address":[],"length":0,"stats":{"Line":3}},{"line":250,"address":[],"length":0,"stats":{"Line":3}},{"line":251,"address":[],"length":0,"stats":{"Line":3}},{"line":252,"address":[],"length":0,"stats":{"Line":3}},{"line":253,"address":[],"length":0,"stats":{"Line":3}},{"line":256,"address":[],"length":0,"stats":{"Line":14}},{"line":257,"address":[],"length":0,"stats":{"Line":3}},{"line":258,"address":[],"length":0,"stats":{"Line":3}},{"line":259,"address":[],"length":0,"stats":{"Line":3}},{"line":260,"address":[],"length":0,"stats":{"Line":3}},{"line":261,"address":[],"length":0,"stats":{"Line":3}},{"line":264,"address":[],"length":0,"stats":{"Line":11}},{"line":265,"address":[],"length":0,"stats":{"Line":3}},{"line":266,"address":[],"length":0,"stats":{"Line":3}},{"line":267,"address":[],"length":0,"stats":{"Line":3}},{"line":268,"address":[],"length":0,"stats":{"Line":3}},{"line":269,"address":[],"length":0,"stats":{"Line":3}},{"line":272,"address":[],"length":0,"stats":{"Line":7}},{"line":273,"address":[],"length":0,"stats":{"Line":2}},{"line":274,"address":[],"length":0,"stats":{"Line":2}},{"line":275,"address":[],"length":0,"stats":{"Line":2}},{"line":276,"address":[],"length":0,"stats":{"Line":2}},{"line":277,"address":[],"length":0,"stats":{"Line":2}},{"line":280,"address":[],"length":0,"stats":{"Line":5}},{"line":281,"address":[],"length":0,"stats":{"Line":2}},{"line":282,"address":[],"length":0,"stats":{"Line":2}},{"line":283,"address":[],"length":0,"stats":{"Line":2}},{"line":284,"address":[],"length":0,"stats":{"Line":2}},{"line":285,"address":[],"length":0,"stats":{"Line":2}},{"line":290,"address":[],"length":0,"stats":{"Line":1}}],"covered":146,"coverable":170},{"path":["/","Users","yuvikachaudhary","Desktop","Semester 4","COP290","spreadsheet_rust","src","lib.rs"],"content":"pub mod extension;\npub mod terminal;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","yuvikachaudhary","Desktop","Semester 4","COP290","spreadsheet_rust","src","terminal","backend.rs"],"content":"/// Terminal backend module for the spreadsheet application.\n///\n/// This module provides core functionality for managing the spreadsheet grid,\n/// handling dependencies between cells, and evaluating cell expressions.\n/// It includes functions for updating cell values, checking for cycles,\n/// and performing topological sorts on the dependency graph.\nuse crate::terminal::functions::Operation;\nuse crate::terminal::functions::avg_function;\nuse crate::terminal::functions::max_function;\nuse crate::terminal::functions::min_function;\nuse crate::terminal::functions::stdev_function;\nuse crate::terminal::functions::sum_function;\nuse crate::terminal::graph::Node;\nuse crate::terminal::types::Coordinates;\n\n///// debug -\u003e in add_and _break check which ops you are taking  ---\u003e done\n\n/// Creates a new grid with the specified number of rows and columns.\n///\n/// # Arguments\n///\n/// * `r` - The number of rows in the grid\n/// * `c` - The number of columns in the grid\n///\n/// # Returns\n///\n/// A 2D vector of `Node`s, initialized with default values\npub fn generate_grid(r: usize, c: usize) -\u003e Vec\u003cVec\u003cNode\u003e\u003e {\n    (0..r + 1)\n        .map(|i| {\n            (0..c + 1)\n                .map(|j| Node {\n                    node_value: 0,\n                    value1: Coordinates { row: -1, col: -1 },\n                    value2: Coordinates { row: -1, col: -1 },\n                    position: Coordinates {\n                        row: i as i32,\n                        col: j as i32,\n                    },\n                    op: Operation::Cons, // Default to constant assignment\n                    valid: true,\n                    visited: false,\n                    dependents: Vec::new(),\n                })\n                .collect()\n        })\n        .collect()\n}\n// wrt new node -- inward\n\n// flags : for these two functions\n// true: when working with new dependencies : value1 and value2\n// false: when working with old dependencies : old_value1 and old_value2\n\n/// Adds edges to the dependency graph based on the specified operation.\n///\n/// # Arguments\n///\n/// * `graph` - The dependency graph represented as a 2D vector of `Node`s\n/// * `value1` - The first value involved in the operation\n/// * `value2` - The second value involved in the operation\n/// * `target` - The target cell where the operation result will be stored\n/// * `op` - The operation to be performed\n/// * `flag` - A flag indicating whether to work with new dependencies (true) or old dependencies (false)\npub fn add_edges(\n    graph: \u0026mut [Vec\u003cNode\u003e],\n    value1: Coordinates,\n    value2: Coordinates,\n    target: Coordinates,\n    op: Operation,\n    flag: bool, // debug\n) {\n    let target_row = target.row as usize;\n    let target_col = target.col as usize;\n    let target_cell = \u0026mut graph[target_row][target_col];\n    if flag {\n        match op {\n            Operation::Sum | Operation::Avg | Operation::Max | Operation::Min =\u003e {\n                // For range operations, remove from all cells in the range\n                for i in value1.row..=value2.row {\n                    for j in value1.col..=value2.col {\n                        if i \u003e= 0 \u0026\u0026 j \u003e= 0 {\n                            let r = i as usize;\n                            let c = j as usize;\n                            graph[r][c].add_dep(target);\n                        }\n                    }\n                }\n            }\n            Operation::Add | Operation::Sub | Operation::Mul | Operation::Div =\u003e {\n                // For binary operations, remove dependency from value1 and value2 - check cells and values\n                if value1.col != -1 {\n                    graph[value1.row as usize][value1.col as usize].add_dep(target);\n                }\n                if value2.col != -1 {\n                    graph[value2.row as usize][value2.col as usize].add_dep(target);\n                }\n            }\n            Operation::Cons | Operation::Slp =\u003e {\n                // single cell operation just check value1 and apply the cases\n                // cell\n                if value1.col != -1 \u0026\u0026 value1.row != -1 {\n                    graph[value1.row as usize][value1.col as usize].add_dep(target);\n                }\n                // value -- do nothing\n            }\n            _ =\u003e {} // will not reach here\n        }\n    } else {\n        let old_value1 = target_cell.value1;\n        let old_value2 = target_cell.value2;\n\n        match target_cell.op {\n            Operation::Sum | Operation::Avg | Operation::Max | Operation::Min =\u003e {\n                // For range operations, remove from all cells in the range\n                for i in old_value1.row..=old_value2.row {\n                    for j in old_value1.col..=old_value2.col {\n                        if i \u003e= 0 \u0026\u0026 j \u003e= 0 {\n                            let r = i as usize;\n                            let c = j as usize;\n                            graph[r][c].add_dep(target);\n                        }\n                    }\n                }\n            }\n            Operation::Add | Operation::Sub | Operation::Mul | Operation::Div =\u003e {\n                // For binary operations, remove dependency from value1 and value2 - check cells and values\n                if old_value1.col != -1 {\n                    graph[old_value1.row as usize][old_value1.col as usize].add_dep(target);\n                }\n                if old_value2.col != -1 {\n                    graph[old_value2.row as usize][old_value2.col as usize].add_dep(target);\n                }\n            }\n            Operation::Cons | Operation::Slp =\u003e {\n                // single cell operation just check value1 and apply the cases\n                // cell\n                if old_value1.col != -1 \u0026\u0026 old_value1.row != -1 {\n                    graph[old_value1.row as usize][old_value1.col as usize].add_dep(target);\n                }\n                // value -- do nothing\n            }\n            _ =\u003e {} // will not reach here\n        }\n    }\n}\n\n// will fill when structure is more clear\n// debug -- see the old dependecies where they are stored in the graph when fully made\n// wrt new node -- inward\n\n/// Breaks edges in the dependency graph based on the specified operation.\n///\n/// # Arguments\n///\n/// * `graph` - The dependency graph represented as a 2D vector of `Node`s\n/// * `value1` - The first value involved in the operation\n/// * `value2` - The second value involved in the operation\n/// * `target` - The target cell where the operation result will be stored\n/// * `op` - The operation to be performed\n/// * `flag` - A flag indicating whether to work with new dependencies (true) or old dependencies (false)\npub fn break_edges(\n    graph: \u0026mut [Vec\u003cNode\u003e],\n    value1: Coordinates,\n    value2: Coordinates,\n    target: Coordinates,\n    op: Operation,\n    flag: bool, // debug\n) {\n    // Get the target cell\n    let target_row = target.row as usize;\n    let target_col = target.col as usize;\n    let target_cell = \u0026mut graph[target_row][target_col];\n    if flag {\n        match op {\n            Operation::Sum | Operation::Avg | Operation::Max | Operation::Min =\u003e {\n                // For range operations, remove from all cells in the range\n                for i in value1.row..=value2.row {\n                    for j in value1.col..=value2.col {\n                        if i \u003e= 0 \u0026\u0026 j \u003e= 0 {\n                            let r = i as usize;\n                            let c = j as usize;\n                            graph[r][c].remove_dep(target);\n                        }\n                    }\n                }\n            }\n            Operation::Add | Operation::Sub | Operation::Mul | Operation::Div =\u003e {\n                // For binary operations, remove dependency from value1 and value2 - check cells and values\n                if value1.col != -1 {\n                    graph[value1.row as usize][value1.col as usize].remove_dep(target);\n                }\n                if value2.col != -1 {\n                    graph[value2.row as usize][value2.col as usize].remove_dep(target);\n                }\n            }\n            Operation::Cons | Operation::Slp =\u003e {\n                // single cell operation just check value1 and apply the cases\n                // cell\n                if value1.col != -1 \u0026\u0026 value1.row != -1 {\n                    graph[value1.row as usize][value1.col as usize].remove_dep(target);\n                }\n                // value -- do nothing\n            }\n            _ =\u003e {} // will not reach here\n        }\n    } else {\n        // Get the previous dependencies (value1 and value2)\n        let old_value1 = target_cell.value1;\n        let old_value2 = target_cell.value2;\n\n        // If old value1 is valid (not -1), remove dependencies\n        // Check if the operation is range-based\n        match target_cell.op {\n            Operation::Sum | Operation::Avg | Operation::Max | Operation::Min =\u003e {\n                // For range operations, remove from all cells in the range\n                for i in old_value1.row..=old_value2.row {\n                    for j in old_value1.col..=old_value2.col {\n                        if i \u003e= 0 \u0026\u0026 j \u003e= 0 {\n                            let r = i as usize;\n                            let c = j as usize;\n                            graph[r][c].remove_dep(target);\n                        }\n                    }\n                }\n            }\n            Operation::Add | Operation::Sub | Operation::Mul | Operation::Div =\u003e {\n                // For binary operations, remove dependency from value1 and value2 - check cells and values\n                if old_value1.col != -1 {\n                    graph[old_value1.row as usize][old_value1.col as usize].remove_dep(target);\n                }\n                if old_value2.col != -1 {\n                    graph[old_value2.row as usize][old_value2.col as usize].remove_dep(target);\n                }\n            }\n            Operation::Cons | Operation::Slp =\u003e {\n                // single cell operation just check value1 and apply the cases\n                // cell\n                if old_value1.col != -1 \u0026\u0026 old_value1.row != -1 {\n                    graph[old_value1.row as usize][old_value1.col as usize].remove_dep(target);\n                }\n                // value -- do nothing\n            }\n            _ =\u003e {} // will not reach here\n        }\n    }\n}\n\n/// Updates the target cell and its dependencies in the graph.\n///\n/// # Arguments\n///\n/// * `graph` - The dependency graph represented as a 2D vector of `Node`s\n/// * `target` - The target cell to be updated\n/// * `value1` - The first value involved in the operation\n/// * `value2` - The second value involved in the operation\n/// * `op` - The operation to be performed\n///\n/// # Returns\n///\n/// An integer status code indicating success (1) or failure (5)\npub fn getting_things_updated(\n    graph: \u0026mut Vec\u003cVec\u003cNode\u003e\u003e,\n    target: Coordinates,\n    value1: Coordinates,\n    value2: Coordinates,\n    op: Operation,\n    // r: usize,\n    // c: usize,\n) -\u003e i32 {\n    // so at this point of time value1 and value2 will store the new ranges of the new function to be applied on target cell\n    // will call update_node (breaking and adding edges)\n    // break previous inward dependecies (will remove the target from its previous parents)\n    // add new dependencies of target in parent's vector\n    // old_op :\n    // println!(\"Old op: {:?}\", graph[target.row as usize][target.col as usize].op);// debug\n    break_edges(graph, value1, value2, target, op, false); // old dependencies\n    add_edges(graph, value1, value2, target, op, true); // new dependencies\n    // check if new dependecies introduces cycle\n    if has_cycle(target, graph) {\n        // println!(\"Cycle detected!\"); // debug\n        break_edges(graph, value1, value2, target, op, true); // new dependencies\n        add_edges(graph, value1, value2, target, op, false); // old dependencies\n        return 5;\n    }\n\n    // go to dependents of the cell and change their values\n    graph[target.row as usize][target.col as usize].op = op;\n    graph[target.row as usize][target.col as usize].value1.row = value1.row;\n    graph[target.row as usize][target.col as usize].value1.col = value1.col;\n    graph[target.row as usize][target.col as usize].value2.row = value2.row;\n    graph[target.row as usize][target.col as usize].value2.col = value2.col;\n\n    // evaluate_node(graph, target);\n    update_topo(graph, target);\n\n    1 // success\n}\n\n/// Updates the topological order of the graph starting from the specified cell.\n///\n/// # Arguments\n///\n/// * `graph` - The dependency graph represented as a 2D vector of `Node`s\n/// * `start` - The starting cell for the topological sort\npub fn update_topo(graph: \u0026mut Vec\u003cVec\u003cNode\u003e\u003e, start: Coordinates) {\n    let mut stack = Vec::new();\n\n    topological_sort(graph, start, \u0026mut stack);\n\n    while let Some(coord) = stack.pop() {\n        evaluate_node(graph, coord);\n    }\n\n    // Reset visited flags so next call works correctly\n    reset_visited(graph, start);\n}\n\n/// Performs a topological sort on the graph starting from the specified cell.\n///\n/// # Arguments\n///\n/// * `graph` - The dependency graph represented as a 2D vector of `Node`s\n/// * `node` - The starting cell for the topological sort\n/// * `stack` - A stack to store the sorted cells\npub fn topological_sort(\n    graph: \u0026mut Vec\u003cVec\u003cNode\u003e\u003e,\n    node: Coordinates,\n    stack: \u0026mut Vec\u003cCoordinates\u003e,\n) {\n    let (i, j) = (node.row as usize, node.col as usize);\n    if graph[i][j].visited {\n        return;\n    }\n\n    // Mark visited before recursive calls\n    graph[i][j].visited = true;\n\n    // Clone dependents to avoid borrowing `graph[i][j]` during iteration\n    let dependents = graph[i][j].dependents.clone();\n\n    for dep in dependents {\n        topological_sort(graph, dep, stack);\n    }\n\n    stack.push(node);\n}\n\n/// Evaluates the value of a node based on its operation and dependencies.\n///\n/// # Arguments\n///\n/// * `graph` - The dependency graph represented as a 2D vector of `Node`s\n/// * `coord` - The coordinates of the node to be evaluated\npub fn evaluate_node(graph: \u0026mut [Vec\u003cNode\u003e], coord: Coordinates) {\n    let row = coord.row as usize;\n    let col = coord.col as usize;\n\n    // extract value1 and value2 before borrowing node\n    let value1 = graph[row][col].value1;\n    let value2 = graph[row][col].value2;\n    //  check here it is going out of bounds (A1=3 - like first command it will go out of bounds)\n    // let value1_valid = graph[value1.row as usize][value1.col as usize].valid;\n    let value1_valid = if value1.row \u003e= 0\n        \u0026\u0026 value1.col \u003e= 0\n        \u0026\u0026 (value1.row as usize) \u003c graph.len()\n        \u0026\u0026 (value1.col as usize) \u003c graph[0].len()\n    {\n        graph[value1.row as usize][value1.col as usize].valid\n    } else {\n        true // assume constants are always valid\n    };\n    let value2_valid = if value2.row \u003e= 0\n        \u0026\u0026 value2.col \u003e= 0\n        \u0026\u0026 (value2.row as usize) \u003c graph.len()\n        \u0026\u0026 (value2.col as usize) \u003c graph[0].len()\n    {\n        graph[value2.row as usize][value2.col as usize].valid\n    } else {\n        true // assume constants are always valid\n    };\n    // let value2_valid = graph[value2.row as usize][value2.col as usize].valid;\n    let value1_node_value = if value1.row \u003e= 0\n        \u0026\u0026 value1.col \u003e= 0\n        \u0026\u0026 (value1.row as usize) \u003c graph.len()\n        \u0026\u0026 (value1.col as usize) \u003c graph[0].len()\n    {\n        graph[value1.row as usize][value1.col as usize].node_value\n    } else {\n        value1.row // constant\n    };\n\n    let value2_node_value = if value2.row \u003e= 0\n        \u0026\u0026 value2.col \u003e= 0\n        \u0026\u0026 (value2.row as usize) \u003c graph.len()\n        \u0026\u0026 (value2.col as usize) \u003c graph[0].len()\n    {\n        graph[value2.row as usize][value2.col as usize].node_value\n    } else {\n        value2.row // constant\n    };\n    let op = graph[row][col].op;\n\n    // evaluate range result before mutable borrow\n    let range_result = match op {\n        Operation::Min =\u003e min_function(value1, value2, graph),\n        Operation::Max =\u003e max_function(value1, value2, graph),\n        Operation::Avg =\u003e avg_function(value1, value2, graph),\n        Operation::Sum =\u003e sum_function(value1, value2, graph),\n        Operation::Std =\u003e stdev_function(value1, value2, graph),\n        _ =\u003e None,\n    };\n\n    let node = \u0026mut graph[row][col];\n\n    match node.op {\n        Operation::Add =\u003e {\n            // V V\n            if node.value1.col == -1 \u0026\u0026 node.value2.col == -1 {\n                node.valid = true;\n                node.node_value = node.value1.row + node.value2.row;\n            }\n            // V C\n            else if node.value1.col == -1 {\n                if value2_valid {\n                    node.valid = true;\n                    node.node_value = node.value1.row + value2_node_value;\n                } else {\n                    node.valid = false;\n                }\n            }\n            // C V\n            else if node.value2.col == -1 {\n                if value1_valid {\n                    node.valid = true;\n                    node.node_value = value1_node_value + node.value2.row;\n                } else {\n                    node.valid = false;\n                }\n            }\n            // C C\n            else if value1_valid \u0026\u0026 value2_valid {\n                node.valid = true;\n                node.node_value = value1_node_value + value2_node_value;\n            } else {\n                node.valid = false;\n            }\n        }\n        Operation::Sub =\u003e {\n            // V V\n            if node.value1.col == -1 \u0026\u0026 node.value2.col == -1 {\n                node.valid = true;\n                node.node_value = node.value1.row - node.value2.row;\n            }\n            // V C\n            else if node.value1.col == -1 {\n                if value2_valid {\n                    node.valid = true;\n                    node.node_value = node.value1.row - value2_node_value;\n                } else {\n                    node.valid = false;\n                }\n            }\n            // C V\n            else if node.value2.col == -1 {\n                if value1_valid {\n                    node.valid = true;\n                    node.node_value = value1_node_value - node.value2.row;\n                } else {\n                    node.valid = false;\n                }\n            }\n            // C C\n            else if value1_valid \u0026\u0026 value2_valid {\n                node.valid = true;\n                node.node_value = value1_node_value - value2_node_value;\n            } else {\n                node.valid = false;\n            }\n        }\n        Operation::Mul =\u003e {\n            // V V\n            if node.value1.col == -1 \u0026\u0026 node.value2.col == -1 {\n                node.valid = true;\n                node.node_value = node.value1.row * node.value2.row;\n            }\n            // V C\n            else if node.value1.col == -1 {\n                if value2_valid {\n                    node.valid = true;\n                    node.node_value = node.value1.row * value2_node_value;\n                } else {\n                    node.valid = false;\n                }\n            }\n            // C V\n            else if node.value2.col == -1 {\n                if value1_valid {\n                    node.valid = true;\n                    node.node_value = value1_node_value * node.value2.row;\n                } else {\n                    node.valid = false;\n                }\n            }\n            // C C\n            else if value1_valid \u0026\u0026 value2_valid {\n                node.valid = true;\n                node.node_value = value1_node_value * value2_node_value;\n            } else {\n                node.valid = false;\n            }\n        }\n        Operation::Div =\u003e {\n            // handle ERR here /// debug\n            // V V\n            if node.value1.col == -1 \u0026\u0026 node.value2.col == -1 {\n                if node.value2.row == 0 {\n                    node.valid = false;\n                } else {\n                    node.valid = true;\n                    node.node_value = node.value1.row / node.value2.row;\n                }\n            }\n            // V C\n            else if node.value1.col == -1 {\n                if value2_valid {\n                    if value2_node_value == 0 {\n                        node.valid = false;\n                    } else {\n                        node.valid = true;\n                        node.node_value = node.value1.row / value2_node_value;\n                    }\n                } else {\n                    node.valid = false;\n                }\n            }\n            // C V\n            else if node.value2.col == -1 {\n                if value1_valid {\n                    if node.value2.row == 0 {\n                        node.valid = false;\n                    } else {\n                        node.valid = true;\n                        node.node_value = value1_node_value / node.value2.row;\n                    }\n                } else {\n                    node.valid = false;\n                }\n            }\n            // C C\n            else if value1_valid \u0026\u0026 value2_valid {\n                if value2_node_value == 0 {\n                    node.valid = false;\n                } else {\n                    node.valid = true;\n                    node.node_value = value1_node_value / value2_node_value;\n                }\n            } else {\n                node.valid = false;\n            }\n        }\n        // range based functions\n        Operation::Min | Operation::Max | Operation::Avg | Operation::Sum | Operation::Std =\u003e {\n            if let Some(result) = range_result {\n                node.node_value = result;\n                node.valid = true;\n            } else {\n                node.valid = false;\n            }\n        }\n        // sleep function\n        Operation::Slp =\u003e {\n            // Handle sleep operation\n            // std::thread::sleep(std::time::Duration::from_secs(1));\n            // V or C\n            if (node.value1.col == -1 \u0026\u0026 node.value2.col == -1) || value1_valid {\n                node.valid = true;\n                node.node_value = value1_node_value;\n                std::thread::sleep(std::time::Duration::from_secs(value1_node_value as u64));\n            } else {\n                node.valid = false;\n            }\n        }\n        #[allow(clippy::if_same_then_else)]\n        Operation::Cons =\u003e {\n            // Handle constant assignment\n            // No operation needed, just set the value\n            node.valid = true;\n            // V\n            if node.value1.col == -1 \u0026\u0026 node.value2.col == -1 {\n                node.valid = true;\n                node.node_value = value1_node_value;\n            }\n            // C\n            else if value1_valid {\n                node.valid = true;\n                node.node_value = value1_node_value;\n            } else {\n                node.valid = false;\n            }\n        }\n        _ =\u003e {}\n    }\n}\n\n/// Checks for cycles in the dependency graph starting from the target cell.\n///\n/// # Arguments\n///\n/// * `target` - The target cell to check for cycles\n/// * `graph` - The dependency graph represented as a 2D vector of `Node`s\n///\n/// # Returns\n///\n/// A boolean indicating whether a cycle was detected (true) or not (false)\npub fn has_cycle(target: Coordinates, graph: \u0026mut [Vec\u003cNode\u003e]) -\u003e bool {\n    // check for cycle using iterative DFS\n    // use stack\n    // reset visited flags\n    let mut stack = vec![target];\n    graph[target.row as usize][target.col as usize].visited = true;\n    while let Some(node1) = stack.pop() {\n        // borrow checker error\n        // let node = \u0026mut graph[node1.row as usize][node1.col as usize];\n        let dependents = graph[node1.row as usize][node1.col as usize]\n            .dependents\n            .clone();\n\n        for dep in dependents {\n            if dep.row == target.row \u0026\u0026 dep.col == target.col {\n                // back edge to target → cycle\n                reset_visited(graph, target);\n                return true;\n            }\n\n            if !graph[dep.row as usize][dep.col as usize].visited {\n                graph[dep.row as usize][dep.col as usize].visited = true;\n                stack.push(dep);\n            }\n        }\n    }\n\n    reset_visited(graph, target);\n    false\n}\n\n// redo dfs to reset flags\n\n/// Resets the visited flags in the graph starting from the specified cell.\n///\n/// # Arguments\n///\n/// * `graph` - The dependency graph represented as a 2D vector of `Node`s\n/// * `start` - The starting cell for resetting visited flags\npub fn reset_visited(graph: \u0026mut [Vec\u003cNode\u003e], start: Coordinates) {\n    let mut stack = vec![start];\n    graph[start.row as usize][start.col as usize].visited = false;\n\n    while let Some(node1) = stack.pop() {\n        // clone dependents first\n        let dependents = graph[node1.row as usize][node1.col as usize]\n            .dependents\n            .clone();\n\n        for dep in dependents {\n            let dep_node = \u0026mut graph[dep.row as usize][dep.col as usize];\n            if dep_node.visited {\n                dep_node.visited = false;\n                stack.push(dep);\n            }\n        }\n    }\n}\n","traces":[{"line":28,"address":[],"length":0,"stats":{"Line":37}},{"line":29,"address":[],"length":0,"stats":{"Line":37}},{"line":30,"address":[],"length":0,"stats":{"Line":185}},{"line":31,"address":[],"length":0,"stats":{"Line":148}},{"line":32,"address":[],"length":0,"stats":{"Line":740}},{"line":33,"address":[],"length":0,"stats":{"Line":592}},{"line":34,"address":[],"length":0,"stats":{"Line":592}},{"line":35,"address":[],"length":0,"stats":{"Line":592}},{"line":36,"address":[],"length":0,"stats":{"Line":592}},{"line":37,"address":[],"length":0,"stats":{"Line":592}},{"line":38,"address":[],"length":0,"stats":{"Line":592}},{"line":40,"address":[],"length":0,"stats":{"Line":592}},{"line":41,"address":[],"length":0,"stats":{"Line":592}},{"line":42,"address":[],"length":0,"stats":{"Line":592}},{"line":43,"address":[],"length":0,"stats":{"Line":592}},{"line":45,"address":[],"length":0,"stats":{"Line":148}},{"line":65,"address":[],"length":0,"stats":{"Line":38}},{"line":73,"address":[],"length":0,"stats":{"Line":38}},{"line":74,"address":[],"length":0,"stats":{"Line":38}},{"line":75,"address":[],"length":0,"stats":{"Line":38}},{"line":76,"address":[],"length":0,"stats":{"Line":38}},{"line":77,"address":[],"length":0,"stats":{"Line":37}},{"line":80,"address":[],"length":0,"stats":{"Line":6}},{"line":81,"address":[],"length":0,"stats":{"Line":12}},{"line":82,"address":[],"length":0,"stats":{"Line":24}},{"line":83,"address":[],"length":0,"stats":{"Line":8}},{"line":84,"address":[],"length":0,"stats":{"Line":8}},{"line":85,"address":[],"length":0,"stats":{"Line":8}},{"line":92,"address":[],"length":0,"stats":{"Line":66}},{"line":93,"address":[],"length":0,"stats":{"Line":33}},{"line":95,"address":[],"length":0,"stats":{"Line":56}},{"line":96,"address":[],"length":0,"stats":{"Line":23}},{"line":102,"address":[],"length":0,"stats":{"Line":1}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":1}},{"line":110,"address":[],"length":0,"stats":{"Line":1}},{"line":111,"address":[],"length":0,"stats":{"Line":1}},{"line":113,"address":[],"length":0,"stats":{"Line":1}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":1}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":11}},{"line":171,"address":[],"length":0,"stats":{"Line":11}},{"line":172,"address":[],"length":0,"stats":{"Line":11}},{"line":173,"address":[],"length":0,"stats":{"Line":11}},{"line":174,"address":[],"length":0,"stats":{"Line":11}},{"line":175,"address":[],"length":0,"stats":{"Line":3}},{"line":178,"address":[],"length":0,"stats":{"Line":3}},{"line":179,"address":[],"length":0,"stats":{"Line":6}},{"line":180,"address":[],"length":0,"stats":{"Line":12}},{"line":181,"address":[],"length":0,"stats":{"Line":4}},{"line":182,"address":[],"length":0,"stats":{"Line":4}},{"line":183,"address":[],"length":0,"stats":{"Line":4}},{"line":190,"address":[],"length":0,"stats":{"Line":4}},{"line":191,"address":[],"length":0,"stats":{"Line":2}},{"line":193,"address":[],"length":0,"stats":{"Line":3}},{"line":194,"address":[],"length":0,"stats":{"Line":1}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":8}},{"line":210,"address":[],"length":0,"stats":{"Line":8}},{"line":214,"address":[],"length":0,"stats":{"Line":8}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":10}},{"line":230,"address":[],"length":0,"stats":{"Line":5}},{"line":232,"address":[],"length":0,"stats":{"Line":10}},{"line":233,"address":[],"length":0,"stats":{"Line":5}},{"line":239,"address":[],"length":0,"stats":{"Line":3}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":8}},{"line":277,"address":[],"length":0,"stats":{"Line":8}},{"line":278,"address":[],"length":0,"stats":{"Line":8}},{"line":280,"address":[],"length":0,"stats":{"Line":8}},{"line":282,"address":[],"length":0,"stats":{"Line":1}},{"line":283,"address":[],"length":0,"stats":{"Line":1}},{"line":284,"address":[],"length":0,"stats":{"Line":1}},{"line":288,"address":[],"length":0,"stats":{"Line":7}},{"line":289,"address":[],"length":0,"stats":{"Line":7}},{"line":290,"address":[],"length":0,"stats":{"Line":7}},{"line":291,"address":[],"length":0,"stats":{"Line":7}},{"line":292,"address":[],"length":0,"stats":{"Line":7}},{"line":295,"address":[],"length":0,"stats":{"Line":7}},{"line":297,"address":[],"length":0,"stats":{"Line":7}},{"line":306,"address":[],"length":0,"stats":{"Line":8}},{"line":307,"address":[],"length":0,"stats":{"Line":8}},{"line":309,"address":[],"length":0,"stats":{"Line":8}},{"line":311,"address":[],"length":0,"stats":{"Line":38}},{"line":312,"address":[],"length":0,"stats":{"Line":10}},{"line":316,"address":[],"length":0,"stats":{"Line":8}},{"line":326,"address":[],"length":0,"stats":{"Line":13}},{"line":331,"address":[],"length":0,"stats":{"Line":13}},{"line":332,"address":[],"length":0,"stats":{"Line":13}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":13}},{"line":340,"address":[],"length":0,"stats":{"Line":13}},{"line":342,"address":[],"length":0,"stats":{"Line":25}},{"line":343,"address":[],"length":0,"stats":{"Line":4}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":84}},{"line":356,"address":[],"length":0,"stats":{"Line":84}},{"line":357,"address":[],"length":0,"stats":{"Line":84}},{"line":360,"address":[],"length":0,"stats":{"Line":84}},{"line":361,"address":[],"length":0,"stats":{"Line":84}},{"line":364,"address":[],"length":0,"stats":{"Line":168}},{"line":365,"address":[],"length":0,"stats":{"Line":84}},{"line":366,"address":[],"length":0,"stats":{"Line":27}},{"line":367,"address":[],"length":0,"stats":{"Line":23}},{"line":369,"address":[],"length":0,"stats":{"Line":23}},{"line":371,"address":[],"length":0,"stats":{"Line":61}},{"line":373,"address":[],"length":0,"stats":{"Line":168}},{"line":374,"address":[],"length":0,"stats":{"Line":29}},{"line":375,"address":[],"length":0,"stats":{"Line":20}},{"line":376,"address":[],"length":0,"stats":{"Line":20}},{"line":378,"address":[],"length":0,"stats":{"Line":20}},{"line":380,"address":[],"length":0,"stats":{"Line":64}},{"line":383,"address":[],"length":0,"stats":{"Line":168}},{"line":384,"address":[],"length":0,"stats":{"Line":84}},{"line":385,"address":[],"length":0,"stats":{"Line":27}},{"line":386,"address":[],"length":0,"stats":{"Line":23}},{"line":388,"address":[],"length":0,"stats":{"Line":23}},{"line":390,"address":[],"length":0,"stats":{"Line":61}},{"line":393,"address":[],"length":0,"stats":{"Line":168}},{"line":394,"address":[],"length":0,"stats":{"Line":29}},{"line":395,"address":[],"length":0,"stats":{"Line":20}},{"line":396,"address":[],"length":0,"stats":{"Line":20}},{"line":398,"address":[],"length":0,"stats":{"Line":20}},{"line":400,"address":[],"length":0,"stats":{"Line":64}},{"line":402,"address":[],"length":0,"stats":{"Line":84}},{"line":405,"address":[],"length":0,"stats":{"Line":168}},{"line":406,"address":[],"length":0,"stats":{"Line":1}},{"line":407,"address":[],"length":0,"stats":{"Line":1}},{"line":408,"address":[],"length":0,"stats":{"Line":1}},{"line":409,"address":[],"length":0,"stats":{"Line":1}},{"line":410,"address":[],"length":0,"stats":{"Line":1}},{"line":411,"address":[],"length":0,"stats":{"Line":79}},{"line":414,"address":[],"length":0,"stats":{"Line":84}},{"line":416,"address":[],"length":0,"stats":{"Line":84}},{"line":419,"address":[],"length":0,"stats":{"Line":11}},{"line":420,"address":[],"length":0,"stats":{"Line":1}},{"line":421,"address":[],"length":0,"stats":{"Line":1}},{"line":424,"address":[],"length":0,"stats":{"Line":7}},{"line":425,"address":[],"length":0,"stats":{"Line":2}},{"line":426,"address":[],"length":0,"stats":{"Line":1}},{"line":427,"address":[],"length":0,"stats":{"Line":1}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":6}},{"line":434,"address":[],"length":0,"stats":{"Line":4}},{"line":435,"address":[],"length":0,"stats":{"Line":2}},{"line":436,"address":[],"length":0,"stats":{"Line":2}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":11}},{"line":443,"address":[],"length":0,"stats":{"Line":3}},{"line":444,"address":[],"length":0,"stats":{"Line":3}},{"line":446,"address":[],"length":0,"stats":{"Line":1}},{"line":451,"address":[],"length":0,"stats":{"Line":9}},{"line":452,"address":[],"length":0,"stats":{"Line":1}},{"line":453,"address":[],"length":0,"stats":{"Line":1}},{"line":456,"address":[],"length":0,"stats":{"Line":5}},{"line":457,"address":[],"length":0,"stats":{"Line":2}},{"line":458,"address":[],"length":0,"stats":{"Line":1}},{"line":459,"address":[],"length":0,"stats":{"Line":1}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":465,"address":[],"length":0,"stats":{"Line":4}},{"line":466,"address":[],"length":0,"stats":{"Line":2}},{"line":467,"address":[],"length":0,"stats":{"Line":1}},{"line":468,"address":[],"length":0,"stats":{"Line":1}},{"line":470,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[],"length":0,"stats":{"Line":9}},{"line":475,"address":[],"length":0,"stats":{"Line":3}},{"line":476,"address":[],"length":0,"stats":{"Line":3}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":483,"address":[],"length":0,"stats":{"Line":10}},{"line":484,"address":[],"length":0,"stats":{"Line":1}},{"line":485,"address":[],"length":0,"stats":{"Line":1}},{"line":488,"address":[],"length":0,"stats":{"Line":6}},{"line":489,"address":[],"length":0,"stats":{"Line":2}},{"line":490,"address":[],"length":0,"stats":{"Line":1}},{"line":491,"address":[],"length":0,"stats":{"Line":1}},{"line":493,"address":[],"length":0,"stats":{"Line":0}},{"line":497,"address":[],"length":0,"stats":{"Line":5}},{"line":498,"address":[],"length":0,"stats":{"Line":6}},{"line":499,"address":[],"length":0,"stats":{"Line":3}},{"line":500,"address":[],"length":0,"stats":{"Line":3}},{"line":502,"address":[],"length":0,"stats":{"Line":0}},{"line":506,"address":[],"length":0,"stats":{"Line":6}},{"line":507,"address":[],"length":0,"stats":{"Line":2}},{"line":508,"address":[],"length":0,"stats":{"Line":2}},{"line":510,"address":[],"length":0,"stats":{"Line":0}},{"line":516,"address":[],"length":0,"stats":{"Line":3}},{"line":517,"address":[],"length":0,"stats":{"Line":0}},{"line":518,"address":[],"length":0,"stats":{"Line":0}},{"line":520,"address":[],"length":0,"stats":{"Line":0}},{"line":521,"address":[],"length":0,"stats":{"Line":0}},{"line":525,"address":[],"length":0,"stats":{"Line":3}},{"line":526,"address":[],"length":0,"stats":{"Line":0}},{"line":527,"address":[],"length":0,"stats":{"Line":0}},{"line":528,"address":[],"length":0,"stats":{"Line":0}},{"line":530,"address":[],"length":0,"stats":{"Line":0}},{"line":531,"address":[],"length":0,"stats":{"Line":0}},{"line":534,"address":[],"length":0,"stats":{"Line":0}},{"line":538,"address":[],"length":0,"stats":{"Line":3}},{"line":539,"address":[],"length":0,"stats":{"Line":0}},{"line":540,"address":[],"length":0,"stats":{"Line":0}},{"line":541,"address":[],"length":0,"stats":{"Line":0}},{"line":543,"address":[],"length":0,"stats":{"Line":0}},{"line":544,"address":[],"length":0,"stats":{"Line":0}},{"line":547,"address":[],"length":0,"stats":{"Line":0}},{"line":551,"address":[],"length":0,"stats":{"Line":6}},{"line":552,"address":[],"length":0,"stats":{"Line":5}},{"line":553,"address":[],"length":0,"stats":{"Line":2}},{"line":555,"address":[],"length":0,"stats":{"Line":1}},{"line":556,"address":[],"length":0,"stats":{"Line":1}},{"line":559,"address":[],"length":0,"stats":{"Line":0}},{"line":564,"address":[],"length":0,"stats":{"Line":10}},{"line":565,"address":[],"length":0,"stats":{"Line":0}},{"line":566,"address":[],"length":0,"stats":{"Line":0}},{"line":568,"address":[],"length":0,"stats":{"Line":0}},{"line":576,"address":[],"length":0,"stats":{"Line":3}},{"line":577,"address":[],"length":0,"stats":{"Line":1}},{"line":578,"address":[],"length":0,"stats":{"Line":1}},{"line":579,"address":[],"length":0,"stats":{"Line":1}},{"line":581,"address":[],"length":0,"stats":{"Line":0}},{"line":588,"address":[],"length":0,"stats":{"Line":54}},{"line":590,"address":[],"length":0,"stats":{"Line":154}},{"line":591,"address":[],"length":0,"stats":{"Line":50}},{"line":592,"address":[],"length":0,"stats":{"Line":50}},{"line":595,"address":[],"length":0,"stats":{"Line":8}},{"line":596,"address":[],"length":0,"stats":{"Line":4}},{"line":597,"address":[],"length":0,"stats":{"Line":4}},{"line":599,"address":[],"length":0,"stats":{"Line":0}},{"line":602,"address":[],"length":0,"stats":{"Line":0}},{"line":616,"address":[],"length":0,"stats":{"Line":11}},{"line":620,"address":[],"length":0,"stats":{"Line":11}},{"line":621,"address":[],"length":0,"stats":{"Line":11}},{"line":622,"address":[],"length":0,"stats":{"Line":38}},{"line":625,"address":[],"length":0,"stats":{"Line":0}},{"line":626,"address":[],"length":0,"stats":{"Line":0}},{"line":629,"address":[],"length":0,"stats":{"Line":26}},{"line":630,"address":[],"length":0,"stats":{"Line":7}},{"line":632,"address":[],"length":0,"stats":{"Line":3}},{"line":633,"address":[],"length":0,"stats":{"Line":3}},{"line":636,"address":[],"length":0,"stats":{"Line":8}},{"line":637,"address":[],"length":0,"stats":{"Line":4}},{"line":638,"address":[],"length":0,"stats":{"Line":4}},{"line":643,"address":[],"length":0,"stats":{"Line":8}},{"line":644,"address":[],"length":0,"stats":{"Line":8}},{"line":655,"address":[],"length":0,"stats":{"Line":20}},{"line":656,"address":[],"length":0,"stats":{"Line":20}},{"line":657,"address":[],"length":0,"stats":{"Line":20}},{"line":659,"address":[],"length":0,"stats":{"Line":76}},{"line":661,"address":[],"length":0,"stats":{"Line":0}},{"line":662,"address":[],"length":0,"stats":{"Line":0}},{"line":665,"address":[],"length":0,"stats":{"Line":50}},{"line":666,"address":[],"length":0,"stats":{"Line":0}},{"line":667,"address":[],"length":0,"stats":{"Line":8}},{"line":668,"address":[],"length":0,"stats":{"Line":8}},{"line":669,"address":[],"length":0,"stats":{"Line":8}}],"covered":212,"coverable":274},{"path":["/","Users","yuvikachaudhary","Desktop","Semester 4","COP290","spreadsheet_rust","src","terminal","functions.rs"],"content":"/// Module for spreadsheet functions implementation.\n///\n/// Provides implementations of various cell operations including:\n/// - Range-based operations (SUM, MIN, MAX, AVG, STDEV)\n/// - Arithmetic operations (Add, Sub, Mul, Div)\n/// - Special operations like Sleep and Constant assignment\n///\n/// These functions are the core computational elements of the spreadsheet.\nuse crate::terminal::graph::Node;\nuse crate::terminal::types::Coordinates;\nuse std::cmp::{max, min};\n\n/// Represents a range of cells in the spreadsheet.\n///\n/// Used for range-based functions like SUM, MIN, MAX, AVG, and STDEV\n/// to specify the corners of a rectangular selection of cells.\npub struct Range {\n    /// The starting cell (top-left corner) of the range\n    pub start: Coordinates,\n\n    /// The ending cell (bottom-right corner) of the range\n    pub end: Coordinates,\n}\n\n/// Supported operations in the spreadsheet.\n///\n/// This enum defines all possible operations that can be performed\n/// on cells in the spreadsheet, including both arithmetic operations\n/// and range-based functions.\n#[derive(Clone, Copy, Debug, PartialEq, Default)]\npub enum Operation {\n    /// Assign a constant value to a cell\n    #[default]\n    Cons,\n\n    /// Add two values\n    Add,\n\n    /// Subtract one value from another\n    Sub,\n\n    /// Multiply two values\n    Mul,\n\n    /// Divide one value by another\n    Div,\n\n    /// Find the minimum value in a range\n    Min,\n\n    /// Find the maximum value in a range\n    Max,\n\n    /// Calculate the average of values in a range\n    Avg,\n\n    /// Calculate the sum of values in a range\n    Sum,\n\n    /// Calculate the standard deviation of values in a range\n    Std,\n\n    /// Sleep operation (pause execution)\n    Slp,\n\n    /// Enable output to the terminal\n    EnableOutput,\n\n    /// Disable output to the terminal\n    DisableOutput,\n\n    /// Scroll to a specific cell\n    Scrollto,\n}\n\n/// Represents a value in the spreadsheet expression system.\n///\n/// Values can be cell references, constants, or operations involving\n/// other values.\n#[derive(Debug, PartialEq)]\npub enum Value {\n    /// A cell reference with row and column indices\n    Cell(i32, i32),\n\n    /// A constant integer value\n    Const(isize),\n\n    /// An operation involving two values and an operator\n    Oper(Box\u003cValue\u003e, Box\u003cValue\u003e, Operation),\n}\n\n/// Computes the maximum value in a specified range of cells.\n///\n/// # Arguments\n///\n/// * `value1` - The starting cell (top-left corner) of the range.\n/// * `value2` - The ending cell (bottom-right corner) of the range.\n/// * `grid` - The 2D array representing the spreadsheet.\n///\n/// # Returns\n///\n/// * `Some(i32)` - The maximum value in the range if all cells are valid.\n/// * `None` - If any cell in the range is invalid.\npub fn max_function(value1: Coordinates, value2: Coordinates, grid: \u0026[Vec\u003cNode\u003e]) -\u003e Option\u003ci32\u003e {\n    let mut max_val = i32::MIN;\n    for i in value1.row..=value2.row {\n        for j in value1.col..=value2.col {\n            if grid[i as usize][j as usize].valid {\n                max_val = max(max_val, grid[i as usize][j as usize].node_value);\n            } else {\n                return None;\n            }\n        }\n    }\n    Some(max_val)\n}\n\n/// Computes the minimum value in a specified range of cells.\n///\n/// # Arguments\n///\n/// * `value1` - The starting cell (top-left corner) of the range.\n/// * `value2` - The ending cell (bottom-right corner) of the range.\n/// * `grid` - The 2D array representing the spreadsheet.\n///\n/// # Returns\n///\n/// * `Some(i32)` - The minimum value in the range if all cells are valid.\n/// * `None` - If any cell in the range is invalid.\npub fn min_function(value1: Coordinates, value2: Coordinates, grid: \u0026[Vec\u003cNode\u003e]) -\u003e Option\u003ci32\u003e {\n    let mut min_val = i32::MAX;\n    for i in value1.row..=value2.row {\n        for j in value1.col..=value2.col {\n            if grid[i as usize][j as usize].valid {\n                min_val = min(min_val, grid[i as usize][j as usize].node_value);\n            } else {\n                return None;\n            }\n        }\n    }\n    Some(min_val)\n}\n\n/// Computes the average value in a specified range of cells.\n///\n/// # Arguments\n///\n/// * `value1` - The starting cell (top-left corner) of the range.\n/// * `value2` - The ending cell (bottom-right corner) of the range.\n/// * `grid` - The 2D array representing the spreadsheet.\n///\n/// # Returns\n///\n/// * `Some(i32)` - The average value in the range if all cells are valid.\n/// * `None` - If any cell in the range is invalid.\npub fn avg_function(value1: Coordinates, value2: Coordinates, grid: \u0026[Vec\u003cNode\u003e]) -\u003e Option\u003ci32\u003e {\n    let mut sum = 0;\n    let mut count = 0;\n    for i in value1.row..=value2.row {\n        for j in value1.col..=value2.col {\n            if grid[i as usize][j as usize].valid {\n                sum += grid[i as usize][j as usize].node_value;\n                count += 1;\n            } else {\n                return None;\n            }\n        }\n    }\n    if count == 0 { None } else { Some(sum / count) }\n}\n\n/// Computes the sum of values in a specified range of cells.\n///\n/// # Arguments\n///\n/// * `value1` - The starting cell (top-left corner) of the range.\n/// * `value2` - The ending cell (bottom-right corner) of the range.\n/// * `grid` - The 2D array representing the spreadsheet.\n///\n/// # Returns\n///\n/// * `Some(i32)` - The sum of values in the range if all cells are valid.\n/// * `None` - If any cell in the range is invalid.\npub fn sum_function(value1: Coordinates, value2: Coordinates, grid: \u0026[Vec\u003cNode\u003e]) -\u003e Option\u003ci32\u003e {\n    let mut sum = 0;\n    for i in value1.row..=value2.row {\n        for j in value1.col..=value2.col {\n            if grid[i as usize][j as usize].valid {\n                sum += grid[i as usize][j as usize].node_value;\n            } else {\n                return None;\n            }\n        }\n    }\n    Some(sum)\n}\n\n/// Computes the standard deviation of values in a specified range of cells.\n///\n/// # Arguments\n///\n/// * `value1` - The starting cell (top-left corner) of the range.\n/// * `value2` - The ending cell (bottom-right corner) of the range.\n/// * `grid` - The 2D array representing the spreadsheet.\n///\n/// # Returns\n///\n/// * `Some(i32)` - The standard deviation of values in the range if all cells are valid.\n/// * `None` - If any cell in the range is invalid.\npub fn stdev_function(value1: Coordinates, value2: Coordinates, grid: \u0026[Vec\u003cNode\u003e]) -\u003e Option\u003ci32\u003e {\n    let mut sum = 0f64;\n    let mut count = 0;\n\n    // First pass: calculate sum and count\n    for i in value1.row..=value2.row {\n        for j in value1.col..=value2.col {\n            let node = \u0026grid[i as usize][j as usize];\n            if node.valid {\n                sum += node.node_value as f64;\n                count += 1;\n            } else {\n                return None;\n            }\n        }\n    }\n\n    if count == 0 {\n        return Some(0); // Consistent with C behavior\n    }\n\n    let mean = sum / count as f64;\n\n    // Second pass: calculate variance\n    let mut stdev = 0f64;\n    for i in value1.row..=value2.row {\n        for j in value1.col..=value2.col {\n            let node = \u0026grid[i as usize][j as usize];\n            if !node.valid {\n                return None; // In C, this sets the target to invalid\n            }\n            let val = node.node_value as f64;\n            stdev += (val - mean) * (val - mean);\n        }\n    }\n\n    let result = (stdev / count as f64).sqrt().round() as i32;\n    Some(result)\n}\n\n/// Checks if the given operation is an arithmetic operation.\n///\n/// # Arguments\n///\n/// * `op` - The operation to check.\n///\n/// # Returns\n///\n/// * `true` - If the operation is Add, Sub, Mul, or Div.\n/// * `false` - Otherwise.\npub fn is_arithmetic(op: Operation) -\u003e bool {\n    matches!(\n        op,\n        Operation::Add | Operation::Sub | Operation::Mul | Operation::Div\n    )\n}\n","traces":[{"line":104,"address":[],"length":0,"stats":{"Line":5}},{"line":105,"address":[],"length":0,"stats":{"Line":5}},{"line":106,"address":[],"length":0,"stats":{"Line":14}},{"line":107,"address":[],"length":0,"stats":{"Line":30}},{"line":108,"address":[],"length":0,"stats":{"Line":41}},{"line":109,"address":[],"length":0,"stats":{"Line":20}},{"line":111,"address":[],"length":0,"stats":{"Line":1}},{"line":115,"address":[],"length":0,"stats":{"Line":4}},{"line":130,"address":[],"length":0,"stats":{"Line":5}},{"line":131,"address":[],"length":0,"stats":{"Line":5}},{"line":132,"address":[],"length":0,"stats":{"Line":14}},{"line":133,"address":[],"length":0,"stats":{"Line":30}},{"line":134,"address":[],"length":0,"stats":{"Line":41}},{"line":135,"address":[],"length":0,"stats":{"Line":20}},{"line":137,"address":[],"length":0,"stats":{"Line":1}},{"line":141,"address":[],"length":0,"stats":{"Line":4}},{"line":156,"address":[],"length":0,"stats":{"Line":6}},{"line":157,"address":[],"length":0,"stats":{"Line":6}},{"line":158,"address":[],"length":0,"stats":{"Line":6}},{"line":159,"address":[],"length":0,"stats":{"Line":14}},{"line":160,"address":[],"length":0,"stats":{"Line":24}},{"line":161,"address":[],"length":0,"stats":{"Line":31}},{"line":162,"address":[],"length":0,"stats":{"Line":15}},{"line":163,"address":[],"length":0,"stats":{"Line":15}},{"line":165,"address":[],"length":0,"stats":{"Line":1}},{"line":169,"address":[],"length":0,"stats":{"Line":10}},{"line":184,"address":[],"length":0,"stats":{"Line":8}},{"line":185,"address":[],"length":0,"stats":{"Line":8}},{"line":186,"address":[],"length":0,"stats":{"Line":20}},{"line":187,"address":[],"length":0,"stats":{"Line":32}},{"line":188,"address":[],"length":0,"stats":{"Line":39}},{"line":189,"address":[],"length":0,"stats":{"Line":19}},{"line":191,"address":[],"length":0,"stats":{"Line":1}},{"line":195,"address":[],"length":0,"stats":{"Line":7}},{"line":210,"address":[],"length":0,"stats":{"Line":7}},{"line":211,"address":[],"length":0,"stats":{"Line":7}},{"line":212,"address":[],"length":0,"stats":{"Line":7}},{"line":215,"address":[],"length":0,"stats":{"Line":18}},{"line":216,"address":[],"length":0,"stats":{"Line":33}},{"line":217,"address":[],"length":0,"stats":{"Line":22}},{"line":218,"address":[],"length":0,"stats":{"Line":43}},{"line":219,"address":[],"length":0,"stats":{"Line":21}},{"line":220,"address":[],"length":0,"stats":{"Line":21}},{"line":222,"address":[],"length":0,"stats":{"Line":1}},{"line":227,"address":[],"length":0,"stats":{"Line":6}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":6}},{"line":234,"address":[],"length":0,"stats":{"Line":6}},{"line":235,"address":[],"length":0,"stats":{"Line":9}},{"line":236,"address":[],"length":0,"stats":{"Line":27}},{"line":237,"address":[],"length":0,"stats":{"Line":18}},{"line":238,"address":[],"length":0,"stats":{"Line":18}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":18}},{"line":242,"address":[],"length":0,"stats":{"Line":18}},{"line":246,"address":[],"length":0,"stats":{"Line":6}},{"line":247,"address":[],"length":0,"stats":{"Line":6}},{"line":260,"address":[],"length":0,"stats":{"Line":11}},{"line":261,"address":[],"length":0,"stats":{"Line":7}},{"line":262,"address":[],"length":0,"stats":{"Line":11}}],"covered":58,"coverable":60},{"path":["/","Users","yuvikachaudhary","Desktop","Semester 4","COP290","spreadsheet_rust","src","terminal","graph.rs"],"content":"/// Graph module for dependency management in the spreadsheet.\n///\n/// This module provides data structures and functions to manage the dependency graph\n/// between cells, detect cycles, and maintain relationships between cells that depend\n/// on one another's values.\nuse crate::terminal::functions::Operation;\nuse crate::terminal::types::Coordinates;\n\n/// Represents a node (cell) in the spreadsheet dependency graph.\n///\n/// Each node maintains its value, the operation it performs, references to its\n/// operands, and a list of other cells that depend on it.\n#[derive(Debug, Clone, Default)]\npub struct Node {\n    /// List of cells that depend on this node's value\n    pub dependents: Vec\u003cCoordinates\u003e,\n\n    /// The computed value of this cell\n    pub node_value: i32,\n\n    /// First operand for the operation performed by this cell\n    pub value1: Coordinates,\n\n    /// Second operand for the operation performed by this cell\n    pub value2: Coordinates,\n\n    /// Position of this cell in the grid\n    pub position: Coordinates,\n\n    /// The operation performed by this cell\n    pub op: Operation,\n\n    /// Whether the cell contains a valid value\n    pub valid: bool,\n\n    /// Used during graph traversal algorithms (e.g., cycle detection)\n    pub visited: bool,\n}\n\nimpl Node {\n    /// Gets the value of this node.\n    ///\n    /// # Returns\n    ///\n    /// The value of this node.\n    pub fn get_value(\u0026self) -\u003e i32 {\n        self.node_value\n    }\n\n    /// Sets the value of this node.\n    ///\n    /// # Arguments\n    ///\n    /// * `value` - The new value to set for this node.\n    pub fn set_value(\u0026mut self, value: i32) {\n        self.node_value = value;\n    }\n\n    /// Sets the position of this node.\n    ///\n    /// # Arguments\n    ///\n    /// * `position` - The new position to set for this node.\n    pub fn set_position(\u0026mut self, position: Coordinates) {\n        self.position = position;\n    }\n\n    /// Sets the first operand for the operation performed by this cell.\n    ///\n    /// # Arguments\n    ///\n    /// * `value1` - The coordinates of the first operand.\n    pub fn set_value1(\u0026mut self, value1: Coordinates) {\n        self.value1 = value1;\n    }\n\n    /// Sets the second operand for the operation performed by this cell.\n    ///\n    /// # Arguments\n    ///\n    /// * `value2` - The coordinates of the second operand.\n    pub fn set_value2(\u0026mut self, value2: Coordinates) {\n        self.value2 = value2;\n    }\n\n    /// Gets whether the cell contains a valid value.\n    ///\n    /// # Returns\n    ///\n    /// `true` if the cell contains a valid value, `false` otherwise.\n    pub fn get_valid(\u0026self) -\u003e bool {\n        self.valid\n    }\n\n    /// Sets whether the cell contains a valid value.\n    ///\n    /// # Arguments\n    ///\n    /// * `valid` - `true` if the cell contains a valid value, `false` otherwise.\n    pub fn set_valid(\u0026mut self, valid: bool) {\n        self.valid = valid;\n    }\n\n    /// Adds a dependent cell to this node's dependents list if it's not already there.\n    ///\n    /// # Arguments\n    ///\n    /// * `cell` - The coordinates of the cell to add to dependents.\n    pub fn add_dep(\u0026mut self, cell: Coordinates) {\n        if !self\n            .dependents\n            .iter()\n            .any(|x| x.row == cell.row \u0026\u0026 x.col == cell.col)\n        {\n            self.dependents.push(cell);\n        }\n    }\n\n    /// Removes a dependent cell from this node's dependents list.\n    ///\n    /// # Arguments\n    ///\n    /// * `cell` - The coordinates of the cell to remove from dependents.\n    pub fn remove_dep(\u0026mut self, cell: Coordinates) {\n        self.dependents\n            .retain(|x| x.row != cell.row || x.col != cell.col);\n    }\n\n    /// Gets the list of cells that depend on this node's value.\n    ///\n    /// # Returns\n    ///\n    /// A reference to the list of dependent cells.\n    pub fn get_dependents(\u0026self) -\u003e \u0026Vec\u003cCoordinates\u003e {\n        \u0026self.dependents\n    }\n\n    /// Sets the list of cells that depend on this node's value.\n    ///\n    /// # Arguments\n    ///\n    /// * `dependents` - The new list of dependent cells.\n    pub fn set_dependents(\u0026mut self, dependents: Vec\u003cCoordinates\u003e) {\n        self.dependents = dependents;\n    }\n}\n","traces":[{"line":46,"address":[],"length":0,"stats":{"Line":3}},{"line":47,"address":[],"length":0,"stats":{"Line":3}},{"line":55,"address":[],"length":0,"stats":{"Line":2}},{"line":56,"address":[],"length":0,"stats":{"Line":2}},{"line":64,"address":[],"length":0,"stats":{"Line":2}},{"line":65,"address":[],"length":0,"stats":{"Line":2}},{"line":73,"address":[],"length":0,"stats":{"Line":1}},{"line":74,"address":[],"length":0,"stats":{"Line":1}},{"line":82,"address":[],"length":0,"stats":{"Line":1}},{"line":83,"address":[],"length":0,"stats":{"Line":1}},{"line":91,"address":[],"length":0,"stats":{"Line":6}},{"line":92,"address":[],"length":0,"stats":{"Line":6}},{"line":100,"address":[],"length":0,"stats":{"Line":3}},{"line":101,"address":[],"length":0,"stats":{"Line":3}},{"line":109,"address":[],"length":0,"stats":{"Line":74}},{"line":110,"address":[],"length":0,"stats":{"Line":74}},{"line":111,"address":[],"length":0,"stats":{"Line":74}},{"line":112,"address":[],"length":0,"stats":{"Line":74}},{"line":113,"address":[],"length":0,"stats":{"Line":156}},{"line":115,"address":[],"length":0,"stats":{"Line":73}},{"line":124,"address":[],"length":0,"stats":{"Line":20}},{"line":125,"address":[],"length":0,"stats":{"Line":20}},{"line":126,"address":[],"length":0,"stats":{"Line":67}},{"line":134,"address":[],"length":0,"stats":{"Line":6}},{"line":135,"address":[],"length":0,"stats":{"Line":6}},{"line":143,"address":[],"length":0,"stats":{"Line":3}},{"line":144,"address":[],"length":0,"stats":{"Line":3}}],"covered":27,"coverable":27},{"path":["/","Users","yuvikachaudhary","Desktop","Semester 4","COP290","spreadsheet_rust","src","terminal","mod.rs"],"content":"pub mod backend;\n/// Terminal module for the spreadsheet application.\n///\n/// This module provides the core functionality for the terminal-based version of the\n/// spreadsheet, including:\n///\n/// - Backend logic for cell computation and dependency tracking\n/// - Spreadsheet rendering and display in the terminal\n/// - Command parsing and processing\n/// - Graph-based dependency management\n///\n/// The terminal version allows for interactive use via command-line input.\npub mod functions;\npub mod graph;\npub mod parser;\npub mod spreadsheet;\npub mod types;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","yuvikachaudhary","Desktop","Semester 4","COP290","spreadsheet_rust","src","terminal","parser.rs"],"content":"/// Parser module for the terminal spreadsheet application.\n///\n/// Provides functionality to parse and validate user input commands,\n/// converting them into operations that can be executed by the spreadsheet.\n/// Supports parsing of cell references, ranges, constants, and various operations.\nuse crate::terminal::functions::{Operation, Value};\n\n/// Validates and parses a command string into spreadsheet operations.\n///\n/// # Arguments\n///\n/// * `cmd` - The command string to parse\n/// * `rows` - The maximum row index (for validation)\n/// * `columns` - The maximum column index (for validation)\n///\n/// # Returns\n///\n/// * `Some((cell, operation))` - If the command is valid, returns the target cell and operation\n/// * `None` - If the command is invalid or unrecognized\n///\n/// # Examples\n///\n/// Commands can be:\n/// - Cell assignments: \"A1=5\"\n/// - Operations: \"B2=A1+10\"\n/// - Range functions: \"C3=SUM(A1:B5)\"\n/// - Special commands: \"enable_output\", \"scroll_to B5\", etc.\npub fn validate(\n    cmd: \u0026str,\n    rows: \u0026usize,\n    columns: \u0026usize,\n) -\u003e Option\u003c(Option\u003cValue\u003e, Option\u003cValue\u003e)\u003e {\n    match cmd.trim() {\n        \"enable_output\" =\u003e {\n            return Some((\n                None,\n                Some(Value::Oper(\n                    Box::new(Value::Const(-1)),\n                    Box::new(Value::Const(-1)),\n                    Operation::EnableOutput,\n                )),\n            ));\n        }\n        \"disable_output\" =\u003e {\n            return Some((\n                None,\n                Some(Value::Oper(\n                    Box::new(Value::Const(-1)),\n                    Box::new(Value::Const(-1)),\n                    Operation::DisableOutput,\n                )),\n            ));\n        }\n        _ =\u003e {} // Continue with the regular parsing for other commands\n    }\n\n    if cmd.trim().starts_with(\"scroll_to \") {\n        let cell_name = cmd.trim()[\"scroll_to \".len()..].trim();\n        let cell = is_cell(cell_name, rows, columns);\n        if let Some(cell) = cell {\n            return Some((\n                Some(cell),\n                Some(Value::Oper(\n                    Box::new(Value::Const(-1)),\n                    Box::new(Value::Const(-1)),\n                    Operation::Scrollto,\n                )),\n            ));\n        } else {\n            return None;\n        }\n    }\n\n    let (cell, exp) = cmd.split_once('=')?;\n\n    let cell = String::from(cell).trim().to_string();\n    let cell = is_cell(\u0026cell, rows, columns);\n\n    let Some((operation, range)) = exp.split_once('(') else {\n        // basic math operations or constant (0-4)\n        let val = (String::from(exp)).trim().to_string();\n        let operators = [\"+\", \"-\", \"*\", \"/\"];\n        for (i, c) in val.chars().enumerate() {\n            if i == 0 \u0026\u0026 c == '-' {\n                continue;\n            }\n            if operators.contains(\u0026c.to_string().as_str()) {\n                let op1 = (val[..i]).trim().to_string();\n                let op2 = \u0026val[i + 1..].trim().to_string();\n                let op1 = is_cell_or_const(\u0026op1.to_string(), rows, columns)?;\n                let op2 = is_cell_or_const(\u0026op2.to_string(), rows, columns)?;\n                match c {\n                    '+' =\u003e {\n                        return Some((\n                            cell,\n                            Some(Value::Oper(Box::new(op1), Box::new(op2), Operation::Add)),\n                        ));\n                    }\n                    '-' =\u003e {\n                        return Some((\n                            cell,\n                            Some(Value::Oper(Box::new(op1), Box::new(op2), Operation::Sub)),\n                        ));\n                    }\n                    '*' =\u003e {\n                        return Some((\n                            cell,\n                            Some(Value::Oper(Box::new(op1), Box::new(op2), Operation::Mul)),\n                        ));\n                    }\n                    '/' =\u003e {\n                        return Some((\n                            cell,\n                            Some(Value::Oper(Box::new(op1), Box::new(op2), Operation::Div)),\n                        ));\n                    }\n                    _ =\u003e {\n                        return None;\n                    } //This case is not possible, just for compilation\n                }\n            }\n        }\n\n        let val = is_cell_or_const(\u0026val, rows, columns)?; //for the moment, assuming the RHS to be a constant or cell\n        return Some((\n            cell,\n            Some(Value::Oper(\n                Box::new(val),\n                Box::new(Value::Const(-1)),\n                Operation::Cons,\n            )),\n        ));\n    };\n    let range = range.strip_suffix(')')?.to_string(); //removing the closing bracket\n\n    let Some((start, end)) = range.split_once(':') else {\n        // SLEEP (the keyword 'SLEEP' is not checked for, it is taken fro granted)\n        let val = range;\n        let val = is_cell_or_const(\u0026val, rows, columns);\n        if let Some(val) = val {\n            return Some((\n                cell,\n                Some(Value::Oper(\n                    Box::new(val),\n                    Box::new(Value::Const(-1)),\n                    Operation::Slp,\n                )),\n            ));\n        }\n        return Some((cell, None));\n    };\n    let start = String::from(start);\n    let end = String::from(end);\n    let start = is_cell(\u0026start, rows, columns)?;\n    let end = is_cell(\u0026end, rows, columns)?;\n    if let (Value::Cell(r, c), Value::Cell(r2, c2)) = (\u0026start, \u0026end) {\n        if r \u003e r2 || c \u003e c2 {\n            return None;\n        }\n    } else {\n        return None;\n    }\n    match operation {\n        \"SUM\" =\u003e Some((\n            cell,\n            Some(Value::Oper(Box::new(start), Box::new(end), Operation::Sum)),\n        )),\n        \"AVG\" =\u003e Some((\n            cell,\n            Some(Value::Oper(Box::new(start), Box::new(end), Operation::Avg)),\n        )),\n        \"STDEV\" =\u003e Some((\n            cell,\n            Some(Value::Oper(Box::new(start), Box::new(end), Operation::Std)),\n        )),\n        \"MIN\" =\u003e Some((\n            cell,\n            Some(Value::Oper(Box::new(start), Box::new(end), Operation::Min)),\n        )),\n        \"MAX\" =\u003e Some((\n            cell,\n            Some(Value::Oper(Box::new(start), Box::new(end), Operation::Max)),\n        )),\n        _ =\u003e Some((cell, None)),\n    }\n}\n\n/// Parses a cell reference in the format \"A1\", \"B2\", etc.\n///\n/// # Arguments\n///\n/// * `exp` - The string containing the cell reference\n/// * `rows` - The maximum row index (for validation)\n/// * `columns` - The maximum column index (for validation)\n///\n/// # Returns\n///\n/// * `Some(Value::Cell(row, col))` - If the expression is a valid cell reference\n/// * `None` - If the expression is not a valid cell reference\npub fn is_cell(exp: \u0026str, rows: \u0026usize, columns: \u0026usize) -\u003e Option\u003cValue\u003e {\n    let mut col = 0;\n    let mut row = 0;\n\n    let chars: Vec\u003cchar\u003e = exp.chars().collect();\n    let mut i = 0;\n    while i \u003c 3 {\n        if chars[i].is_alphabetic() {\n            col = col * 26 + (chars[i] as u8 - b'A') as usize + 1;\n        } else {\n            break;\n        }\n        i += 1;\n    }\n    if exp.chars().count() - i \u003e 3 || i == 0 {\n        return None;\n    }\n    while i \u003c exp.chars().count() {\n        if chars[i].is_numeric() {\n            row = row * 10 + (chars[i] as u8 - b'0') as usize;\n        } else {\n            return None;\n        }\n        i += 1;\n    }\n    if row \u003e *rows || col \u003e *columns {\n        return None;\n    }\n    Some(Value::Cell(col as i32, row as i32))\n}\n\n/// Parses a constant integer value.\n///\n/// # Arguments\n///\n/// * `exp` - The string containing the integer constant\n///\n/// # Returns\n///\n/// * `Some(Value::Const(value))` - If the expression is a valid integer\n/// * `None` - If the expression is not a valid integer\npub fn is_const(exp: \u0026str) -\u003e Option\u003cValue\u003e {\n    // let mut ans = 0;\n    // for c in exp.chars() {\n    //     if c.is_numeric() {\n    //         ans = ans*10 + (c as u8 - '0' as u8) as usize;\n    //     } else {\n    //         return None;\n    //     }\n    // }\n    // return Some(Value::Const(ans));\n    match exp.parse::\u003cisize\u003e() {\n        Ok(ans) =\u003e Some(Value::Const(ans)),\n        Err(_) =\u003e None,\n    }\n}\n\n/// Parses an expression that could be either a cell reference or a constant.\n///\n/// # Arguments\n///\n/// * `exp` - The string to parse\n/// * `rows` - The maximum row index (for cell validation)\n/// * `columns` - The maximum column index (for cell validation)\n///\n/// # Returns\n///\n/// * `Some(Value)` - If the expression is either a valid cell or constant\n/// * `None` - If the expression is neither a valid cell nor constant\npub fn is_cell_or_const(exp: \u0026str, rows: \u0026usize, columns: \u0026usize) -\u003e Option\u003cValue\u003e {\n    if let Some(constant) = is_const(exp) {\n        Some(constant)\n    } else if let Some(cell) = is_cell(exp, rows, columns) {\n        return Some(cell);\n    } else {\n        return None;\n    }\n}\n\n// assignment - cell, value - done\n// basic math - cells, values\n// sleep - cell, value - done\n// range operations - cells, values - done\n","traces":[{"line":28,"address":[],"length":0,"stats":{"Line":42}},{"line":33,"address":[],"length":0,"stats":{"Line":42}},{"line":34,"address":[],"length":0,"stats":{"Line":42}},{"line":35,"address":[],"length":0,"stats":{"Line":2}},{"line":36,"address":[],"length":0,"stats":{"Line":2}},{"line":37,"address":[],"length":0,"stats":{"Line":2}},{"line":38,"address":[],"length":0,"stats":{"Line":2}},{"line":39,"address":[],"length":0,"stats":{"Line":2}},{"line":40,"address":[],"length":0,"stats":{"Line":2}},{"line":44,"address":[],"length":0,"stats":{"Line":40}},{"line":45,"address":[],"length":0,"stats":{"Line":2}},{"line":46,"address":[],"length":0,"stats":{"Line":2}},{"line":47,"address":[],"length":0,"stats":{"Line":2}},{"line":48,"address":[],"length":0,"stats":{"Line":2}},{"line":49,"address":[],"length":0,"stats":{"Line":2}},{"line":50,"address":[],"length":0,"stats":{"Line":2}},{"line":54,"address":[],"length":0,"stats":{"Line":38}},{"line":57,"address":[],"length":0,"stats":{"Line":38}},{"line":58,"address":[],"length":0,"stats":{"Line":5}},{"line":59,"address":[],"length":0,"stats":{"Line":5}},{"line":60,"address":[],"length":0,"stats":{"Line":8}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":2}},{"line":74,"address":[],"length":0,"stats":{"Line":33}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":9}},{"line":81,"address":[],"length":0,"stats":{"Line":18}},{"line":82,"address":[],"length":0,"stats":{"Line":18}},{"line":83,"address":[],"length":0,"stats":{"Line":79}},{"line":84,"address":[],"length":0,"stats":{"Line":79}},{"line":85,"address":[],"length":0,"stats":{"Line":1}},{"line":87,"address":[],"length":0,"stats":{"Line":60}},{"line":88,"address":[],"length":0,"stats":{"Line":15}},{"line":89,"address":[],"length":0,"stats":{"Line":15}},{"line":90,"address":[],"length":0,"stats":{"Line":30}},{"line":91,"address":[],"length":0,"stats":{"Line":15}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":6}},{"line":95,"address":[],"length":0,"stats":{"Line":6}},{"line":96,"address":[],"length":0,"stats":{"Line":6}},{"line":100,"address":[],"length":0,"stats":{"Line":3}},{"line":101,"address":[],"length":0,"stats":{"Line":3}},{"line":102,"address":[],"length":0,"stats":{"Line":3}},{"line":106,"address":[],"length":0,"stats":{"Line":3}},{"line":107,"address":[],"length":0,"stats":{"Line":3}},{"line":108,"address":[],"length":0,"stats":{"Line":3}},{"line":112,"address":[],"length":0,"stats":{"Line":3}},{"line":113,"address":[],"length":0,"stats":{"Line":3}},{"line":114,"address":[],"length":0,"stats":{"Line":3}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":6}},{"line":125,"address":[],"length":0,"stats":{"Line":2}},{"line":126,"address":[],"length":0,"stats":{"Line":2}},{"line":127,"address":[],"length":0,"stats":{"Line":2}},{"line":128,"address":[],"length":0,"stats":{"Line":2}},{"line":129,"address":[],"length":0,"stats":{"Line":2}},{"line":130,"address":[],"length":0,"stats":{"Line":2}},{"line":134,"address":[],"length":0,"stats":{"Line":9}},{"line":136,"address":[],"length":0,"stats":{"Line":7}},{"line":138,"address":[],"length":0,"stats":{"Line":1}},{"line":139,"address":[],"length":0,"stats":{"Line":1}},{"line":140,"address":[],"length":0,"stats":{"Line":1}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":1}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":7}},{"line":155,"address":[],"length":0,"stats":{"Line":7}},{"line":156,"address":[],"length":0,"stats":{"Line":7}},{"line":157,"address":[],"length":0,"stats":{"Line":13}},{"line":158,"address":[],"length":0,"stats":{"Line":1}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":1}},{"line":165,"address":[],"length":0,"stats":{"Line":1}},{"line":166,"address":[],"length":0,"stats":{"Line":1}},{"line":168,"address":[],"length":0,"stats":{"Line":6}},{"line":169,"address":[],"length":0,"stats":{"Line":1}},{"line":170,"address":[],"length":0,"stats":{"Line":1}},{"line":172,"address":[],"length":0,"stats":{"Line":5}},{"line":173,"address":[],"length":0,"stats":{"Line":1}},{"line":174,"address":[],"length":0,"stats":{"Line":1}},{"line":176,"address":[],"length":0,"stats":{"Line":4}},{"line":177,"address":[],"length":0,"stats":{"Line":1}},{"line":178,"address":[],"length":0,"stats":{"Line":1}},{"line":180,"address":[],"length":0,"stats":{"Line":3}},{"line":181,"address":[],"length":0,"stats":{"Line":1}},{"line":182,"address":[],"length":0,"stats":{"Line":1}},{"line":184,"address":[],"length":0,"stats":{"Line":1}},{"line":200,"address":[],"length":0,"stats":{"Line":75}},{"line":201,"address":[],"length":0,"stats":{"Line":75}},{"line":202,"address":[],"length":0,"stats":{"Line":75}},{"line":204,"address":[],"length":0,"stats":{"Line":75}},{"line":205,"address":[],"length":0,"stats":{"Line":75}},{"line":206,"address":[],"length":0,"stats":{"Line":152}},{"line":207,"address":[],"length":0,"stats":{"Line":228}},{"line":208,"address":[],"length":0,"stats":{"Line":77}},{"line":210,"address":[],"length":0,"stats":{"Line":74}},{"line":212,"address":[],"length":0,"stats":{"Line":77}},{"line":214,"address":[],"length":0,"stats":{"Line":147}},{"line":215,"address":[],"length":0,"stats":{"Line":4}},{"line":217,"address":[],"length":0,"stats":{"Line":150}},{"line":218,"address":[],"length":0,"stats":{"Line":159}},{"line":219,"address":[],"length":0,"stats":{"Line":79}},{"line":221,"address":[],"length":0,"stats":{"Line":1}},{"line":223,"address":[],"length":0,"stats":{"Line":79}},{"line":225,"address":[],"length":0,"stats":{"Line":136}},{"line":226,"address":[],"length":0,"stats":{"Line":6}},{"line":228,"address":[],"length":0,"stats":{"Line":64}},{"line":241,"address":[],"length":0,"stats":{"Line":46}},{"line":251,"address":[],"length":0,"stats":{"Line":46}},{"line":252,"address":[],"length":0,"stats":{"Line":21}},{"line":253,"address":[],"length":0,"stats":{"Line":25}},{"line":269,"address":[],"length":0,"stats":{"Line":40}},{"line":270,"address":[],"length":0,"stats":{"Line":58}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":40}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":4}}],"covered":108,"coverable":130},{"path":["/","Users","yuvikachaudhary","Desktop","Semester 4","COP290","spreadsheet_rust","src","terminal","spreadsheet.rs"],"content":"/// Spreadsheet module for the terminal-based interface.\n///\n/// This module provides functionality for rendering the spreadsheet grid in\n/// the terminal, handling user commands, and displaying the current state of\n/// cells to the user. It acts as the frontend for the terminal-based version\n/// of the spreadsheet application.\nuse crate::terminal::backend::getting_things_updated;\nuse crate::terminal::functions::Operation;\nuse crate::terminal::functions::Value;\nuse crate::terminal::graph::Node;\nuse crate::terminal::parser;\nuse crate::terminal::types::Coordinates;\nuse std::cmp;\nuse std::io;\nuse std::io::Write;\n\n/// Constants defining the maximum dimensions of the spreadsheet\nconst MAX_ROW: usize = 999;\nconst MAX_COLUMN: usize = 18278;\n\n/// Translates a column number to its Excel-style letter representation (A, B, C, ..., AA, AB, etc.).\n///\n/// # Arguments\n///\n/// * `y` - The 1-based column index to convert\n///\n/// # Returns\n///\n/// A string containing the column letter(s)\npub fn column_decoder(mut j: usize) -\u003e String {\n    let mut cc = Vec::new();\n    while j \u003e 0 {\n        j -= 1;\n        cc.push((b'A' + (j % 26) as u8) as char);\n        j /= 26;\n    }\n    cc.reverse();\n    cc.into_iter().collect()\n}\n\n/// Prints the current state of the spreadsheet grid to the terminal.\n///\n/// # Arguments\n///\n/// * `start_x` - The starting row index for display\n/// * `start_y` - The starting column index for display\n/// * `r` - The number of rows in the grid\n/// * `c` - The number of columns in the grid\n/// * `grid` - The spreadsheet grid containing the cells\npub fn print_grid(start_x: usize, start_y: usize, r: usize, c: usize, grid: \u0026mut [Vec\u003cNode\u003e]) {\n    let max_x = cmp::min(9 + start_x, r);\n    let max_y = cmp::min(9 + start_y, c);\n\n    for (i, _row) in grid.iter().enumerate().take(max_x + 1).skip(start_x - 1) {\n        for j in start_y - 1..=max_y {\n            if i == start_x - 1 \u0026\u0026 j == start_y - 1 {\n                print!(\"{:\u003e12}\", \" \");\n            } else if i == start_x - 1 \u0026\u0026 j != start_y - 1 {\n                print!(\"{:\u003e12}\", column_decoder(j));\n            } else if j == start_y - 1 {\n                print!(\"{:\u003e12}\", i);\n            } else if grid[i][j].valid {\n                print!(\"{:\u003e12}\", grid[i][j].node_value);\n            } else {\n                print!(\"{:\u003e12}\", \"ERR\");\n            }\n        }\n        println!();\n    }\n}\n\n/// Displays a status message with execution time.\n///\n/// # Arguments\n///\n/// * `status` - The status code of the previous operation\n/// * `time` - The execution time of the operation in seconds\npub fn display_status(x: i32, time_taken: f64) {\n    print!(\"[{:.2}] \", time_taken);\n    match x {\n        1 =\u003e print!(\"(ok) \u003e \"),                 // relevant\n        2 =\u003e print!(\"(invalid range) \u003e \"), // not relevant to autograder - will have to change parser if want to // debug\n        3 =\u003e print!(\"(unrecognized cmd) \u003e \"), // relevant\n        4 =\u003e print!(\"(invalid row/column) \u003e \"), // ig not relevant\n        5 =\u003e print!(\"(cycle not allowed) \u003e \"), // relevant\n        _ =\u003e (),\n    }\n    io::stdout().flush().unwrap();\n}\n\nfn is_number(str: \u0026str) -\u003e bool {\n    !str.is_empty() \u0026\u0026 str.chars().all(|c| c.is_ascii_digit())\n}\n\n/// Processes a single command and updates the spreadsheet state accordingly.\n///\n/// # Arguments\n///\n/// * `cmd` - The command string to process\n/// * `start_x` - The current row index for display (may be updated)\n/// * `start_y` - The current column index for display (may be updated)\n/// * `r` - The number of rows in the grid\n/// * `c` - The number of columns in the grid\n/// * `is_disabled` - Whether output is disabled\n/// * `grid` - The spreadsheet grid to update\n///\n/// # Returns\n///\n/// An integer status code indicating success or specific failure modes\n#[allow(unreachable_code)]\npub fn process_command(\n    command: \u0026str,\n    start_x: \u0026mut usize,\n    start_y: \u0026mut usize,\n    r: usize,\n    c: usize,\n    is_disabled: \u0026mut bool,\n    grid: \u0026mut Vec\u003cVec\u003cNode\u003e\u003e,\n) -\u003e i32 {\n    match command {\n        \"q\" =\u003e return 0,\n        \"w\" =\u003e {\n            *start_x = if *start_x \u003e 10 { *start_x - 10 } else { 1 };\n            if !(*is_disabled) {\n                print_grid(*start_x, *start_y, r, c, grid);\n            }\n            return 1;\n        }\n        \"s\" =\u003e {\n            if *start_x + 10 \u003c= r {\n                *start_x += 10;\n                *start_x = cmp::min(*start_x, r - 9);\n            }\n            if !(*is_disabled) {\n                print_grid(*start_x, *start_y, r, c, grid);\n            }\n            return 1;\n        }\n        \"a\" =\u003e {\n            *start_y = if *start_y \u003e 10 { *start_y - 10 } else { 1 };\n            if !(*is_disabled) {\n                print_grid(*start_x, *start_y, r, c, grid);\n            }\n            return 1;\n        }\n        \"d\" =\u003e {\n            if *start_y + 10 \u003c= c {\n                *start_y += 10;\n                *start_y = cmp::min(*start_y, c - 9);\n            }\n            if !(*is_disabled) {\n                print_grid(*start_x, *start_y, r, c, grid);\n            }\n            return 1;\n        }\n        _ =\u003e {}\n    }\n\n    // let mut function: isize = -1;\n    // work with enums only not functions\n\n    // debug - complete this\n    match parser::validate(command, \u0026r, \u0026c) {\n        Some((Some(Value::Cell(col, row)), Some(Value::Oper(v1, v2, op)))) =\u003e {\n            // Handle special operations\n            if op == Operation::Scrollto {\n                {\n                    *start_x = row as usize;\n                    *start_y = col as usize;\n                    if !(*is_disabled) {\n                        print_grid(*start_x, *start_y, r, c, grid);\n                    }\n                    return 1;\n                }\n            }\n\n            let target_cell = Coordinates { row, col };\n            let (value1, value2) = match (\u0026*v1, \u0026*v2) {\n                (Value::Cell(c1, r1), Value::Cell(c2, r2)) =\u003e (\n                    Coordinates { row: *r1, col: *c1 },\n                    Coordinates { row: *r2, col: *c2 },\n                ),\n                (Value::Cell(c1, r1), Value::Const(val)) =\u003e (\n                    Coordinates { row: *r1, col: *c1 },\n                    Coordinates {\n                        row: *val as i32,\n                        col: -1,\n                    },\n                ),\n                (Value::Const(val), Value::Cell(c2, r2)) =\u003e (\n                    Coordinates {\n                        row: *val as i32,\n                        col: -1,\n                    },\n                    Coordinates { row: *r2, col: *c2 },\n                ),\n                (Value::Const(val1), Value::Const(val2)) =\u003e (\n                    Coordinates {\n                        row: *val1 as i32,\n                        col: -1,\n                    },\n                    Coordinates {\n                        row: *val2 as i32,\n                        col: -1,\n                    },\n                ),\n                _ =\u003e {\n                    if !(*is_disabled) {\n                        print_grid(*start_x, *start_y, r, c, grid);\n                    }\n                    return 3; // Invalid operands\n                }\n            };\n            let operation = op;\n\n            let status = getting_things_updated(grid, target_cell, value1, value2, operation);\n\n            if !(*is_disabled) {\n                print_grid(*start_x, *start_y, r, c, grid);\n            }\n\n            return status;\n        }\n        Some((None, Some(Value::Oper(_v1, _v2, op)))) =\u003e {\n            // Handle special operations\n            match op {\n                Operation::EnableOutput =\u003e {\n                    *is_disabled = false;\n                    print_grid(*start_x, *start_y, r, c, grid);\n                    return 1;\n                }\n                Operation::DisableOutput =\u003e {\n                    *is_disabled = true;\n                    return 1;\n                }\n                _ =\u003e {\n                    if !(*is_disabled) {\n                        print_grid(*start_x, *start_y, r, c, grid);\n                    }\n                    return 3; // Invalid operands\n                }\n            }\n        }\n        _ =\u003e {\n            if !(*is_disabled) {\n                print_grid(*start_x, *start_y, r, c, grid);\n            }\n            return 3; // Invalid operands\n        }\n    }\n    1\n}\n\n/// Processes the command line arguments provided to the application.\n///\n/// # Arguments\n///\n/// * `argc` - The number of arguments\n/// * `args` - The vector of argument strings\n/// * `is_disabled` - Whether the output should be disabled\n///\n/// # Returns\n///\n/// `true` if arguments are valid and processing should continue, `false` otherwise\npub fn process_first(x: usize, command: \u0026[String], _is_disabled: \u0026mut bool) -\u003e bool {\n    if x != 3 {\n        return false;\n    }\n    if !is_number(\u0026command[1]) || !is_number(\u0026command[2]) {\n        return false;\n    }\n\n    let r = command[1].parse::\u003cusize\u003e().unwrap();\n    let c = command[2].parse::\u003cusize\u003e().unwrap();\n\n    if !(1..=MAX_ROW).contains(\u0026r) || !(1..=MAX_COLUMN).contains(\u0026c) {\n        return false;\n    }\n    true\n}\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":276}},{"line":31,"address":[],"length":0,"stats":{"Line":276}},{"line":32,"address":[],"length":0,"stats":{"Line":850}},{"line":33,"address":[],"length":0,"stats":{"Line":287}},{"line":34,"address":[],"length":0,"stats":{"Line":287}},{"line":35,"address":[],"length":0,"stats":{"Line":287}},{"line":37,"address":[],"length":0,"stats":{"Line":276}},{"line":38,"address":[],"length":0,"stats":{"Line":276}},{"line":50,"address":[],"length":0,"stats":{"Line":32}},{"line":51,"address":[],"length":0,"stats":{"Line":32}},{"line":52,"address":[],"length":0,"stats":{"Line":32}},{"line":54,"address":[],"length":0,"stats":{"Line":329}},{"line":55,"address":[],"length":0,"stats":{"Line":3271}},{"line":56,"address":[],"length":0,"stats":{"Line":3303}},{"line":57,"address":[],"length":0,"stats":{"Line":32}},{"line":58,"address":[],"length":0,"stats":{"Line":3504}},{"line":59,"address":[],"length":0,"stats":{"Line":265}},{"line":60,"address":[],"length":0,"stats":{"Line":3207}},{"line":61,"address":[],"length":0,"stats":{"Line":265}},{"line":62,"address":[],"length":0,"stats":{"Line":5086}},{"line":63,"address":[],"length":0,"stats":{"Line":2409}},{"line":65,"address":[],"length":0,"stats":{"Line":3}},{"line":68,"address":[],"length":0,"stats":{"Line":297}},{"line":78,"address":[],"length":0,"stats":{"Line":10}},{"line":79,"address":[],"length":0,"stats":{"Line":10}},{"line":80,"address":[],"length":0,"stats":{"Line":10}},{"line":81,"address":[],"length":0,"stats":{"Line":4}},{"line":82,"address":[],"length":0,"stats":{"Line":1}},{"line":83,"address":[],"length":0,"stats":{"Line":1}},{"line":84,"address":[],"length":0,"stats":{"Line":1}},{"line":85,"address":[],"length":0,"stats":{"Line":1}},{"line":86,"address":[],"length":0,"stats":{"Line":2}},{"line":88,"address":[],"length":0,"stats":{"Line":10}},{"line":91,"address":[],"length":0,"stats":{"Line":14}},{"line":92,"address":[],"length":0,"stats":{"Line":64}},{"line":111,"address":[],"length":0,"stats":{"Line":24}},{"line":120,"address":[],"length":0,"stats":{"Line":24}},{"line":121,"address":[],"length":0,"stats":{"Line":25}},{"line":122,"address":[],"length":0,"stats":{"Line":23}},{"line":123,"address":[],"length":0,"stats":{"Line":6}},{"line":124,"address":[],"length":0,"stats":{"Line":6}},{"line":125,"address":[],"length":0,"stats":{"Line":3}},{"line":127,"address":[],"length":0,"stats":{"Line":3}},{"line":129,"address":[],"length":0,"stats":{"Line":20}},{"line":130,"address":[],"length":0,"stats":{"Line":4}},{"line":131,"address":[],"length":0,"stats":{"Line":1}},{"line":132,"address":[],"length":0,"stats":{"Line":1}},{"line":134,"address":[],"length":0,"stats":{"Line":6}},{"line":135,"address":[],"length":0,"stats":{"Line":3}},{"line":137,"address":[],"length":0,"stats":{"Line":3}},{"line":139,"address":[],"length":0,"stats":{"Line":17}},{"line":140,"address":[],"length":0,"stats":{"Line":6}},{"line":141,"address":[],"length":0,"stats":{"Line":6}},{"line":142,"address":[],"length":0,"stats":{"Line":3}},{"line":144,"address":[],"length":0,"stats":{"Line":3}},{"line":146,"address":[],"length":0,"stats":{"Line":14}},{"line":147,"address":[],"length":0,"stats":{"Line":4}},{"line":148,"address":[],"length":0,"stats":{"Line":1}},{"line":149,"address":[],"length":0,"stats":{"Line":1}},{"line":151,"address":[],"length":0,"stats":{"Line":6}},{"line":152,"address":[],"length":0,"stats":{"Line":3}},{"line":154,"address":[],"length":0,"stats":{"Line":3}},{"line":156,"address":[],"length":0,"stats":{"Line":11}},{"line":163,"address":[],"length":0,"stats":{"Line":11}},{"line":164,"address":[],"length":0,"stats":{"Line":4}},{"line":166,"address":[],"length":0,"stats":{"Line":4}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":4}},{"line":178,"address":[],"length":0,"stats":{"Line":4}},{"line":179,"address":[],"length":0,"stats":{"Line":4}},{"line":180,"address":[],"length":0,"stats":{"Line":4}},{"line":181,"address":[],"length":0,"stats":{"Line":4}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":4}},{"line":219,"address":[],"length":0,"stats":{"Line":4}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":2}},{"line":226,"address":[],"length":0,"stats":{"Line":2}},{"line":228,"address":[],"length":0,"stats":{"Line":1}},{"line":229,"address":[],"length":0,"stats":{"Line":1}},{"line":230,"address":[],"length":0,"stats":{"Line":1}},{"line":233,"address":[],"length":0,"stats":{"Line":1}},{"line":234,"address":[],"length":0,"stats":{"Line":1}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":10}},{"line":246,"address":[],"length":0,"stats":{"Line":5}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":10}},{"line":266,"address":[],"length":0,"stats":{"Line":10}},{"line":267,"address":[],"length":0,"stats":{"Line":2}},{"line":269,"address":[],"length":0,"stats":{"Line":14}},{"line":270,"address":[],"length":0,"stats":{"Line":2}},{"line":273,"address":[],"length":0,"stats":{"Line":6}},{"line":274,"address":[],"length":0,"stats":{"Line":6}},{"line":276,"address":[],"length":0,"stats":{"Line":10}},{"line":277,"address":[],"length":0,"stats":{"Line":3}},{"line":279,"address":[],"length":0,"stats":{"Line":3}}],"covered":92,"coverable":124},{"path":["/","Users","yuvikachaudhary","Desktop","Semester 4","COP290","spreadsheet_rust","src","terminal","types.rs"],"content":"/// Common types module used throughout the terminal spreadsheet application.\n///\n/// This module defines fundamental types like Coordinates that are\n/// used across different components of the spreadsheet.\nuse std::fmt;\n\n/// Represents coordinates within the spreadsheet grid.\n///\n/// Used to identify cells by their row and column positions, and to\n/// represent positions for operations and rendering.\n#[derive(Debug, Clone, Copy, PartialEq, Default)]\npub struct Coordinates {\n    /// The row index (0-based)\n    pub row: i32,\n\n    /// The column index (0-based)\n    pub col: i32,\n}\n\nimpl fmt::Display for Coordinates {\n    /// Formats the Coordinates for display.\n    ///\n    /// # Arguments\n    ///\n    /// * `f` - The formatter\n    ///\n    /// # Returns\n    ///\n    /// A Result indicating whether the formatting succeeded\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"({}, {})\", self.row, self.col)\n    }\n}\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":1}},{"line":31,"address":[],"length":0,"stats":{"Line":1}}],"covered":2,"coverable":2},{"path":["/","Users","yuvikachaudhary","Desktop","Semester 4","COP290","spreadsheet_rust","tests","backend_ext.rs"],"content":"use project::extension::backend::backend::*;\n#[allow(unused_imports)]\nuse project::extension::common::{Operation, Value};\nuse std::fs;\n\n#[test]\nfn test_init_backend() {\n    let backend = Backend::init_backend(10, 15);\n    let grid = backend.get_grid();\n    assert_eq!(grid.get_row_size(), 10 + 1);\n    assert_eq!(grid.get_column_size(), 15 + 1);\n    assert_eq!(grid.get_node_value(9, 14), Some(0));\n}\n\n#[test]\n#[should_panic(expected = \"Expected a Cell value\")]\nfn test_init_backend1() {\n    let backend = Backend::init_backend(10, 15);\n    let val = Value::Const(5);\n    backend.get_node_value(val);\n}\n\n#[test]\nfn test_grid_new() {\n    let grid = Grid::new(10, 15);\n    assert_eq!(grid.get_row_size(), 10);\n    assert_eq!(grid.get_column_size(), 15);\n}\n\n#[test]\nfn test_valgrid_creation() {\n    let backend = Backend::init_backend(5, 5);\n    let valgrid = backend.get_valgrid();\n    assert_eq!(valgrid.rows, 6);\n    assert_eq!(valgrid.columns, 6);\n}\n\n#[test]\nfn test_process_command_assign_value() {\n    let mut backend = Backend::init_backend(10, 10);\n    let status = backend.process_command(10, 10, \"A1=5\".to_string());\n    assert_eq!(status, Status::Success);\n    assert_eq!(backend.get_node_value(Value::Cell(1, 1)), Some(5));\n}\n\n#[test]\nfn test_process_command_invalid() {\n    let mut backend = Backend::init_backend(10, 10);\n    let status = backend.process_command(10, 10, \"invalid command\".to_string());\n    assert_eq!(status, Status::UnrecognizedCmd);\n}\n\n#[test]\nfn test_process_command_sum() {\n    let mut backend = Backend::init_backend(10, 10);\n    // Assign values to cells\n    backend.process_command(10, 10, \"A1=5\".to_string());\n    backend.process_command(10, 10, \"A2=10\".to_string());\n    backend.process_command(10, 10, \"A3=15\".to_string());\n\n    // Test SUM function\n    let status = backend.process_command(10, 10, \"B1=SUM(A1:A3)\".to_string());\n    assert_eq!(status, Status::Success);\n    assert_eq!(backend.get_node_value(Value::Cell(1, 2)), Some(30));\n}\n\n#[test]\nfn test_process_command_avg() {\n    let mut backend = Backend::init_backend(10, 10);\n    // Assign values to cells\n    backend.process_command(10, 10, \"A1=6\".to_string());\n    backend.process_command(10, 10, \"A2=12\".to_string());\n    backend.process_command(10, 10, \"A3=18\".to_string());\n\n    // Test AVG function\n\n    let status = backend.process_command(10, 10, \"B1=AVG(A1:A3)\".to_string());\n    assert_eq!(status, Status::Success);\n    assert_eq!(backend.get_node_value(Value::Cell(1, 2)), Some(12));\n}\n\n#[test]\nfn test_process_command_arithmetic() {\n    let mut backend = Backend::init_backend(10, 10);\n    // Assign values to cells\n    backend.process_command(10, 10, \"A1=5\".to_string());\n    backend.process_command(10, 10, \"A2=10\".to_string());\n\n    // Test arithmetic operations\n    backend.process_command(10, 10, \"B1=A1+A2\".to_string()); // Addition\n    backend.process_command(10, 10, \"B2=A2-A1\".to_string()); // Subtraction\n    backend.process_command(10, 10, \"B3=A1*A2\".to_string()); // Multiplication\n    backend.process_command(10, 10, \"B4=A2/A1\".to_string()); // Division\n\n    assert_eq!(backend.get_node_value(Value::Cell(1, 2)), Some(15)); // 5+10\n    assert_eq!(backend.get_node_value(Value::Cell(2, 2)), Some(5)); // 10-5\n    assert_eq!(backend.get_node_value(Value::Cell(3, 2)), Some(50)); // 5*10\n    assert_eq!(backend.get_node_value(Value::Cell(4, 2)), Some(2)); // 10/5\n}\n\n#[test]\nfn test_process_command_stdev() {\n    let mut backend = Backend::init_backend(10, 10);\n    // Assign values to cells\n    backend.process_command(10, 10, \"A1=5\".to_string());\n    backend.process_command(10, 10, \"A2=10\".to_string());\n    backend.process_command(10, 10, \"A3=15\".to_string());\n\n    // Test SUM function\n    let status = backend.process_command(10, 10, \"B1=STDEV(A1:A3)\".to_string());\n    assert_eq!(status, Status::Success);\n    assert_eq!(backend.get_node_value(Value::Cell(1, 2)), Some(4));\n}\n\n#[test]\nfn test_process_command_stdev_none() {\n    let mut backend = Backend::init_backend(10, 10);\n    // Assign values to cells\n    backend.process_command(10, 10, \"A1=5\".to_string());\n    backend.process_command(10, 10, \"A2=10\".to_string());\n    backend.process_command(10, 10, \"A3=15\".to_string());\n    backend.grid.cells_vec[1][1].valid = false;\n    // Test SUM function\n    let status = backend.process_command(10, 10, \"B1=STDEV(A1:A3)\".to_string());\n    assert_eq!(status, Status::Success);\n    assert_eq!(backend.get_node_value(Value::Cell(1, 2)), None);\n}\n\n#[test]\nfn test_process_command_sleep() {\n    let mut backend = Backend::init_backend(10, 10);\n    // Assign values to cells\n    backend.process_command(10, 10, \"A1=1\".to_string());\n    backend.process_command(10, 10, \"A2=10\".to_string());\n    backend.process_command(10, 10, \"A3=15\".to_string());\n\n    // Test SUM function\n    let status = backend.process_command(10, 10, \"B1=SLEEP(A1)\".to_string());\n    assert_eq!(status, Status::Success);\n    assert_eq!(backend.get_node_value(Value::Cell(1, 2)), Some(1));\n}\n\n#[test]\nfn test_process_command_sleep_none() {\n    let mut backend = Backend::init_backend(10, 10);\n    // Assign values to cells\n    backend.process_command(10, 10, \"A1=5\".to_string());\n    backend.process_command(10, 10, \"A2=10\".to_string());\n    backend.process_command(10, 10, \"A3=15\".to_string());\n    backend.grid.cells_vec[1][1].valid = false;\n    // Test SUM function\n    let status = backend.process_command(10, 10, \"B1=SLEEP(A1)\".to_string());\n    assert_eq!(status, Status::Success);\n}\n\n#[test]\nfn test_process_command_sum_none() {\n    let mut backend = Backend::init_backend(10, 10);\n    // Assign values to cells\n    backend.process_command(10, 10, \"A1=5\".to_string());\n    backend.process_command(10, 10, \"A2=10\".to_string());\n    backend.process_command(10, 10, \"A3=15\".to_string());\n    backend.grid.cells_vec[1][1].valid = false;\n    // Test SUM function\n    let status = backend.process_command(10, 10, \"B1=SUM(A1:A3)\".to_string());\n    assert_eq!(status, Status::Success);\n    assert_eq!(backend.get_node_value(Value::Cell(1, 2)), None);\n}\n\n#[test]\nfn test_process_command_avg_none() {\n    let mut backend = Backend::init_backend(10, 10);\n    // Assign values to cells\n    backend.process_command(10, 10, \"A1=6\".to_string());\n    backend.process_command(10, 10, \"A2=12\".to_string());\n    backend.process_command(10, 10, \"A3=18\".to_string());\n\n    // Test AVG function\n    backend.grid.cells_vec[1][1].valid = false;\n    let status = backend.process_command(10, 10, \"B1=AVG(A1:A3)\".to_string());\n    assert_eq!(status, Status::Success);\n    assert_eq!(backend.get_node_value(Value::Cell(1, 2)), None);\n}\n\n#[test]\nfn test_process_command_arithmetic_none() {\n    let mut backend = Backend::init_backend(10, 10);\n    // Assign values to cells\n    backend.process_command(10, 10, \"A1=5\".to_string());\n    backend.process_command(10, 10, \"A2=10\".to_string());\n    // Test arithmetic operations\n    backend.grid.cells_vec[1][1].valid = false;\n    backend.process_command(10, 10, \"B1=A1+A2\".to_string()); // Addition\n    backend.process_command(10, 10, \"B2=A2-A1\".to_string()); // Subtraction\n    backend.process_command(10, 10, \"B3=A1*A2\".to_string()); // Multiplication\n    backend.process_command(10, 10, \"B4=A2/A1\".to_string()); // Division\n\n    assert_eq!(backend.get_node_value(Value::Cell(1, 2)), None); // 5+10\n    assert_eq!(backend.get_node_value(Value::Cell(2, 2)), None); // 10-5\n    assert_eq!(backend.get_node_value(Value::Cell(3, 2)), None); // 5*10\n    assert_eq!(backend.get_node_value(Value::Cell(4, 2)), None); // 10/5\n}\n\n#[test]\nfn test_circular_dependency() {\n    let mut backend = Backend::init_backend(10, 10);\n    // Create a circular dependency\n    backend.process_command(10, 10, \"A1=5\".to_string());\n    backend.process_command(10, 10, \"A2=A1+10\".to_string());\n    let status = backend.process_command(10, 10, \"A1=A2+5\".to_string());\n\n    assert_eq!(status, Status::CircularDependency);\n}\n\n#[test]\nfn test_undo_redo() {\n    let mut backend = Backend::init_backend(10, 10);\n\n    // Make changes\n    backend.process_command(10, 10, \"A1=5\".to_string());\n    assert_eq!(backend.get_node_value(Value::Cell(1, 1)), Some(5));\n\n    backend.process_command(10, 10, \"A1=10\".to_string());\n    assert_eq!(backend.get_node_value(Value::Cell(1, 1)), Some(10));\n\n    // Undo\n    backend.process_command(10, 10, \"undo\".to_string());\n    assert_eq!(backend.get_node_value(Value::Cell(1, 1)), Some(5));\n\n    // Redo\n    backend.process_command(10, 10, \"redo\".to_string());\n    assert_eq!(backend.get_node_value(Value::Cell(1, 1)), Some(10));\n}\n\n#[test]\nfn test_serialization() {\n    let mut backend = Backend::init_backend(5, 5);\n    backend.process_command(5, 5, \"A1=42\".to_string());\n\n    // Create a temporary file path\n    let temp_file = \"test_serialization.json\";\n\n    // Serialize\n    let result = backend.serial(temp_file);\n    assert!(result.is_ok());\n\n    // Deserialize\n    let loaded_backend = Backend::deserial(temp_file);\n    assert!(loaded_backend.is_ok());\n\n    let loaded_backend = loaded_backend.unwrap();\n    assert_eq!(loaded_backend.get_node_value(Value::Cell(1, 1)), Some(42));\n\n    // Clean up\n    if let Ok(_) = fs::remove_file(temp_file) {\n        // File deleted successfully\n    }\n}\n\n#[test]\nfn test_invalid_range() {\n    let mut backend = Backend::init_backend(10, 10);\n    let status = backend.process_command(10, 10, \"A1=SUM(Z1:Z10)\".to_string());\n    // Z column is beyond our 10 columns, so it should report invalid range\n    assert_eq!(status, Status::UnrecognizedCmd);\n}\n\n#[test]\nfn test_min_max_functions() {\n    let mut backend = Backend::init_backend(10, 10);\n    // Assign values to cells\n    backend.process_command(10, 10, \"A1=5\".to_string());\n    backend.process_command(10, 10, \"A2=10\".to_string());\n    backend.process_command(10, 10, \"A3=15\".to_string());\n    backend.process_command(10, 10, \"A4=2\".to_string());\n\n    // Test MIN and MAX functions\n    backend.process_command(10, 10, \"B1=MIN(A1:A4)\".to_string());\n    backend.process_command(10, 10, \"B2=MAX(A1:A4)\".to_string());\n\n    assert_eq!(backend.get_node_value(Value::Cell(1, 2)), Some(2)); // MIN\n    assert_eq!(backend.get_node_value(Value::Cell(2, 2)), Some(15)); // MAX\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","yuvikachaudhary","Desktop","Semester 4","COP290","spreadsheet_rust","tests","backend_terminal.rs"],"content":"use project::terminal::backend::*;\nuse project::terminal::functions::Operation;\n#[allow(unused_imports)]\nuse project::terminal::graph::Node;\nuse project::terminal::types::Coordinates;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_generate_grid() {\n        let grid = generate_grid(3, 3);\n\n        // Check grid dimensions\n        assert_eq!(grid.len(), 4); // 0-indexed + specified rows\n        assert_eq!(grid[0].len(), 4); // 0-indexed + specified columns\n\n        // Check node initialization\n        let node = \u0026grid[1][2]; // Random cell\n        assert_eq!(node.node_value, 0);\n        assert_eq!(node.value1, Coordinates { row: -1, col: -1 });\n        assert_eq!(node.value2, Coordinates { row: -1, col: -1 });\n        assert_eq!(node.position, Coordinates { row: 1, col: 2 });\n        assert_eq!(node.op, Operation::Cons);\n        assert!(node.valid);\n        assert!(!node.visited);\n        assert!(node.dependents.is_empty());\n    }\n\n    #[test]\n    fn test_add_edges_binary_operation() {\n        let mut grid = generate_grid(3, 3);\n\n        // Create a simple dependency: C1 = A1 + B1\n        let a1 = Coordinates { row: 1, col: 1 };\n        let b1 = Coordinates { row: 1, col: 2 };\n        let c1 = Coordinates { row: 1, col: 3 };\n\n        add_edges(\u0026mut grid, a1, b1, c1, Operation::Add, true);\n\n        // Check that A1 and B1 have C1 as dependent\n        assert!(grid[1][1].dependents.contains(\u0026c1));\n        assert!(grid[1][2].dependents.contains(\u0026c1));\n    }\n\n    #[test]\n    fn test_add_edges_range_operation() {\n        let mut grid = generate_grid(3, 3);\n\n        // Create a range dependency: D1 = SUM(A1:B2)\n        let a1 = Coordinates { row: 1, col: 1 };\n        let b2 = Coordinates { row: 2, col: 2 };\n        let d1 = Coordinates { row: 1, col: 3 };\n\n        add_edges(\u0026mut grid, a1, b2, d1, Operation::Sum, true);\n\n        // Check that all cells in range have D1 as dependent\n        assert!(grid[1][1].dependents.contains(\u0026d1)); // A1\n        assert!(grid[1][2].dependents.contains(\u0026d1)); // B1\n        assert!(grid[2][1].dependents.contains(\u0026d1)); // A2\n        assert!(grid[2][2].dependents.contains(\u0026d1)); // B2\n    }\n\n    #[test]\n    fn test_add_edges_range_sleep() {\n        let mut grid = generate_grid(3, 3);\n\n        // Create a range dependency: D1 = SUM(A1:B2)\n        let a1 = Coordinates { row: -1, col: -1 };\n        let b2 = Coordinates { row: 2, col: 2 };\n        let d1 = Coordinates { row: 1, col: 3 };\n\n        add_edges(\u0026mut grid, a1, b2, d1, Operation::Slp, true);\n\n        // Check that all cells in range have D1 as dependent\n        assert!(!grid[1][1].dependents.contains(\u0026d1)); // A1\n    }\n\n    #[test]\n    fn test_add_edges_range_enable() {\n        let mut grid = generate_grid(3, 3);\n\n        // Create a range dependency: D1 = SUM(A1:B2)\n        let a1 = Coordinates { row: -1, col: -1 };\n        let b2 = Coordinates { row: 2, col: 2 };\n        let d1 = Coordinates { row: 1, col: 3 };\n\n        add_edges(\u0026mut grid, a1, b2, d1, Operation::EnableOutput, true);\n\n        // Check that all cells in range have D1 as dependent\n        assert!(!grid[1][1].dependents.contains(\u0026d1)); // A1\n        assert!(!grid[1][2].dependents.contains(\u0026d1)); // B1\n        assert!(!grid[2][1].dependents.contains(\u0026d1)); // A2\n        assert!(!grid[2][2].dependents.contains(\u0026d1)); // B2\n    }\n\n    #[test]\n    fn test_break_edges_binary_operation() {\n        let mut grid = generate_grid(3, 3);\n\n        // Setup: C1 = A1 + B1\n        let a1 = Coordinates { row: 1, col: 1 };\n        let b1 = Coordinates { row: 1, col: 2 };\n        let c1 = Coordinates { row: 1, col: 3 };\n\n        // First add edges\n        add_edges(\u0026mut grid, a1, b1, c1, Operation::Add, true);\n\n        // Then break them\n        break_edges(\u0026mut grid, a1, b1, c1, Operation::Add, true);\n\n        // Check that A1 and B1 no longer have C1 as dependent\n        assert!(!grid[1][1].dependents.contains(\u0026c1));\n        assert!(!grid[1][2].dependents.contains(\u0026c1));\n    }\n\n    #[test]\n    fn test_break_edges_range_operation() {\n        let mut grid = generate_grid(3, 3);\n\n        // Setup: D1 = SUM(A1:B2)\n        let a1 = Coordinates { row: 1, col: 1 };\n        let b2 = Coordinates { row: 2, col: 2 };\n        let d1 = Coordinates { row: 1, col: 3 };\n\n        // First add edges\n        add_edges(\u0026mut grid, a1, b2, d1, Operation::Sum, true);\n\n        // Then break them\n        break_edges(\u0026mut grid, a1, b2, d1, Operation::Sum, true);\n\n        // Check that all cells in range no longer have D1 as dependent\n        assert!(!grid[1][1].dependents.contains(\u0026d1)); // A1\n        assert!(!grid[1][2].dependents.contains(\u0026d1)); // B1\n        assert!(!grid[2][1].dependents.contains(\u0026d1)); // A2\n        assert!(!grid[2][2].dependents.contains(\u0026d1)); // B2\n    }\n\n    #[test]\n    fn test_has_cycle_no_cycle() {\n        let mut grid = generate_grid(3, 3);\n\n        // Setup: B1 = A1 + 5\n        let a1 = Coordinates { row: 1, col: 1 };\n        let b1 = Coordinates { row: 1, col: 2 };\n        let five = Coordinates { row: 5, col: -1 }; // constant value 5\n\n        add_edges(\u0026mut grid, a1, five, b1, Operation::Add, true);\n\n        // This shouldn't create a cycle\n        assert!(!has_cycle(b1, \u0026mut grid));\n    }\n\n    #[test]\n    fn test_has_cycle_direct_cycle() {\n        let mut grid = generate_grid(3, 3);\n\n        // Setup: A1 = B1 + 5, B1 = A1 + 3\n        let a1 = Coordinates { row: 1, col: 1 };\n        let b1 = Coordinates { row: 1, col: 2 };\n        let five = Coordinates { row: 5, col: -1 }; // constant value 5\n        let three = Coordinates { row: 3, col: -1 }; // constant value 3\n\n        // First add A1 = B1 + 5\n        add_edges(\u0026mut grid, b1, five, a1, Operation::Add, true);\n\n        // Now try to add B1 = A1 + 3 (which creates a cycle)\n        add_edges(\u0026mut grid, a1, three, b1, Operation::Add, true);\n\n        // This should detect a cycle\n        assert!(has_cycle(b1, \u0026mut grid));\n    }\n\n    #[test]\n    fn test_has_cycle_indirect_cycle() {\n        let mut grid = generate_grid(3, 3);\n\n        // Setup: A1 = C1 + 1, B1 = A1 + 2, C1 = B1 + 3\n        let a1 = Coordinates { row: 1, col: 1 };\n        let b1 = Coordinates { row: 1, col: 2 };\n        let c1 = Coordinates { row: 1, col: 3 };\n        let one = Coordinates { row: 1, col: -1 };\n        let two = Coordinates { row: 2, col: -1 };\n        let three = Coordinates { row: 3, col: -1 };\n\n        // Add first two relationships\n        add_edges(\u0026mut grid, c1, one, a1, Operation::Add, true);\n        add_edges(\u0026mut grid, a1, two, b1, Operation::Add, true);\n\n        // Now try to add C1 = B1 + 3 (which creates an indirect cycle)\n        add_edges(\u0026mut grid, b1, three, c1, Operation::Add, true);\n\n        // This should detect a cycle\n        assert!(has_cycle(c1, \u0026mut grid));\n    }\n\n    #[test]\n    fn test_evaluate_node_constant() {\n        let mut grid = generate_grid(3, 3);\n\n        // Set A1 = 42\n        let a1 = Coordinates { row: 1, col: 1 };\n        let val = Coordinates { row: 42, col: -1 }; // constant value 42\n\n        grid[1][1].op = Operation::Cons;\n        grid[1][1].value1 = val;\n\n        evaluate_node(\u0026mut grid, a1);\n\n        // Check that A1 has value 42\n        assert_eq!(grid[1][1].node_value, 42);\n        assert!(grid[1][1].valid);\n    }\n\n    #[test]\n    fn test_evaluate_node_binary_add() {\n        let mut grid = generate_grid(3, 3);\n\n        // Set A1 = 10, B1 = 20, C1 = A1 + B1\n        let a1 = Coordinates { row: 1, col: 1 };\n        let b1 = Coordinates { row: 1, col: 2 };\n        let c1 = Coordinates { row: 1, col: 3 };\n\n        // Set values for A1 and B1\n        grid[1][1].op = Operation::Cons;\n        grid[1][1].value1 = Coordinates { row: 10, col: -1 };\n        grid[1][2].op = Operation::Cons;\n        grid[1][2].value1 = Coordinates { row: 20, col: -1 };\n\n        // Evaluate them first\n        evaluate_node(\u0026mut grid, a1);\n        evaluate_node(\u0026mut grid, b1);\n\n        // Set C1 = A1 + B1\n        grid[1][3].op = Operation::Add;\n        grid[1][3].value1 = a1;\n        grid[1][3].value2 = b1;\n\n        // Add dependencies\n        add_edges(\u0026mut grid, a1, b1, c1, Operation::Add, true);\n\n        // Evaluate C1\n        evaluate_node(\u0026mut grid, c1);\n\n        // Check result\n        assert_eq!(grid[1][3].node_value, 30); // 10 + 20\n        assert!(grid[1][3].valid);\n    }\n\n    #[test]\n    fn test_evaluate_node_binary_add_1() {\n        let mut grid = generate_grid(3, 3);\n\n        // Set A1 = 10, B1 = 20, C1 = A1 + B1\n        let a1 = Coordinates { row: 1, col: 1 };\n        let b1 = Coordinates { row: 1, col: 2 };\n        let c1 = Coordinates { row: 1, col: 3 };\n\n        // Set values for A1 and B1\n        grid[1][1].op = Operation::Cons;\n        grid[1][1].value1 = Coordinates { row: 10, col: -1 };\n        grid[1][2].op = Operation::Cons;\n        grid[1][2].value1 = Coordinates { row: 20, col: -1 };\n\n        // Evaluate them first\n        evaluate_node(\u0026mut grid, a1);\n        evaluate_node(\u0026mut grid, b1);\n\n        // Set C1 = A1 + B1\n        grid[1][3].op = Operation::Add;\n        grid[1][3].value1 = Coordinates { row: 1, col: -1 };\n        grid[1][3].value2 = Coordinates { row: 1, col: 2 };\n\n        // Add dependencies\n        add_edges(\u0026mut grid, a1, b1, c1, Operation::Add, true);\n\n        // Evaluate C1\n        evaluate_node(\u0026mut grid, c1);\n\n        // Check result\n        assert_eq!(grid[1][3].node_value, 21); // 10 + 20\n        assert!(grid[1][3].valid);\n    }\n\n    #[test]\n    fn test_evaluate_node_binary_add_2() {\n        let mut grid = generate_grid(3, 3);\n\n        // Set A1 = 10, B1 = 20, C1 = A1 + B1\n        let a1 = Coordinates { row: 1, col: 1 };\n        let b1 = Coordinates { row: 1, col: 2 };\n        let c1 = Coordinates { row: 1, col: 3 };\n\n        // Set values for A1 and B1\n        grid[1][1].op = Operation::Cons;\n        grid[1][1].value1 = Coordinates { row: 10, col: -1 };\n        grid[1][2].op = Operation::Cons;\n        grid[1][2].value1 = Coordinates { row: 20, col: -1 };\n\n        // Evaluate them first\n        evaluate_node(\u0026mut grid, a1);\n        evaluate_node(\u0026mut grid, b1);\n\n        // Set C1 = A1 + B1\n        grid[1][3].op = Operation::Add;\n        grid[1][3].value1 = Coordinates { row: 1, col: 1 };\n        grid[1][3].value2 = Coordinates { row: 1, col: -1 };\n\n        // Add dependencies\n        add_edges(\u0026mut grid, a1, b1, c1, Operation::Add, true);\n\n        // Evaluate C1\n        evaluate_node(\u0026mut grid, c1);\n\n        // Check result\n        assert_eq!(grid[1][3].node_value, 11); // 10 + 20\n        assert!(grid[1][3].valid);\n    }\n\n    #[test]\n    fn test_evaluate_node_binary_add_3() {\n        let mut grid = generate_grid(3, 3);\n\n        // Set A1 = 10, B1 = 20, C1 = A1 + B1\n        let a1 = Coordinates { row: 1, col: 1 };\n        let b1 = Coordinates { row: 1, col: 2 };\n        let c1 = Coordinates { row: 1, col: 3 };\n\n        // Set values for A1 and B1\n        grid[1][1].op = Operation::Cons;\n        grid[1][1].value1 = Coordinates { row: 10, col: -1 };\n        grid[1][2].op = Operation::Cons;\n        grid[1][2].value1 = Coordinates { row: 20, col: -1 };\n\n        // Evaluate them first\n        evaluate_node(\u0026mut grid, a1);\n        evaluate_node(\u0026mut grid, b1);\n\n        // Set C1 = A1 + B1\n        grid[1][3].op = Operation::Add;\n        grid[1][3].value1 = Coordinates { row: 1, col: -1 };\n        grid[1][3].value2 = Coordinates { row: 1, col: -1 };\n\n        // Add dependencies\n        add_edges(\u0026mut grid, a1, b1, c1, Operation::Add, true);\n\n        // Evaluate C1\n        evaluate_node(\u0026mut grid, c1);\n\n        // Check result\n        assert_eq!(grid[1][3].node_value, 2); // 10 + 20\n        assert!(grid[1][3].valid);\n    }\n\n    #[test]\n    fn test_evaluate_node_binary_sub() {\n        let mut grid = generate_grid(3, 3);\n\n        // Set A1 = 30, B1 = 12, C1 = A1 - B1\n        let a1 = Coordinates { row: 1, col: 1 };\n        let b1 = Coordinates { row: 1, col: 2 };\n        let c1 = Coordinates { row: 1, col: 3 };\n\n        // Set values for A1 and B1\n        grid[1][1].op = Operation::Cons;\n        grid[1][1].value1 = Coordinates { row: 30, col: -1 };\n        grid[1][2].op = Operation::Cons;\n        grid[1][2].value1 = Coordinates { row: 12, col: -1 };\n\n        // Evaluate them first\n        evaluate_node(\u0026mut grid, a1);\n        evaluate_node(\u0026mut grid, b1);\n\n        // Set C1 = A1 - B1\n        grid[1][3].op = Operation::Sub;\n        grid[1][3].value1 = a1;\n        grid[1][3].value2 = b1;\n\n        // Add dependencies\n        add_edges(\u0026mut grid, a1, b1, c1, Operation::Sub, true);\n\n        // Evaluate C1\n        evaluate_node(\u0026mut grid, c1);\n\n        // Check result\n        assert_eq!(grid[1][3].node_value, 18); // 30 - 12\n        assert!(grid[1][3].valid);\n    }\n\n    #[test]\n    fn test_evaluate_node_binary_sub1() {\n        let mut grid = generate_grid(3, 3);\n\n        // Set A1 = 10, B1 = 20, C1 = A1 + B1\n        let a1 = Coordinates { row: 1, col: 1 };\n        let b1 = Coordinates { row: 1, col: 2 };\n        let c1 = Coordinates { row: 1, col: 3 };\n\n        // Set values for A1 and B1\n        grid[1][1].op = Operation::Cons;\n        grid[1][1].value1 = Coordinates { row: 10, col: -1 };\n        grid[1][2].op = Operation::Cons;\n        grid[1][2].value1 = Coordinates { row: 20, col: -1 };\n\n        // Evaluate them first\n        evaluate_node(\u0026mut grid, a1);\n        evaluate_node(\u0026mut grid, b1);\n\n        // Set C1 = A1 + B1\n        grid[1][3].op = Operation::Sub;\n        grid[1][3].value1 = Coordinates { row: 1, col: -1 };\n        grid[1][3].value2 = Coordinates { row: 1, col: 2 };\n\n        // Add dependencies\n        add_edges(\u0026mut grid, a1, b1, c1, Operation::Sub, true);\n\n        // Evaluate C1\n        evaluate_node(\u0026mut grid, c1);\n\n        // Check result\n        assert_eq!(grid[1][3].node_value, -19); // 10 + 20\n        assert!(grid[1][3].valid);\n    }\n\n    #[test]\n    fn test_evaluate_node_binary_sub2() {\n        let mut grid = generate_grid(3, 3);\n\n        // Set A1 = 10, B1 = 20, C1 = A1 + B1\n        let a1 = Coordinates { row: 1, col: 1 };\n        let b1 = Coordinates { row: 1, col: 2 };\n        let c1 = Coordinates { row: 1, col: 3 };\n\n        // Set values for A1 and B1\n        grid[1][1].op = Operation::Cons;\n        grid[1][1].value1 = Coordinates { row: 10, col: -1 };\n        grid[1][2].op = Operation::Cons;\n        grid[1][2].value1 = Coordinates { row: 20, col: -1 };\n\n        // Evaluate them first\n        evaluate_node(\u0026mut grid, a1);\n        evaluate_node(\u0026mut grid, b1);\n\n        // Set C1 = A1 + B1\n        grid[1][3].op = Operation::Sub;\n        grid[1][3].value1 = Coordinates { row: 1, col: 1 };\n        grid[1][3].value2 = Coordinates { row: 1, col: -1 };\n\n        // Add dependencies\n        add_edges(\u0026mut grid, a1, b1, c1, Operation::Sub, true);\n\n        // Evaluate C1\n        evaluate_node(\u0026mut grid, c1);\n\n        // Check result\n        assert_eq!(grid[1][3].node_value, 9); // 10 + 20\n        assert!(grid[1][3].valid);\n    }\n\n    #[test]\n    fn test_evaluate_node_binary_sub3() {\n        let mut grid = generate_grid(3, 3);\n\n        // Set A1 = 10, B1 = 20, C1 = A1 + B1\n        let a1 = Coordinates { row: 1, col: 1 };\n        let b1 = Coordinates { row: 1, col: 2 };\n        let c1 = Coordinates { row: 1, col: 3 };\n\n        // Set values for A1 and B1\n        grid[1][1].op = Operation::Cons;\n        grid[1][1].value1 = Coordinates { row: 10, col: -1 };\n        grid[1][2].op = Operation::Cons;\n        grid[1][2].value1 = Coordinates { row: 20, col: -1 };\n\n        // Evaluate them first\n        evaluate_node(\u0026mut grid, a1);\n        evaluate_node(\u0026mut grid, b1);\n\n        // Set C1 = A1 + B1\n        grid[1][3].op = Operation::Sub;\n        grid[1][3].value1 = Coordinates { row: 1, col: -1 };\n        grid[1][3].value2 = Coordinates { row: 1, col: -1 };\n\n        // Add dependencies\n        add_edges(\u0026mut grid, a1, b1, c1, Operation::Sub, true);\n\n        // Evaluate C1\n        evaluate_node(\u0026mut grid, c1);\n\n        // Check result\n        assert_eq!(grid[1][3].node_value, 0); // 10 + 20\n        assert!(grid[1][3].valid);\n    }\n\n    #[test]\n    fn test_evaluate_node_binary_mul() {\n        let mut grid = generate_grid(3, 3);\n\n        // Set A1 = 7, B1 = 6, C1 = A1 * B1\n        let a1 = Coordinates { row: 1, col: 1 };\n        let b1 = Coordinates { row: 1, col: 2 };\n        let c1 = Coordinates { row: 1, col: 3 };\n\n        // Set values for A1 and B1\n        grid[1][1].op = Operation::Cons;\n        grid[1][1].value1 = Coordinates { row: 7, col: -1 };\n        grid[1][2].op = Operation::Cons;\n        grid[1][2].value1 = Coordinates { row: 6, col: -1 };\n\n        // Evaluate them first\n        evaluate_node(\u0026mut grid, a1);\n        evaluate_node(\u0026mut grid, b1);\n\n        // Set C1 = A1 * B1\n        grid[1][3].op = Operation::Mul;\n        grid[1][3].value1 = a1;\n        grid[1][3].value2 = b1;\n\n        // Add dependencies\n        add_edges(\u0026mut grid, a1, b1, c1, Operation::Mul, true);\n\n        // Evaluate C1\n        evaluate_node(\u0026mut grid, c1);\n\n        // Check result\n        assert_eq!(grid[1][3].node_value, 42); // 7 * 6\n        assert!(grid[1][3].valid);\n    }\n\n    #[test]\n    fn test_evaluate_node_binary_mul1() {\n        let mut grid = generate_grid(3, 3);\n\n        // Set A1 = 10, B1 = 20, C1 = A1 + B1\n        let a1 = Coordinates { row: 1, col: 1 };\n        let b1 = Coordinates { row: 1, col: 2 };\n        let c1 = Coordinates { row: 1, col: 3 };\n\n        // Set values for A1 and B1\n        grid[1][1].op = Operation::Cons;\n        grid[1][1].value1 = Coordinates { row: 10, col: -1 };\n        grid[1][2].op = Operation::Cons;\n        grid[1][2].value1 = Coordinates { row: 20, col: -1 };\n\n        // Evaluate them first\n        evaluate_node(\u0026mut grid, a1);\n        evaluate_node(\u0026mut grid, b1);\n\n        // Set C1 = A1 + B1\n        grid[1][3].op = Operation::Mul;\n        grid[1][3].value1 = Coordinates { row: 1, col: -1 };\n        grid[1][3].value2 = Coordinates { row: 1, col: 2 };\n\n        // Add dependencies\n        add_edges(\u0026mut grid, a1, b1, c1, Operation::Mul, true);\n\n        // Evaluate C1\n        evaluate_node(\u0026mut grid, c1);\n\n        // Check result\n        assert_eq!(grid[1][3].node_value, 20); // 10 + 20\n        assert!(grid[1][3].valid);\n    }\n\n    #[test]\n    fn test_evaluate_node_binary_mul2() {\n        let mut grid = generate_grid(3, 3);\n\n        // Set A1 = 10, B1 = 20, C1 = A1 + B1\n        let a1 = Coordinates { row: 1, col: 1 };\n        let b1 = Coordinates { row: 1, col: 2 };\n        let c1 = Coordinates { row: 1, col: 3 };\n\n        // Set values for A1 and B1\n        grid[1][1].op = Operation::Cons;\n        grid[1][1].value1 = Coordinates { row: 10, col: -1 };\n        grid[1][2].op = Operation::Cons;\n        grid[1][2].value1 = Coordinates { row: 20, col: -1 };\n\n        // Evaluate them first\n        evaluate_node(\u0026mut grid, a1);\n        evaluate_node(\u0026mut grid, b1);\n\n        // Set C1 = A1 + B1\n        grid[1][3].op = Operation::Mul;\n        grid[1][3].value1 = Coordinates { row: 1, col: 1 };\n        grid[1][3].value2 = Coordinates { row: 1, col: -1 };\n\n        // Add dependencies\n        add_edges(\u0026mut grid, a1, b1, c1, Operation::Mul, true);\n\n        // Evaluate C1\n        evaluate_node(\u0026mut grid, c1);\n\n        // Check result\n        assert_eq!(grid[1][3].node_value, 10); // 10 + 20\n        assert!(grid[1][3].valid);\n    }\n\n    #[test]\n    fn test_evaluate_node_binary_mul3() {\n        let mut grid = generate_grid(3, 3);\n\n        // Set A1 = 10, B1 = 20, C1 = A1 + B1\n        let a1 = Coordinates { row: 1, col: 1 };\n        let b1 = Coordinates { row: 1, col: 2 };\n        let c1 = Coordinates { row: 1, col: 3 };\n\n        // Set values for A1 and B1\n        grid[1][1].op = Operation::Cons;\n        grid[1][1].value1 = Coordinates { row: 10, col: -1 };\n        grid[1][2].op = Operation::Cons;\n        grid[1][2].value1 = Coordinates { row: 20, col: -1 };\n\n        // Evaluate them first\n        evaluate_node(\u0026mut grid, a1);\n        evaluate_node(\u0026mut grid, b1);\n\n        // Set C1 = A1 + B1\n        grid[1][3].op = Operation::Mul;\n        grid[1][3].value1 = Coordinates { row: 1, col: -1 };\n        grid[1][3].value2 = Coordinates { row: 1, col: -1 };\n\n        // Add dependencies\n        add_edges(\u0026mut grid, a1, b1, c1, Operation::Mul, true);\n\n        // Evaluate C1\n        evaluate_node(\u0026mut grid, c1);\n\n        // Check result\n        assert_eq!(grid[1][3].node_value, 1); // 10 + 20\n        assert!(grid[1][3].valid);\n    }\n    #[test]\n    fn test_evaluate_node_binary_div() {\n        let mut grid = generate_grid(3, 3);\n\n        // Set A1 = 20, B1 = 4, C1 = A1 / B1\n        let a1 = Coordinates { row: 1, col: 1 };\n        let b1 = Coordinates { row: 1, col: 2 };\n        let c1 = Coordinates { row: 1, col: 3 };\n\n        // Set values for A1 and B1\n        grid[1][1].op = Operation::Cons;\n        grid[1][1].value1 = Coordinates { row: 20, col: -1 };\n        grid[1][2].op = Operation::Cons;\n        grid[1][2].value1 = Coordinates { row: 4, col: -1 };\n\n        // Evaluate them first\n        evaluate_node(\u0026mut grid, a1);\n        evaluate_node(\u0026mut grid, b1);\n\n        // Set C1 = A1 / B1\n        grid[1][3].op = Operation::Div;\n        grid[1][3].value1 = a1;\n        grid[1][3].value2 = b1;\n\n        // Add dependencies\n        add_edges(\u0026mut grid, a1, b1, c1, Operation::Div, true);\n\n        // Evaluate C1\n        evaluate_node(\u0026mut grid, c1);\n\n        // Check result\n        assert_eq!(grid[1][3].node_value, 5); // 20 / 4\n        assert!(grid[1][3].valid);\n    }\n\n    #[test]\n    fn test_evaluate_node_div_by_zero() {\n        let mut grid = generate_grid(3, 3);\n\n        // Set A1 = 20, B1 = 0, C1 = A1 / B1\n        let a1 = Coordinates { row: 1, col: 1 };\n        let b1 = Coordinates { row: 1, col: 2 };\n        let c1 = Coordinates { row: 1, col: 3 };\n\n        // Set values for A1 and B1\n        grid[1][1].op = Operation::Cons;\n        grid[1][1].value1 = Coordinates { row: 20, col: -1 };\n        grid[1][2].op = Operation::Cons;\n        grid[1][2].value1 = Coordinates { row: 0, col: -1 };\n\n        // Evaluate them first\n        evaluate_node(\u0026mut grid, a1);\n        evaluate_node(\u0026mut grid, b1);\n\n        // Set C1 = A1 / B1\n        grid[1][3].op = Operation::Div;\n        grid[1][3].value1 = a1;\n        grid[1][3].value2 = b1;\n\n        // Add dependencies\n        add_edges(\u0026mut grid, a1, b1, c1, Operation::Div, true);\n\n        // Evaluate C1\n        evaluate_node(\u0026mut grid, c1);\n\n        // Check result - should be invalid due to division by zero\n        assert!(!grid[1][3].valid);\n    }\n\n    #[test]\n    fn test_getting_things_updated_success() {\n        let mut grid = generate_grid(3, 3);\n\n        // Set A1 = 10, B1 = 20\n        let a1 = Coordinates { row: 1, col: 1 };\n        let b1 = Coordinates { row: 1, col: 2 };\n        let c1 = Coordinates { row: 1, col: 3 };\n\n        // Set up initial values\n        grid[1][1].op = Operation::Cons;\n        grid[1][1].value1 = Coordinates { row: 10, col: -1 };\n        grid[1][2].op = Operation::Cons;\n        grid[1][2].value1 = Coordinates { row: 20, col: -1 };\n\n        // Evaluate initial values\n        evaluate_node(\u0026mut grid, a1);\n        evaluate_node(\u0026mut grid, b1);\n\n        // Now update C1 = A1 + B1\n        let result = getting_things_updated(\u0026mut grid, c1, a1, b1, Operation::Add);\n\n        // Check result code and cell value\n        assert_eq!(result, 1); // Success\n        assert_eq!(grid[1][3].node_value, 30); // 10 + 20\n    }\n\n    #[test]\n    fn test_getting_things_updated_cycle_detection() {\n        let mut grid = generate_grid(3, 3);\n\n        // Set up A1 = 10, B1 = A1 * 2\n        let a1 = Coordinates { row: 1, col: 1 };\n        let b1 = Coordinates { row: 1, col: 2 };\n        let two = Coordinates { row: 2, col: -1 };\n\n        // Set initial value for A1 = 10\n        grid[1][1].op = Operation::Cons;\n        grid[1][1].value1 = Coordinates { row: 10, col: -1 };\n        evaluate_node(\u0026mut grid, a1);\n\n        // Set B1 = A1 * 2\n        grid[1][2].op = Operation::Mul;\n        grid[1][2].value1 = a1;\n        grid[1][2].value2 = two;\n        add_edges(\u0026mut grid, a1, two, b1, Operation::Mul, true);\n        evaluate_node(\u0026mut grid, b1);\n\n        // Now try to update A1 = B1 + 5 (which would create a cycle)\n        let five = Coordinates { row: 5, col: -1 };\n        let result = getting_things_updated(\u0026mut grid, a1, b1, five, Operation::Add);\n\n        // Should detect cycle and return error code\n        assert_eq!(result, 5); // Cycle detected\n\n        // A1 should retain its original value\n        assert_eq!(grid[1][1].node_value, 10);\n    }\n\n    #[test]\n    fn test_update_topo_simple_chain() {\n        let mut grid = generate_grid(3, 3);\n\n        // Set A1 = 10, B1 = A1 * 2, C1 = B1 + 5\n        let a1 = Coordinates { row: 1, col: 1 };\n        let b1 = Coordinates { row: 1, col: 2 };\n        let c1 = Coordinates { row: 1, col: 3 };\n        let two = Coordinates { row: 2, col: -1 };\n        let five = Coordinates { row: 5, col: -1 };\n\n        // Set up initial values\n        grid[1][1].op = Operation::Cons;\n        grid[1][1].value1 = Coordinates { row: 10, col: -1 };\n        evaluate_node(\u0026mut grid, a1);\n\n        // Set B1 = A1 * 2\n        grid[1][2].op = Operation::Mul;\n        grid[1][2].value1 = a1;\n        grid[1][2].value2 = two;\n        add_edges(\u0026mut grid, a1, two, b1, Operation::Mul, true);\n\n        // Set C1 = B1 + 5\n        grid[1][3].op = Operation::Add;\n        grid[1][3].value1 = b1;\n        grid[1][3].value2 = five;\n        add_edges(\u0026mut grid, b1, five, c1, Operation::Add, true);\n\n        // Update starting from A1\n        update_topo(\u0026mut grid, a1);\n\n        // Check the propagated values\n        assert_eq!(grid[1][1].node_value, 10); // A1 = 10\n        assert_eq!(grid[1][2].node_value, 20); // B1 = A1 * 2 = 10 * 2 = 20\n        assert_eq!(grid[1][3].node_value, 25); // C1 = B1 + 5 = 20 + 5 = 25\n    }\n\n    #[test]\n    fn test_reset_visited() {\n        let mut grid = generate_grid(3, 3);\n\n        // Set up a simple structure with dependents\n        let a1 = Coordinates { row: 1, col: 1 };\n        let b1 = Coordinates { row: 1, col: 2 };\n        let c1 = Coordinates { row: 1, col: 3 };\n\n        // Mark all as visited\n        grid[1][1].visited = true;\n        grid[1][2].visited = true;\n        grid[1][3].visited = true;\n\n        // Set up dependencies: A1 -\u003e B1 -\u003e C1\n        grid[1][1].dependents.push(b1);\n        grid[1][2].dependents.push(c1);\n\n        // Reset visited flags starting from A1\n        reset_visited(\u0026mut grid, a1);\n\n        // Check that all flags were reset\n        assert!(!grid[1][1].visited);\n        assert!(!grid[1][2].visited);\n        assert!(!grid[1][3].visited);\n    }\n\n    #[test]\n    fn test_topological_sort() {\n        let mut grid = generate_grid(3, 3);\n\n        // Set up a simple structure with dependencies: A1 -\u003e B1 -\u003e C1\n        let a1 = Coordinates { row: 1, col: 1 };\n        let b1 = Coordinates { row: 1, col: 2 };\n        let c1 = Coordinates { row: 1, col: 3 };\n\n        // Set up dependencies\n        grid[1][1].dependents.push(b1);\n        grid[1][2].dependents.push(c1);\n\n        // Perform topological sort\n        let mut stack = Vec::new();\n        topological_sort(\u0026mut grid, a1, \u0026mut stack);\n\n        // Check the order in the stack (it should be C1, B1, A1)\n        assert_eq!(stack.len(), 3);\n        assert_eq!(stack[0], c1); // C1 should be first out of the stack\n        assert_eq!(stack[1], b1); // B1 should be second\n        assert_eq!(stack[2], a1); // A1 should be last\n    }\n    #[test]\n    fn test_evaluate_node_sleep() {\n        let mut grid = generate_grid(3, 3);\n        let a1 = Coordinates { row: 1, col: 1 };\n\n        grid[1][1].op = Operation::Slp;\n        grid[1][1].value1 = Coordinates { row: 1, col: -1 };\n\n        evaluate_node(\u0026mut grid, a1);\n\n        assert_eq!(grid[1][1].node_value, 1);\n        assert!(grid[1][1].valid);\n    }\n    #[test]\n    fn test_evaluate_node_std_range() {\n        let mut grid = generate_grid(3, 3);\n        let a1 = Coordinates { row: 1, col: 1 };\n        let b2 = Coordinates { row: 2, col: 2 };\n        let d1 = Coordinates { row: 1, col: 3 };\n\n        // Fill A1:B2 with constants\n        for i in 1..=2 {\n            for j in 1..=2 {\n                grid[i][j].op = Operation::Cons;\n                grid[i][j].value1 = Coordinates {\n                    row: 5 * (i + j) as i32,\n                    col: -1,\n                };\n                evaluate_node(\n                    \u0026mut grid,\n                    Coordinates {\n                        row: i as i32,\n                        col: j as i32,\n                    },\n                );\n            }\n        }\n\n        grid[1][3].op = Operation::Std;\n        grid[1][3].value1 = a1;\n        grid[1][3].value2 = b2;\n\n        evaluate_node(\u0026mut grid, d1);\n\n        assert!(grid[1][3].valid);\n    }\n    #[test]\n    fn test_evaluate_node_min_range() {\n        let mut grid = generate_grid(3, 3);\n        let a1 = Coordinates { row: 1, col: 1 };\n        let b2 = Coordinates { row: 2, col: 2 };\n        let d1 = Coordinates { row: 1, col: 3 };\n\n        // Fill A1:B2 with constants\n        for i in 1..=2 {\n            for j in 1..=2 {\n                grid[i][j].op = Operation::Cons;\n                grid[i][j].value1 = Coordinates {\n                    row: 5 * (i + j) as i32,\n                    col: 3,\n                };\n                evaluate_node(\n                    \u0026mut grid,\n                    Coordinates {\n                        row: i as i32,\n                        col: j as i32,\n                    },\n                );\n            }\n        }\n\n        grid[1][3].op = Operation::Min;\n        grid[1][3].value1 = a1;\n        grid[1][3].value2 = b2;\n\n        evaluate_node(\u0026mut grid, d1);\n\n        assert!(grid[1][3].valid);\n    }\n    #[test]\n    fn test_evaluate_node_max_range() {\n        let mut grid = generate_grid(3, 3);\n        let a1 = Coordinates { row: 1, col: 1 };\n        let b2 = Coordinates { row: 2, col: 2 };\n        let d1 = Coordinates { row: 1, col: 3 };\n\n        // Fill A1:B2 with constants\n        for i in 1..=2 {\n            for j in 1..=2 {\n                grid[i][j].op = Operation::Cons;\n                grid[i][j].value1 = Coordinates {\n                    row: 5 * (i + j) as i32,\n                    col: -1,\n                };\n                evaluate_node(\n                    \u0026mut grid,\n                    Coordinates {\n                        row: i as i32,\n                        col: j as i32,\n                    },\n                );\n            }\n        }\n\n        grid[1][3].op = Operation::Max;\n        grid[1][3].value1 = a1;\n        grid[1][3].value2 = b2;\n\n        evaluate_node(\u0026mut grid, d1);\n\n        assert!(grid[1][3].valid);\n    }\n    #[test]\n    fn test_evaluate_node_avg_range() {\n        let mut grid = generate_grid(3, 3);\n        let a1 = Coordinates { row: 1, col: 1 };\n        let b2 = Coordinates { row: 2, col: 2 };\n        let d1 = Coordinates { row: 1, col: 3 };\n\n        // Fill A1:B2 with constants\n        for i in 1..=2 {\n            for j in 1..=2 {\n                grid[i][j].op = Operation::Cons;\n                grid[i][j].value1 = Coordinates {\n                    row: 5 * (i + j) as i32,\n                    col: -1,\n                };\n                evaluate_node(\n                    \u0026mut grid,\n                    Coordinates {\n                        row: i as i32,\n                        col: j as i32,\n                    },\n                );\n            }\n        }\n\n        grid[1][3].op = Operation::Avg;\n        grid[1][3].value1 = a1;\n        grid[1][3].value2 = b2;\n\n        evaluate_node(\u0026mut grid, d1);\n\n        assert!(grid[1][3].valid);\n    }\n    #[test]\n    fn test_evaluate_node_sum_range() {\n        let mut grid = generate_grid(3, 3);\n        let a1 = Coordinates { row: 1, col: 1 };\n        let b2 = Coordinates { row: 2, col: 2 };\n        let d1 = Coordinates { row: 1, col: 3 };\n\n        // Fill A1:B2 with constants\n        for i in 1..=2 {\n            for j in 1..=2 {\n                grid[i][j].op = Operation::Cons;\n                grid[i][j].value1 = Coordinates {\n                    row: 5 * (i + j) as i32,\n                    col: -1,\n                };\n                evaluate_node(\n                    \u0026mut grid,\n                    Coordinates {\n                        row: i as i32,\n                        col: j as i32,\n                    },\n                );\n            }\n        }\n\n        grid[1][3].op = Operation::Sum;\n        grid[1][3].value1 = a1;\n        grid[1][3].value2 = b2;\n\n        evaluate_node(\u0026mut grid, d1);\n\n        assert!(grid[1][3].valid);\n    }\n    #[test]\n    fn test_add_and_break_edges_old_dependencies() {\n        let mut grid = generate_grid(3, 3);\n        let a1 = Coordinates { row: 1, col: 1 };\n        let b1 = Coordinates { row: 1, col: 2 };\n        let c1 = Coordinates { row: 1, col: 3 };\n\n        // Initial: C1 = A1 + B1\n        getting_things_updated(\u0026mut grid, c1, a1, b1, Operation::Add);\n\n        // Update C1 = A1 - B1 (this should break previous edges using old values)\n        getting_things_updated(\u0026mut grid, c1, a1, b1, Operation::Sub);\n\n        // C1 should still be dependent on A1 and B1 (new op)\n        assert!(grid[1][1].dependents.contains(\u0026c1));\n        assert!(grid[1][2].dependents.contains(\u0026c1));\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","yuvikachaudhary","Desktop","Semester 4","COP290","spreadsheet_rust","tests","common_ext.rs"],"content":"use project::extension::common::*;\n\n#[test]\npub fn tesst() {\n    let mut val = Value::Const(5);\n    let my_val = val.row();\n    assert_eq!(my_val, 0);\n    let my_val = val.col();\n    assert_eq!(my_val, 0);\n    let mut my_val = val.assign_row(2);\n    assert_eq!(my_val, ());\n    let mut my_val = val.assign_col(3);\n    assert_eq!(my_val, ());\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","yuvikachaudhary","Desktop","Semester 4","COP290","spreadsheet_rust","tests","frontend_ext.rs"],"content":"use project::extension::backend::backend::*;\n#[allow(unused_imports)]\nuse project::extension::common::{Operation, Value};\nuse project::extension::frontend::terminal::*;\n\n#[cfg(test)]\nmod frontend_tests {\n    use super::*;\n\n    #[test]\n    fn test_column_decoder() {\n        // Test basic column conversions\n        assert_eq!(column_decoder(1), \"A\");\n        assert_eq!(column_decoder(2), \"B\");\n        assert_eq!(column_decoder(26), \"Z\");\n        assert_eq!(column_decoder(27), \"AA\");\n        assert_eq!(column_decoder(28), \"AB\");\n        assert_eq!(column_decoder(52), \"AZ\");\n        assert_eq!(column_decoder(53), \"BA\");\n        assert_eq!(column_decoder(702), \"ZZ\");\n        assert_eq!(column_decoder(703), \"AAA\");\n    }\n\n    #[test]\n    fn test_frontend_initialization() {\n        // Test initialization with empty path\n        let frontend = Frontend::init_frontend(10, 20, \"\");\n\n        // Check that default values are set correctly\n        assert_eq!(frontend.start, Value::Cell(1, 1));\n        assert_eq!(frontend.dimension, Value::Cell(10, 20));\n        assert_eq!(frontend.print_enabled, true);\n\n        // Check that backend was initialized with correct dimensions\n        assert_eq!(frontend.backend.grid.get_row_size(), 11); // +1 because backend adds 1\n        assert_eq!(frontend.backend.grid.get_column_size(), 21); // +1 because backend adds 1\n\n        // Test initialization with a path (this would require creating a test file first)\n        // This part is more complex and might need mocking, so we'll skip it for now\n    }\n    #[test]\n    fn test_frontend_from_file() {\n        // Test initialization with empty path\n        let frontend = Frontend::init_frontend(11, 11, \"gradient.json\");\n\n        // Check that default values are set correctly\n        assert_eq!(frontend.start, Value::Cell(1, 1));\n        assert_eq!(frontend.dimension, Value::Cell(10, 10));\n        assert_eq!(frontend.print_enabled, true);\n\n        // Check that backend was initialized with correct dimensions\n        assert_eq!(frontend.backend.grid.get_row_size(), 11); // +1 because backend adds 1\n        assert_eq!(frontend.backend.grid.get_column_size(), 11); // +1 because backend adds 1\n\n        // Test initialization with a path (this would require creating a test file first)\n        // This part is more complex and might need mocking, so we'll skip it for now\n    }\n\n    #[test]\n    fn test_execute_status() {\n        // Test navigation commands\n        let mut frontend = Frontend::init_frontend(100, 100, \"\");\n\n        // Test Left command\n        frontend.start = Value::Cell(50, 50);\n        frontend.execute_status(\u0026Status::Left);\n        assert_eq!(frontend.start, Value::Cell(50, 40));\n\n        // Test extreme Left (should stop at 1)\n        frontend.start = Value::Cell(50, 5);\n        frontend.execute_status(\u0026Status::Left);\n        assert_eq!(frontend.start, Value::Cell(50, 1));\n\n        // Test Right command\n        frontend.start = Value::Cell(50, 50);\n        frontend.execute_status(\u0026Status::Right);\n        assert_eq!(frontend.start, Value::Cell(50, 60));\n\n        // Test extreme Right (should stop at dimension-9)\n        frontend.start = Value::Cell(50, 95);\n        frontend.execute_status(\u0026Status::Right);\n        assert_eq!(frontend.start, Value::Cell(50, 91)); // dimension.col() - 9\n\n        // Test Up command\n        frontend.start = Value::Cell(50, 50);\n        frontend.execute_status(\u0026Status::Up);\n        assert_eq!(frontend.start, Value::Cell(40, 50));\n\n        // Test extreme Up (should stop at 1)\n        frontend.start = Value::Cell(5, 50);\n        frontend.execute_status(\u0026Status::Up);\n        assert_eq!(frontend.start, Value::Cell(1, 50));\n\n        // Test Down command\n        frontend.start = Value::Cell(50, 50);\n        frontend.execute_status(\u0026Status::Down);\n        assert_eq!(frontend.start, Value::Cell(60, 50));\n\n        // Test extreme Down (should stop at dimension-9)\n        frontend.start = Value::Cell(95, 50);\n        frontend.execute_status(\u0026Status::Down);\n        assert_eq!(frontend.start, Value::Cell(91, 50)); // dimension.row() - 9\n\n        // Test PrintDisabled command\n        frontend.execute_status(\u0026Status::PrintDisabled);\n        assert_eq!(frontend.print_enabled, false);\n\n        // Test PrintEnabled command\n        frontend.execute_status(\u0026Status::PrintEnabled);\n        assert_eq!(frontend.print_enabled, true);\n\n        // Test ScrollTo command\n        frontend.execute_status(\u0026Status::ScrollTo(25, 35));\n        assert_eq!(frontend.start, Value::Cell(25, 35));\n    }\n\n    #[test]\n    fn test_print_grid_enabled() {\n        let mut frontend = Frontend::init_frontend(10, 10, \"\");\n\n        // Directly access and modify grid nodes through public field\n        frontend.backend.grid.cells_vec[1][1].node_value = 100;\n        frontend.backend.grid.cells_vec[1][1].valid = true;\n\n        frontend.backend.grid.cells_vec[2][2].node_value = 42; // For text display test\n        frontend.backend.grid.cells_vec[2][2].valid = true;\n\n        // Ensure print is enabled\n        frontend.print_enabled = true;\n\n        // Capture stdout to verify output\n        let mut output = Vec::new();\n        {\n            use std::io::Write;\n            frontend.print_grid();\n            writeln!(output, \"Output captured\").unwrap();\n        }\n\n        // Verify that something was written\n        assert!(!output.is_empty());\n    }\n    #[test]\n    fn test_print_grid_err() {\n        let mut frontend = Frontend::init_frontend(10, 10, \"\");\n\n        // Directly access and modify grid nodes through public field\n        frontend.backend.grid.cells_vec[1][1].node_value = 100;\n        frontend.backend.grid.cells_vec[1][1].valid = false;\n\n        frontend.backend.grid.cells_vec[2][2].node_value = 42; // For text display test\n        frontend.backend.grid.cells_vec[2][2].valid = false;\n\n        // Ensure print is enabled\n        frontend.print_enabled = true;\n\n        // Capture stdout to verify output\n        let mut output = Vec::new();\n        {\n            use std::io::Write;\n            frontend.print_grid();\n            writeln!(output, \"Output captured\").unwrap();\n        }\n\n        // Verify that something was written\n        assert!(!output.is_empty());\n    }\n\n    #[test]\n    fn test_print_grid_disabled() {\n        let mut frontend = Frontend::init_frontend(10, 10, \"\");\n\n        // Set up some test data directly\n        frontend.backend.grid.cells_vec[1][1].node_value = 100;\n        frontend.backend.grid.cells_vec[1][1].valid = true;\n\n        // Disable printing\n        frontend.print_enabled = false;\n\n        // With print_enabled set to false, print_grid should return early\n        frontend.print_grid();\n\n        // If we reach here without errors, the test passes\n        assert!(!frontend.print_enabled);\n    }\n\n    #[test]\n    fn test_display() {\n        let mut frontend = Frontend::init_frontend(10, 10, \"\");\n\n        // Set up a test cell\n        frontend.backend.grid.cells_vec[1][1].node_value = 100;\n        frontend.backend.grid.cells_vec[1][1].valid = true;\n        // Capture stdout to verify output\n        let mut output = Vec::new();\n        {\n            use std::io::{Write, stdout};\n            let _stdout_backup = stdout();\n            // Note: In a real test, you'd use a crate like `rexpect` or set up\n            // proper stdout capturing, but this is simplified\n            frontend.display(Status::Success, 0.5);\n            writeln!(output, \"Output captured\").unwrap();\n        }\n        {\n            use std::io::{Write, stdout};\n            let _stdout_backup = stdout();\n            // Note: In a real test, you'd use a crate like `rexpect` or set up\n            // proper stdout capturing, but this is simplified\n            frontend.display(Status::UnrecognizedCmd, 0.5);\n            writeln!(output, \"Output captured\").unwrap();\n        }\n        {\n            use std::io::{Write, stdout};\n            let _stdout_backup = stdout();\n            // Note: In a real test, you'd use a crate like `rexpect` or set up\n            // proper stdout capturing, but this is simplified\n            frontend.display(Status::CircularDependency, 0.5);\n            writeln!(output, \"Output captured\").unwrap();\n        }\n        {\n            use std::io::{Write, stdout};\n            let _stdout_backup = stdout();\n            // Note: In a real test, you'd use a crate like `rexpect` or set up\n            // proper stdout capturing, but this is simplified\n            frontend.display(Status::PrintEnabled, 0.5);\n            writeln!(output, \"Output captured\").unwrap();\n        }\n        {\n            use std::io::{Write, stdout};\n            let _stdout_backup = stdout();\n            // Note: In a real test, you'd use a crate like `rexpect` or set up\n            // proper stdout capturing, but this is simplified\n            frontend.display(Status::PrintDisabled, 0.5);\n            writeln!(output, \"Output captured\").unwrap();\n        }\n        {\n            use std::io::{Write, stdout};\n            let _stdout_backup = stdout();\n            // Note: In a real test, you'd use a crate like `rexpect` or set up\n            // proper stdout capturing, but this is simplified\n            frontend.display(Status::Up, 0.5);\n            writeln!(output, \"Output captured\").unwrap();\n        }\n        {\n            use std::io::{Write, stdout};\n            let _stdout_backup = stdout();\n            // Note: In a real test, you'd use a crate like `rexpect` or set up\n            // proper stdout capturing, but this is simplified\n            frontend.display(Status::Down, 0.5);\n            writeln!(output, \"Output captured\").unwrap();\n        }\n        {\n            use std::io::{Write, stdout};\n            let _stdout_backup = stdout();\n            // Note: In a real test, you'd use a crate like `rexpect` or set up\n            // proper stdout capturing, but this is simplified\n            frontend.display(Status::Left, 0.5);\n            writeln!(output, \"Output captured\").unwrap();\n        }\n        {\n            use std::io::{Write, stdout};\n            let _stdout_backup = stdout();\n            // Note: In a real test, you'd use a crate like `rexpect` or set up\n            // proper stdout capturing, but this is simplified\n            frontend.display(Status::Right, 0.5);\n            writeln!(output, \"Output captured\").unwrap();\n        }\n        {\n            use std::io::{Write, stdout};\n            let _stdout_backup = stdout();\n            // Note: In a real test, you'd use a crate like `rexpect` or set up\n            // proper stdout capturing, but this is simplified\n            frontend.display(Status::ScrollTo(5, 5), 0.5);\n            writeln!(output, \"Output captured\").unwrap();\n        }\n\n        // Verify output contains expected elements\n        // This is just a basic test; actual implementation would need proper stdout capture\n        assert!(!output.is_empty());\n    }\n\n    #[test]\n    fn test_invalid_location_dimension() {\n        // Test handling of invalid location/dimension values\n        let mut frontend = Frontend::init_frontend(10, 10, \"\");\n\n        // Set invalid values that don't match the Cell pattern\n        frontend.start = Value::Const(42); // Using Const instead of Number\n        frontend.dimension = Value::Oper(None, None, Operation::Quit); // Using Oper instead of Text\n\n        // This should not panic, but handle the error gracefully\n        frontend.print_grid();\n\n        // If we reach here without errors, the test passes\n        assert!(frontend.print_enabled); // Check some state was maintained\n    }\n\n    #[test]\n    fn test_column_decoder_edge_cases() {\n        // Test edge cases for column decoder\n        assert_eq!(column_decoder(0), \"\"); // What should happen with 0?\n        assert_eq!(column_decoder(1000), \"ALL\"); // Very large column numbers\n        assert_eq!(column_decoder(18278), \"ZZZ\"); // Test triple-letter columns\n    }\n\n    #[test]\n    fn test_command_processing() {\n        let mut frontend = Frontend::init_frontend(10, 10, \"\");\n\n        // Test that commands are properly passed to backend\n        // You might need to mock backend.process_command to verify this\n\n        // For example:\n        let _command = \"A1 = 100\";\n        // Call a method that would trigger process_command\n        // Then verify backend state changed appropriately\n\n        // Or test navigation commands:\n        frontend.start = Value::Cell(50, 50);\n        frontend.execute_status(\u0026Status::ScrollTo(25, 30));\n        assert_eq!(frontend.start, Value::Cell(25, 30));\n    }\n\n    #[test]\n    fn test_dimension_boundaries() {\n        let mut frontend = Frontend::init_frontend(200, 200, \"\");\n\n        // Test that print_grid correctly handles cells at boundaries\n        frontend.start = Value::Cell(1, 1);\n        frontend.print_grid(); // Should show cells 1,1 through 9,9\n\n        // Test scrolling beyond grid boundaries\n        frontend.execute_status(\u0026Status::ScrollTo(100, 100));\n        // Verify it doesn't go beyond actual dimensions\n        assert_eq!(frontend.start.row(), 100);\n        assert_eq!(frontend.start.col(), 100);\n    }\n\n    #[test]\n    fn test_print_grid_formatting() {\n        let mut frontend = Frontend::init_frontend(10, 10, \"\");\n\n        // Set up a variety of cell values to test formatting\n        frontend.backend.grid.cells_vec[1][1].node_value = 12345; // Large number\n        frontend.backend.grid.cells_vec[1][1].valid = true;\n\n        frontend.backend.grid.cells_vec[2][2].node_value = -42; // Negative number\n        frontend.backend.grid.cells_vec[2][2].valid = true;\n\n        frontend.backend.grid.cells_vec[3][3].node_value = 0; // Zero\n        frontend.backend.grid.cells_vec[3][3].valid = true;\n\n        // In a real test, capture and verify stdout formatting\n        frontend.print_grid();\n        // Assert that formatting is correct (would need proper stdout capture)\n    }\n\n    #[test]\n    fn test_execute_status_chain() {\n        let mut frontend = Frontend::init_frontend(100, 100, \"\");\n\n        // Test complex sequence of status commands\n        frontend.start = Value::Cell(50, 50);\n\n        // Chain of navigation commands\n        frontend.execute_status(\u0026Status::Up); // Should go to row 40\n        frontend.execute_status(\u0026Status::Left); // Should go to col 40\n        frontend.execute_status(\u0026Status::Down); // Should go to row 50\n        frontend.execute_status(\u0026Status::Right); // Should go to col 50\n\n        // Verify final position after chain\n        assert_eq!(frontend.start, Value::Cell(50, 50));\n\n        // Test disable -\u003e enable print\n        frontend.execute_status(\u0026Status::PrintDisabled);\n        assert_eq!(frontend.print_enabled, false);\n        frontend.execute_status(\u0026Status::PrintEnabled);\n        assert_eq!(frontend.print_enabled, true);\n    }\n\n    // Note: run_counter and display are harder to test in isolation\n    // as they deal with stdin/stdout and would require more complex mocking\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","yuvikachaudhary","Desktop","Semester 4","COP290","spreadsheet_rust","tests","functions_ext.rs"],"content":"use project::extension::backend::backend::*;\nuse project::extension::backend::functions::*;\nuse project::extension::backend::graph::*;\n#[allow(unused_imports)]\nuse project::extension::common::{Operation, Value};\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn setup_test_grid(rows: usize, cols: usize) -\u003e Grid {\n        let mut grid = Grid::new(rows, cols);\n        // Initialize grid with default values\n        for i in 0..rows {\n            for j in 0..cols {\n                let node = Node::new(i as isize * cols as isize + j as isize);\n                grid.set_node(i, j, node);\n            }\n        }\n        grid\n    }\n\n    fn setup_grid_with_range_operation(rows: usize, cols: usize, oper: Operation) -\u003e Grid {\n        let mut grid = setup_test_grid(rows, cols);\n\n        // Set up a cell with a range operation\n        let mut function_node = Node::new(0);\n        function_node.function = Some(Value::Oper(\n            Some(Box::new(Value::Cell(0, 0))),\n            Some(Box::new(Value::Cell(2, 2))),\n            oper,\n        ));\n        grid.set_node(3, 3, function_node);\n\n        grid\n    }\n\n    fn setup_grid_with_binary_operation(rows: usize, cols: usize, oper: Operation) -\u003e Grid {\n        let mut grid = setup_test_grid(rows, cols);\n\n        // Set up a cell with a binary operation\n        let mut function_node = Node::new(0);\n        function_node.function = Some(Value::Oper(\n            Some(Box::new(Value::Cell(1, 1))),\n            Some(Box::new(Value::Cell(2, 2))),\n            oper,\n        ));\n        grid.set_node(3, 3, function_node);\n\n        grid\n    }\n\n    fn setup_grid_with_const_operation(rows: usize, cols: usize, oper: Operation) -\u003e Grid {\n        let mut grid = setup_test_grid(rows, cols);\n\n        // Set up a cell with a binary operation using constants\n        let mut function_node = Node::new(0);\n        function_node.function = Some(Value::Oper(\n            Some(Box::new(Value::Const(10))),\n            Some(Box::new(Value::Const(5))),\n            oper,\n        ));\n        grid.set_node(3, 3, function_node);\n\n        grid\n    }\n\n    fn setup_grid_with_mixed_operation(rows: usize, cols: usize, oper: Operation) -\u003e Grid {\n        let mut grid = setup_test_grid(rows, cols);\n\n        // Set up a cell with a binary operation using both cell and constant\n        let mut function_node = Node::new(0);\n        function_node.function = Some(Value::Oper(\n            Some(Box::new(Value::Cell(1, 1))),\n            Some(Box::new(Value::Const(5))),\n            oper,\n        ));\n        grid.set_node(3, 3, function_node);\n\n        grid\n    }\n\n    fn setup_invalid_grid_in_range(rows: usize, cols: usize, oper: Operation) -\u003e Grid {\n        let mut grid = setup_test_grid(rows, cols);\n\n        // Set up a cell with a range operation\n        let mut function_node = Node::new(0);\n        function_node.function = Some(Value::Oper(\n            Some(Box::new(Value::Cell(0, 0))),\n            Some(Box::new(Value::Cell(2, 2))),\n            oper,\n        ));\n        grid.set_node(3, 3, function_node);\n\n        // Make one cell in the range invalid\n        let invalid_node = grid.get_node(1, 1);\n        invalid_node.valid = false;\n\n        grid\n    }\n\n    #[test]\n    fn test_max_function_normal() {\n        let mut grid = setup_grid_with_range_operation(5, 5, Operation::Max);\n\n        // In a 3x3 grid (0,0 to 2,2), the max value would be at (2,2) = 2*5+2 = 12\n        let result = max_function(\u0026mut grid, 3, 3);\n        assert_eq!(result, Some(12));\n    }\n\n    #[test]\n    fn test_max_function_empty_range() {\n        let mut grid = setup_test_grid(5, 5);\n\n        // Set up a cell with a range operation for an empty range\n        let mut function_node = Node::new(0);\n        function_node.function = Some(Value::Oper(\n            Some(Box::new(Value::Cell(2, 2))),\n            Some(Box::new(Value::Cell(1, 1))),\n            Operation::Max,\n        ));\n        grid.set_node(3, 3, function_node);\n\n        // For an empty range (since end \u003c start), should return None\n        let result = max_function(\u0026mut grid, 3, 3);\n        assert_eq!(result, Some(isize::MIN));\n    }\n\n    #[test]\n    fn test_max_function_invalid_cell() {\n        let mut grid = setup_invalid_grid_in_range(5, 5, Operation::Max);\n\n        // If there's an invalid cell in the range, should return None\n        let result = max_function(\u0026mut grid, 3, 3);\n        assert_eq!(result, None);\n    }\n\n    #[test]\n    fn test_max_function_invalid_function() {\n        let mut grid = setup_test_grid(5, 5);\n\n        // Set up a cell with an invalid function structure\n        let mut function_node = Node::new(0);\n        function_node.function = Some(Value::Cell(1, 1)); // Not a Value::Oper\n        grid.set_node(3, 3, function_node);\n\n        // With an invalid function structure, max_function would return Some(isize::MIN), not None\n        let result = max_function(\u0026mut grid, 3, 3);\n        assert_eq!(result, Some(isize::MIN));\n    }\n\n    #[test]\n    fn test_min_function_normal() {\n        let mut grid = setup_grid_with_range_operation(5, 5, Operation::Min);\n\n        // In a 3x3 grid (0,0 to 2,2), the min value would be at (0,0) = 0\n        let result = min_function(\u0026mut grid, 3, 3);\n        assert_eq!(result, Some(0));\n    }\n\n    #[test]\n    fn test_min_function_empty_range() {\n        let mut grid = setup_test_grid(5, 5);\n\n        // Set up a cell with a range operation for an empty range\n        let mut function_node = Node::new(0);\n        function_node.function = Some(Value::Oper(\n            Some(Box::new(Value::Cell(2, 2))),\n            Some(Box::new(Value::Cell(1, 1))),\n            Operation::Min,\n        ));\n        grid.set_node(3, 3, function_node);\n\n        // For an empty range (since end \u003c start), should return None\n        let result = min_function(\u0026mut grid, 3, 3);\n        assert_eq!(result, Some(isize::MAX));\n    }\n\n    #[test]\n    fn test_min_function_invalid_cell() {\n        let mut grid = setup_invalid_grid_in_range(5, 5, Operation::Min);\n\n        // If there's an invalid cell in the range, should return None\n        let result = min_function(\u0026mut grid, 3, 3);\n        assert_eq!(result, None);\n    }\n\n    #[test]\n    fn test_sum_function_normal() {\n        let mut grid = setup_grid_with_range_operation(5, 5, Operation::Sum);\n\n        // In a 3x3 grid (0,0 to 2,2), the sum would be 0+1+2+5+6+7+10+11+12 = 54\n        let result = sum_function(\u0026mut grid, 3, 3);\n        assert_eq!(result, Some(54));\n    }\n\n    #[test]\n    fn test_sum_function_empty_range() {\n        let mut grid = setup_test_grid(5, 5);\n\n        // Set up a cell with a range operation for an empty range\n        let mut function_node = Node::new(0);\n        function_node.function = Some(Value::Oper(\n            Some(Box::new(Value::Cell(2, 2))),\n            Some(Box::new(Value::Cell(1, 1))),\n            Operation::Sum,\n        ));\n        grid.set_node(3, 3, function_node);\n\n        // For an empty range (since end \u003c start), should return Some(0)\n        let result = sum_function(\u0026mut grid, 3, 3);\n        assert_eq!(result, Some(0));\n    }\n\n    #[test]\n    fn test_sum_function_invalid_cell() {\n        let mut grid = setup_invalid_grid_in_range(5, 5, Operation::Sum);\n\n        // If there's an invalid cell in the range, should return None\n        let result = sum_function(\u0026mut grid, 3, 3);\n        assert_eq!(result, None);\n    }\n\n    #[test]\n    fn test_avg_function_normal() {\n        let mut grid = setup_grid_with_range_operation(5, 5, Operation::Avg);\n\n        // In a 3x3 grid (0,0 to 2,2), the average would be (0+1+2+5+6+7+10+11+12)/9 = 54/9 = 6\n        let result = avg_function(\u0026mut grid, 3, 3);\n        assert_eq!(result, Some(6));\n    }\n\n    #[test]\n    fn test_avg_function_empty_range() {\n        let mut grid = setup_test_grid(5, 5);\n\n        // Set up a cell with a range operation for an empty range\n        let mut function_node = Node::new(0);\n        function_node.function = Some(Value::Oper(\n            Some(Box::new(Value::Cell(2, 2))),\n            Some(Box::new(Value::Cell(1, 1))),\n            Operation::Avg,\n        ));\n        grid.set_node(3, 3, function_node);\n\n        // For an empty range (since end \u003c start), should return None\n        let result = avg_function(\u0026mut grid, 3, 3);\n        assert_eq!(result, None);\n    }\n\n    #[test]\n    fn test_avg_function_invalid_cell() {\n        let mut grid = setup_invalid_grid_in_range(5, 5, Operation::Avg);\n\n        // If there's an invalid cell in the range, should return None\n        let result = avg_function(\u0026mut grid, 3, 3);\n        assert_eq!(result, None);\n    }\n\n    #[test]\n    fn test_std_dev_function_normal() {\n        let mut grid = setup_grid_with_range_operation(5, 5, Operation::Std);\n\n        // In a 3x3 grid (0,0 to 2,2), values are 0,1,2,5,6,7,10,11,12\n        // Mean is 6, variance is (6-0)²+(6-1)²+(6-2)²+(6-5)²+(6-6)²+(6-7)²+(6-10)²+(6-11)²+(6-12)² = 36+25+16+1+0+1+16+25+36 = 156\n        // StdDev is sqrt(156/9) = sqrt(17.333) ≈ 4.16 rounded to 4\n        let result = std_dev_function(\u0026mut grid, 3, 3);\n        assert_eq!(result, Some(4));\n    }\n\n    #[test]\n    fn test_std_dev_function_empty_range() {\n        let mut grid = setup_test_grid(5, 5);\n\n        // Set up a cell with a range operation for an empty range\n        let mut function_node = Node::new(0);\n        function_node.function = Some(Value::Oper(\n            Some(Box::new(Value::Cell(2, 2))),\n            Some(Box::new(Value::Cell(1, 1))),\n            Operation::Std,\n        ));\n        grid.set_node(3, 3, function_node);\n\n        // For an empty range (since end \u003c start), should return Some(0)\n        let result = std_dev_function(\u0026mut grid, 3, 3);\n        assert_eq!(result, Some(0));\n    }\n\n    #[test]\n    fn test_std_dev_function_invalid_cell() {\n        let mut grid = setup_invalid_grid_in_range(5, 5, Operation::Std);\n\n        // If there's an invalid cell in the range, should return None\n        let result = std_dev_function(\u0026mut grid, 3, 3);\n        assert_eq!(result, None);\n    }\n\n    #[test]\n    fn test_add_normal() {\n        let mut grid = setup_grid_with_binary_operation(5, 5, Operation::Add);\n\n        // Adding cell(1,1) = 6 and cell(2,2) = 12\n        let result = add(\u0026mut grid, 3, 3);\n        assert_eq!(result, Some(18));\n    }\n\n    #[test]\n    fn test_add_with_const() {\n        let mut grid = setup_grid_with_const_operation(5, 5, Operation::Add);\n\n        // Adding constants 10 + 5\n        let result = add(\u0026mut grid, 3, 3);\n        assert_eq!(result, Some(15));\n    }\n\n    #[test]\n    fn test_add_with_mixed() {\n        let mut grid = setup_grid_with_mixed_operation(5, 5, Operation::Add);\n\n        // Adding cell(1,1) = 6 and const 5\n        let result = add(\u0026mut grid, 3, 3);\n        assert_eq!(result, Some(11));\n    }\n\n    #[test]\n    fn test_add_invalid_cell() {\n        let mut grid = setup_grid_with_binary_operation(5, 5, Operation::Add);\n\n        // Make one of the cells invalid\n        let invalid_node = grid.get_node(1, 1);\n        invalid_node.valid = false;\n\n        // Should return None if one of the cells is invalid\n        let result = add(\u0026mut grid, 3, 3);\n        assert_eq!(result, None);\n    }\n\n    #[test]\n    fn test_add_invalid_function() {\n        let mut grid = setup_test_grid(5, 5);\n\n        // Set up a cell with an invalid function structure\n        let mut function_node = Node::new(0);\n        function_node.function = Some(Value::Cell(1, 1));\n        grid.set_node(3, 3, function_node);\n\n        // With an invalid function structure, should return None\n        let result = add(\u0026mut grid, 3, 3);\n        assert_eq!(result, None);\n    }\n\n    #[test]\n    fn test_sub_normal() {\n        let mut grid = setup_grid_with_binary_operation(5, 5, Operation::Sub);\n\n        // Subtracting cell(2,2) = 12 from cell(1,1) = 6\n        // The correct result is -6, not 6, as the subtraction appears to be first - second\n        let result = sub(\u0026mut grid, 3, 3);\n        assert_eq!(result, Some(-6));\n    }\n\n    #[test]\n    fn test_sub_with_const() {\n        let mut grid = setup_grid_with_const_operation(5, 5, Operation::Sub);\n\n        // Subtracting constants 10 - 5\n        let result = sub(\u0026mut grid, 3, 3);\n        assert_eq!(result, Some(5));\n    }\n\n    #[test]\n    fn test_sub_with_mixed() {\n        let mut grid = setup_grid_with_mixed_operation(5, 5, Operation::Sub);\n\n        // Subtracting cell(1,1) = 6 and const 5\n        let result = sub(\u0026mut grid, 3, 3);\n        assert_eq!(result, Some(1));\n    }\n\n    #[test]\n    fn test_sub_invalid_cell() {\n        let mut grid = setup_grid_with_binary_operation(5, 5, Operation::Sub);\n\n        // Make one of the cells invalid\n        let invalid_node = grid.get_node(2, 2);\n        invalid_node.valid = false;\n\n        // Should return None if one of the cells is invalid\n        let result = sub(\u0026mut grid, 3, 3);\n        assert_eq!(result, None);\n    }\n\n    #[test]\n    fn test_mul_normal() {\n        let mut grid = setup_grid_with_binary_operation(5, 5, Operation::Mul);\n\n        // Multiplying cell(1,1) = 6 and cell(2,2) = 12\n        let result = mul(\u0026mut grid, 3, 3);\n        assert_eq!(result, Some(72));\n    }\n\n    #[test]\n    fn test_mul_with_const() {\n        let mut grid = setup_grid_with_const_operation(5, 5, Operation::Mul);\n\n        // Multiplying constants 10 * 5\n        let result = mul(\u0026mut grid, 3, 3);\n        assert_eq!(result, Some(50));\n    }\n\n    #[test]\n    fn test_mul_with_mixed() {\n        let mut grid = setup_grid_with_mixed_operation(5, 5, Operation::Mul);\n\n        // Multiplying cell(1,1) = 6 and const 5\n        let result = mul(\u0026mut grid, 3, 3);\n        assert_eq!(result, Some(30));\n    }\n\n    #[test]\n    fn test_mul_invalid_cell() {\n        let mut grid = setup_grid_with_binary_operation(5, 5, Operation::Mul);\n\n        // Make one of the cells invalid\n        let invalid_node = grid.get_node(1, 1);\n        invalid_node.valid = false;\n\n        // Should return None if one of the cells is invalid\n        let result = mul(\u0026mut grid, 3, 3);\n        assert_eq!(result, None);\n    }\n\n    #[test]\n    fn test_div_normal() {\n        let mut grid = setup_grid_with_binary_operation(5, 5, Operation::Div);\n\n        // Dividing cell(1,1) = 6 by cell(2,2) = 12\n        let result = div(\u0026mut grid, 3, 3);\n        assert_eq!(result, Some(0)); // Integer division\n    }\n\n    #[test]\n    fn test_div_with_const() {\n        let mut grid = setup_grid_with_const_operation(5, 5, Operation::Div);\n\n        // Dividing constants 10 / 5\n        let result = div(\u0026mut grid, 3, 3);\n        assert_eq!(result, Some(2));\n    }\n\n    #[test]\n    fn test_div_with_mixed() {\n        let mut grid = setup_grid_with_mixed_operation(5, 5, Operation::Div);\n\n        // Dividing cell(1,1) = 6 by const 5\n        let result = div(\u0026mut grid, 3, 3);\n        assert_eq!(result, Some(1)); // Integer division\n    }\n\n    #[test]\n    fn test_div_by_zero() {\n        let mut grid = setup_test_grid(5, 5);\n\n        // Set up a cell to divide by zero\n        let mut function_node = Node::new(0);\n        function_node.function = Some(Value::Oper(\n            Some(Box::new(Value::Cell(1, 1))),\n            Some(Box::new(Value::Const(0))),\n            Operation::Div,\n        ));\n        grid.set_node(3, 3, function_node);\n\n        // Should return None for division by zero\n        let result = div(\u0026mut grid, 3, 3);\n        assert_eq!(result, None);\n    }\n\n    #[test]\n    fn test_div_invalid_cell() {\n        let mut grid = setup_grid_with_binary_operation(5, 5, Operation::Div);\n\n        // Make one of the cells invalid\n        let invalid_node = grid.get_node(2, 2);\n        invalid_node.valid = false;\n\n        // Should return None if one of the cells is invalid\n        let result = div(\u0026mut grid, 3, 3);\n        assert_eq!(result, None);\n    }\n\n    #[test]\n    fn test_slp_normal() {\n        let mut grid = setup_test_grid(5, 5);\n\n        // Set up a cell with a sleep operation\n        let mut function_node = Node::new(0);\n        function_node.function = Some(Value::Oper(\n            Some(Box::new(Value::Const(0))), // Sleep for 0 seconds for test speed\n            Some(Box::new(Value::Const(0))),\n            Operation::Slp,\n        ));\n        grid.set_node(3, 3, function_node);\n\n        // Should return the sleep time\n        let result = slp(\u0026mut grid, 3, 3);\n        assert_eq!(result, Some(0));\n    }\n\n    #[test]\n    fn test_slp_with_cell() {\n        let mut grid = setup_test_grid(5, 5);\n\n        // Set up a cell with a sleep operation\n        let mut function_node = Node::new(0);\n        function_node.function = Some(Value::Oper(\n            Some(Box::new(Value::Cell(0, 0))), // Sleep for value of cell(0,0) = 0\n            Some(Box::new(Value::Const(0))),\n            Operation::Slp,\n        ));\n        grid.set_node(3, 3, function_node);\n\n        // Should return the sleep time\n        let result = slp(\u0026mut grid, 3, 3);\n        assert_eq!(result, Some(0));\n    }\n\n    #[test]\n    fn test_slp_invalid_cell() {\n        let mut grid = setup_test_grid(5, 5);\n\n        // Set up a cell with a sleep operation\n        let mut function_node = Node::new(0);\n        function_node.function = Some(Value::Oper(\n            Some(Box::new(Value::Cell(0, 0))),\n            Some(Box::new(Value::Const(0))),\n            Operation::Slp,\n        ));\n        grid.set_node(3, 3, function_node);\n\n        // Make the cell invalid\n        let invalid_node = grid.get_node(0, 0);\n        invalid_node.valid = false;\n\n        // Should return None if the cell is invalid\n        let result = slp(\u0026mut grid, 3, 3);\n        assert_eq!(result, None);\n    }\n\n    #[test]\n    fn test_cons_normal() {\n        let mut grid = setup_test_grid(5, 5);\n\n        // Set up a cell with a cons operation\n        let mut function_node = Node::new(0);\n        function_node.function = Some(Value::Oper(\n            Some(Box::new(Value::Const(42))),\n            Some(Box::new(Value::Const(0))),\n            Operation::Cons,\n        ));\n        grid.set_node(3, 3, function_node);\n\n        // Should return the constant value\n        let result = cons(\u0026mut grid, 3, 3);\n        assert_eq!(result, Some(42));\n    }\n\n    #[test]\n    fn test_cons_with_cell() {\n        let mut grid = setup_test_grid(5, 5);\n\n        // Set up a cell with a cons operation\n        let mut function_node = Node::new(0);\n        function_node.function = Some(Value::Oper(\n            Some(Box::new(Value::Cell(1, 1))), // Get value of cell(1,1) = 6\n            Some(Box::new(Value::Const(0))),\n            Operation::Cons,\n        ));\n        grid.set_node(3, 3, function_node);\n\n        // Should return the value of the referenced cell\n        let result = cons(\u0026mut grid, 3, 3);\n        assert_eq!(result, Some(6));\n    }\n\n    #[test]\n    fn test_cons_invalid_cell() {\n        let mut grid = setup_test_grid(5, 5);\n\n        // Set up a cell with a cons operation\n        let mut function_node = Node::new(0);\n        function_node.function = Some(Value::Oper(\n            Some(Box::new(Value::Cell(1, 1))),\n            Some(Box::new(Value::Const(0))),\n            Operation::Cons,\n        ));\n        grid.set_node(3, 3, function_node);\n\n        // Make the cell invalid\n        let invalid_node = grid.get_node(1, 1);\n        invalid_node.valid = false;\n\n        // Should return None if the cell is invalid\n        let result = cons(\u0026mut grid, 3, 3);\n        assert_eq!(result, None);\n    }\n\n    #[test]\n    fn test_invalid_function_structures() {\n        let mut grid = setup_test_grid(5, 5);\n\n        // Missing first operand\n        let mut function_node = Node::new(0);\n        function_node.function = Some(Value::Oper(\n            None,\n            Some(Box::new(Value::Const(5))),\n            Operation::Add,\n        ));\n        grid.set_node(3, 3, function_node);\n\n        assert_eq!(add(\u0026mut grid, 3, 3), None);\n\n        // Missing second operand\n        let mut function_node = Node::new(0);\n        function_node.function = Some(Value::Oper(\n            Some(Box::new(Value::Const(5))),\n            None,\n            Operation::Add,\n        ));\n        grid.set_node(3, 3, function_node);\n\n        assert_eq!(add(\u0026mut grid, 3, 3), None);\n\n        // Both operands missing\n        let mut function_node = Node::new(0);\n        function_node.function = Some(Value::Oper(None, None, Operation::Add));\n        grid.set_node(3, 3, function_node);\n\n        assert_eq!(add(\u0026mut grid, 3, 3), None);\n    }\n\n    #[test]\n    fn test_nested_value_types() {\n        let mut grid = setup_test_grid(5, 5);\n\n        // Set up a cell with a nested operation\n        let mut function_node = Node::new(0);\n        function_node.function = Some(Value::Oper(\n            Some(Box::new(Value::Oper(\n                Some(Box::new(Value::Const(5))),\n                Some(Box::new(Value::Const(5))),\n                Operation::Add,\n            ))),\n            Some(Box::new(Value::Const(5))),\n            Operation::Add,\n        ));\n        grid.set_node(3, 3, function_node);\n\n        // Should return None for nested operations\n        assert_eq!(add(\u0026mut grid, 3, 3), None);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","yuvikachaudhary","Desktop","Semester 4","COP290","spreadsheet_rust","tests","functions_terminal.rs"],"content":"use project::terminal::functions::*;\nuse project::terminal::graph::Node;\nuse project::terminal::types::Coordinates;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // Helper function to create a test grid\n    fn setup_test_grid() -\u003e Vec\u003cVec\u003cNode\u003e\u003e {\n        let mut grid = vec![\n            vec![Node::default(); 4], // Row 0 (placeholder)\n            vec![Node::default(); 4], // Row 1\n            vec![Node::default(); 4], // Row 2\n            vec![Node::default(); 4], // Row 3\n        ];\n\n        // Set up node positions\n        for i in 0..4 {\n            for j in 0..4 {\n                grid[i][j].position = Coordinates {\n                    row: i as i32,\n                    col: j as i32,\n                };\n                grid[i][j].valid = true;\n            }\n        }\n\n        // Set some test values\n        // Row 1: [10, 20, 30, 40]\n        // Row 2: [5, 15, 25, 35]\n        // Row 3: [2, 8, 18, 32]\n        grid[1][1].node_value = 10;\n        grid[1][2].node_value = 20;\n        grid[1][3].node_value = 30;\n        grid[2][1].node_value = 5;\n        grid[2][2].node_value = 15;\n        grid[2][3].node_value = 25;\n        grid[3][1].node_value = 2;\n        grid[3][2].node_value = 8;\n        grid[3][3].node_value = 18;\n\n        grid\n    }\n\n    #[test]\n    fn test_sum_function() {\n        let grid = setup_test_grid();\n\n        // Test case 1: Sum of a single cell\n        let result = sum_function(\n            Coordinates { row: 1, col: 1 },\n            Coordinates { row: 1, col: 1 },\n            \u0026grid,\n        );\n        assert_eq!(result, Some(10));\n\n        // Test case 2: Sum of a row\n        let result = sum_function(\n            Coordinates { row: 1, col: 1 },\n            Coordinates { row: 1, col: 3 },\n            \u0026grid,\n        );\n        assert_eq!(result, Some(60)); // 10+20+30\n\n        // Test case 3: Sum of a column\n        let result = sum_function(\n            Coordinates { row: 1, col: 1 },\n            Coordinates { row: 3, col: 1 },\n            \u0026grid,\n        );\n        assert_eq!(result, Some(17)); // 10+5+2\n\n        // Test case 4: Sum of a rectangle\n        let result = sum_function(\n            Coordinates { row: 1, col: 1 },\n            Coordinates { row: 2, col: 2 },\n            \u0026grid,\n        );\n        assert_eq!(result, Some(50)); // 10+20+5+15\n    }\n\n    #[test]\n    fn test_avg_function() {\n        let grid = setup_test_grid();\n\n        // Test case 1: Average of a single cell\n        let result = avg_function(\n            Coordinates { row: 1, col: 1 },\n            Coordinates { row: 1, col: 1 },\n            \u0026grid,\n        );\n        assert_eq!(result, Some(10));\n\n        // Test case 2: Average of a row\n        let result = avg_function(\n            Coordinates { row: 1, col: 1 },\n            Coordinates { row: 1, col: 3 },\n            \u0026grid,\n        );\n        assert_eq!(result, Some(20)); // (10+20+30)/3\n\n        // Test case 3: Average of a rectangle\n        let result = avg_function(\n            Coordinates { row: 1, col: 1 },\n            Coordinates { row: 2, col: 2 },\n            \u0026grid,\n        );\n        assert_eq!(result, Some(12)); // (10+20+5+15)/4 = 50/4 = 12.5 -\u003e 12 (integer division)\n    }\n\n    #[test]\n    fn test_min_function() {\n        let grid = setup_test_grid();\n\n        // Test case 1: Min of a single cell\n        let result = min_function(\n            Coordinates { row: 1, col: 1 },\n            Coordinates { row: 1, col: 1 },\n            \u0026grid,\n        );\n        assert_eq!(result, Some(10));\n\n        // Test case 2: Min of a row\n        let result = min_function(\n            Coordinates { row: 1, col: 1 },\n            Coordinates { row: 1, col: 3 },\n            \u0026grid,\n        );\n        assert_eq!(result, Some(10)); // min(10, 20, 30)\n\n        // Test case 3: Min of a rectangle\n        let result = min_function(\n            Coordinates { row: 1, col: 1 },\n            Coordinates { row: 3, col: 3 },\n            \u0026grid,\n        );\n        assert_eq!(result, Some(2)); // min(10, 20, 30, 5, 15, 25, 2, 8, 18)\n    }\n\n    #[test]\n    fn test_max_function() {\n        let grid = setup_test_grid();\n\n        // Test case 1: Max of a single cell\n        let result = max_function(\n            Coordinates { row: 1, col: 1 },\n            Coordinates { row: 1, col: 1 },\n            \u0026grid,\n        );\n        assert_eq!(result, Some(10));\n\n        // Test case 2: Max of a row\n        let result = max_function(\n            Coordinates { row: 1, col: 1 },\n            Coordinates { row: 1, col: 3 },\n            \u0026grid,\n        );\n        assert_eq!(result, Some(30)); // max(10, 20, 30)\n\n        // Test case 3: Max of a rectangle\n        let result = max_function(\n            Coordinates { row: 1, col: 1 },\n            Coordinates { row: 3, col: 3 },\n            \u0026grid,\n        );\n        assert_eq!(result, Some(30)); // max(10, 20, 30, 5, 15, 25, 2, 8, 18)\n    }\n\n    #[test]\n    fn test_stdev_function() {\n        let grid = setup_test_grid();\n\n        // Test case 1: STDEV of a single cell (should be 0)\n        let result = stdev_function(\n            Coordinates { row: 1, col: 1 },\n            Coordinates { row: 1, col: 1 },\n            \u0026grid,\n        );\n        assert_eq!(result, Some(0));\n\n        // Test case 2: STDEV of a row\n        // Values: 10, 20, 30\n        // Mean: 20\n        // Variance: ((10-20)² + (20-20)² + (30-20)²)/3 = (100 + 0 + 100)/3 = 66.67\n        // STDEV: sqrt(66.67) ≈ 8.16 -\u003e 8 (with integer rounding)\n        let result = stdev_function(\n            Coordinates { row: 1, col: 1 },\n            Coordinates { row: 1, col: 3 },\n            \u0026grid,\n        );\n        assert_eq!(result, Some(8));\n\n        // Test case 3: STDEV of a 2x2 square\n        // Values: 10, 20, 5, 15\n        // Mean: 12.5\n        // Variance: ((10-12.5)² + (20-12.5)² + (5-12.5)² + (15-12.5)²)/4 = 37.5\n        // STDEV: sqrt(37.5) ≈ 6.12 -\u003e 6 (with integer rounding)\n        let result = stdev_function(\n            Coordinates { row: 1, col: 1 },\n            Coordinates { row: 2, col: 2 },\n            \u0026grid,\n        );\n        assert_eq!(result, Some(6));\n    }\n\n    #[test]\n    fn test_invalid_cells() {\n        let mut grid = setup_test_grid();\n\n        // Mark one cell as invalid\n        grid[2][2].valid = false;\n\n        // All range functions should return None if any cell is invalid\n        let coords_start = Coordinates { row: 1, col: 1 };\n        let coords_end = Coordinates { row: 2, col: 2 };\n\n        assert_eq!(sum_function(coords_start, coords_end, \u0026grid), None);\n        assert_eq!(avg_function(coords_start, coords_end, \u0026grid), None);\n        assert_eq!(min_function(coords_start, coords_end, \u0026grid), None);\n        assert_eq!(max_function(coords_start, coords_end, \u0026grid), None);\n        assert_eq!(stdev_function(coords_start, coords_end, \u0026grid), None);\n    }\n\n    #[test]\n    fn test_empty_range() {\n        // Create an empty grid (all cells have 0 value but are valid)\n        let grid = vec![vec![Node::default(); 4]; 4];\n\n        // Calculate average of empty range - should be None as count is 0\n        let result = avg_function(\n            Coordinates { row: 1, col: 1 },\n            Coordinates { row: 0, col: 0 }, // invalid range (end before start)\n            \u0026grid,\n        );\n        assert_eq!(result, None);\n\n        // Sum of empty range should be Some(0)\n        let result = sum_function(\n            Coordinates { row: 1, col: 1 },\n            Coordinates { row: 0, col: 0 }, // invalid range (end before start)\n            \u0026grid,\n        );\n        assert_eq!(result, Some(0));\n    }\n\n    #[test]\n    fn test_is_arithmetic() {\n        assert!(is_arithmetic(Operation::Add));\n        assert!(is_arithmetic(Operation::Sub));\n        assert!(is_arithmetic(Operation::Mul));\n        assert!(is_arithmetic(Operation::Div));\n\n        assert!(!is_arithmetic(Operation::Sum));\n        assert!(!is_arithmetic(Operation::Avg));\n        assert!(!is_arithmetic(Operation::Min));\n        assert!(!is_arithmetic(Operation::Max));\n        assert!(!is_arithmetic(Operation::Std));\n        assert!(!is_arithmetic(Operation::Slp));\n        assert!(!is_arithmetic(Operation::Cons));\n    }\n\n    #[test]\n    fn test_operation_equality() {\n        // Test that operations can be compared correctly\n        assert_eq!(Operation::Add, Operation::Add);\n        assert_ne!(Operation::Add, Operation::Sub);\n        assert_ne!(Operation::Sum, Operation::Avg);\n    }\n\n    #[test]\n    fn test_sum_empty_range() {\n        let grid = setup_test_grid();\n\n        // Test summing 0 cells (empty range)\n        let result = sum_function(\n            Coordinates { row: 3, col: 3 }, // Out of grid bounds\n            Coordinates { row: 3, col: 3 },\n            \u0026grid,\n        );\n        assert_eq!(result, Some(18)); // only that grid cell is present whose value is 18\n    }\n\n    #[test]\n    fn test_stdev_edge_cases() {\n        let _grid = setup_test_grid();\n\n        // Test STDEV of a range with identical values (should be 0)\n        let mut identical_grid = setup_test_grid();\n        for i in 1..3 {\n            for j in 1..3 {\n                identical_grid[i][j].node_value = 10;\n            }\n        }\n\n        let result = stdev_function(\n            Coordinates { row: 1, col: 1 },\n            Coordinates { row: 2, col: 2 },\n            \u0026identical_grid,\n        );\n        assert_eq!(result, Some(0));\n\n        // Test with extreme values that might cause integer overflow\n        let mut extreme_grid = setup_test_grid();\n        extreme_grid[1][1].node_value = i32::MAX / 2;\n        extreme_grid[1][2].node_value = i32::MIN / 2;\n\n        // This test mainly checks that the function doesn't panic\n        let result = stdev_function(\n            Coordinates { row: 1, col: 1 },\n            Coordinates { row: 1, col: 2 },\n            \u0026extreme_grid,\n        );\n        assert!(result.is_some());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","yuvikachaudhary","Desktop","Semester 4","COP290","spreadsheet_rust","tests","graph_ext.rs"],"content":"use project::extension::backend::backend::*;\nuse project::extension::backend::graph::*;\nuse project::extension::common::{Operation, Value};\n\n#[cfg(test)]\nmod node_tests {\n    use super::*;\n\n    // Helper function to create a test grid with predefined size\n    fn create_test_grid(rows: usize, cols: usize) -\u003e Grid {\n        let mut grid = Grid::new(rows + 1, cols + 1);\n        // Initialize with default nodes\n        for r in 1..=rows {\n            for c in 1..=cols {\n                grid.set_node(r, c, Node::new(0));\n            }\n        }\n        grid\n    }\n\n    #[test]\n    fn test_node_new() {\n        let node = Node::new(42);\n        assert_eq!(node.get_node_value(), Some(42));\n        assert!(node.dependents.is_empty());\n        assert_eq!(node.function, None);\n        assert!(!node.visited);\n        assert!(node.valid);\n    }\n\n    #[test]\n    fn test_get_node_value() {\n        // Test valid node\n        let mut node = Node::new(42);\n        assert_eq!(node.get_node_value(), Some(42));\n\n        // Test invalid node\n        node.valid = false;\n        assert_eq!(node.get_node_value(), None);\n    }\n\n    #[test]\n    fn test_remove_dep() {\n        let mut node = Node::new(42);\n        let cell1 = Value::Cell(1, 1);\n        let cell2 = Value::Cell(2, 2);\n\n        // Add dependencies\n        node.dependents.push(cell1.clone());\n        node.dependents.push(cell2.clone());\n        assert_eq!(node.dependents.len(), 2);\n\n        // Remove one dependency\n        node.remove_dep(cell1);\n        assert_eq!(node.dependents.len(), 1);\n        assert_eq!(node.dependents[0], cell2);\n\n        // Try to remove non-existent dependency (should do nothing)\n        node.remove_dep(Value::Cell(3, 3));\n        assert_eq!(node.dependents.len(), 1);\n    }\n\n    #[test]\n    fn test_add_dep() {\n        let mut node = Node::new(42);\n        let cell1 = Value::Cell(1, 1);\n\n        // Add dependency\n        node.add_dep(cell1.clone());\n        assert_eq!(node.dependents.len(), 1);\n        assert_eq!(node.dependents[0], cell1);\n\n        // Try to add same dependency again (should not duplicate)\n        node.add_dep(cell1.clone());\n        assert_eq!(node.dependents.len(), 1);\n\n        // Add another dependency\n        let cell2 = Value::Cell(2, 2);\n        node.add_dep(cell2.clone());\n        assert_eq!(node.dependents.len(), 2);\n        assert!(node.dependents.contains(\u0026cell1));\n        assert!(node.dependents.contains(\u0026cell2));\n    }\n\n    #[test]\n    fn test_set_dependents() {\n        let mut node = Node::new(42);\n\n        // Initial state\n        assert!(node.dependents.is_empty());\n\n        // Set dependencies\n        let deps = vec![Value::Cell(1, 1), Value::Cell(2, 2)];\n        node.set_dependents(deps.clone());\n        assert_eq!(node.dependents, deps);\n\n        // Set to empty\n        node.set_dependents(vec![]);\n        assert!(node.dependents.is_empty());\n    }\n\n    #[test]\n    fn test_break_edges_sum_operation() {\n        let mut grid = create_test_grid(5, 5);\n\n        // Set up a SUM operation: C3 = SUM(A1:B2)\n        let target = Value::Cell(3, 3);\n        let func = Some(Value::Oper(\n            Some(Box::new(Value::Cell(1, 1))),\n            Some(Box::new(Value::Cell(2, 2))),\n            Operation::Sum,\n        ));\n\n        // Add dependencies first\n        add_edges(\u0026mut grid, target.clone(), func.clone(), true);\n\n        // Verify dependencies were added\n        assert!(grid.get_node(1, 1).dependents.contains(\u0026target));\n        assert!(grid.get_node(1, 2).dependents.contains(\u0026target));\n        assert!(grid.get_node(2, 1).dependents.contains(\u0026target));\n        assert!(grid.get_node(2, 2).dependents.contains(\u0026target));\n\n        // Break the edges\n        break_edges(\u0026mut grid, target.clone(), func.clone(), false);\n\n        // Verify dependencies were removed\n        assert!(!grid.get_node(1, 1).dependents.contains(\u0026target));\n        assert!(!grid.get_node(1, 2).dependents.contains(\u0026target));\n        assert!(!grid.get_node(2, 1).dependents.contains(\u0026target));\n        assert!(!grid.get_node(2, 2).dependents.contains(\u0026target));\n    }\n\n    #[test]\n    fn test_break_edges_binary_operation() {\n        let mut grid = create_test_grid(5, 5);\n\n        // Set up a binary operation: C3 = A1 + B2\n        let target = Value::Cell(3, 3);\n        let func = Some(Value::Oper(\n            Some(Box::new(Value::Cell(1, 1))),\n            Some(Box::new(Value::Cell(2, 2))),\n            Operation::Add,\n        ));\n\n        // Add dependencies first\n        add_edges(\u0026mut grid, target.clone(), func.clone(), true);\n\n        // Verify dependencies were added\n        assert!(grid.get_node(1, 1).dependents.contains(\u0026target));\n        assert!(grid.get_node(2, 2).dependents.contains(\u0026target));\n\n        // Break the edges\n        break_edges(\u0026mut grid, target.clone(), func.clone(), false);\n\n        // Verify dependencies were removed\n        assert!(!grid.get_node(1, 1).dependents.contains(\u0026target));\n        assert!(!grid.get_node(2, 2).dependents.contains(\u0026target));\n    }\n\n    #[test]\n    fn test_add_edges_sum_operation() {\n        let mut grid = create_test_grid(5, 5);\n\n        // Set up a SUM operation: C3 = SUM(A1:B2)\n        let target = Value::Cell(3, 3);\n        let func = Some(Value::Oper(\n            Some(Box::new(Value::Cell(1, 1))),\n            Some(Box::new(Value::Cell(2, 2))),\n            Operation::Sum,\n        ));\n\n        // Add the edges\n        add_edges(\u0026mut grid, target.clone(), func.clone(), true);\n\n        // Verify all cells in the range have the target as a dependent\n        assert!(grid.get_node(1, 1).dependents.contains(\u0026target));\n        assert!(grid.get_node(1, 2).dependents.contains(\u0026target));\n        assert!(grid.get_node(2, 1).dependents.contains(\u0026target));\n        assert!(grid.get_node(2, 2).dependents.contains(\u0026target));\n    }\n\n    #[test]\n    fn test_add_edges_binary_operation() {\n        let mut grid = create_test_grid(5, 5);\n\n        // Set up a binary operation: C3 = A1 + B2\n        let target = Value::Cell(3, 3);\n        let func = Some(Value::Oper(\n            Some(Box::new(Value::Cell(1, 1))),\n            Some(Box::new(Value::Cell(2, 2))),\n            Operation::Add,\n        ));\n\n        // Add the edges\n        add_edges(\u0026mut grid, target.clone(), func.clone(), true);\n\n        // Verify both operand cells have the target as a dependent\n        assert!(grid.get_node(1, 1).dependents.contains(\u0026target));\n        assert!(grid.get_node(2, 2).dependents.contains(\u0026target));\n    }\n\n    #[test]\n    fn test_update_edges() {\n        let mut grid = create_test_grid(5, 5);\n\n        // Set up an initial operation: C3 = A1 + B2\n        let target = Value::Cell(3, 3);\n        let func1 = Some(Value::Oper(\n            Some(Box::new(Value::Cell(1, 1))),\n            Some(Box::new(Value::Cell(2, 2))),\n            Operation::Add,\n        ));\n\n        // Store the function in the grid\n        grid.get_node(3, 3).function = func1.clone();\n\n        // Add initial dependencies\n        update_edges(\u0026mut grid, target.clone(), func1.clone(), true);\n\n        // Verify initial dependencies\n        assert!(grid.get_node(1, 1).dependents.contains(\u0026target));\n        assert!(grid.get_node(2, 2).dependents.contains(\u0026target));\n\n        // Change the operation: C3 = D4 * E5\n        let func2 = Some(Value::Oper(\n            Some(Box::new(Value::Cell(4, 4))),\n            Some(Box::new(Value::Cell(5, 5))),\n            Operation::Mul,\n        ));\n\n        // Update the edges with new function\n        update_edges(\u0026mut grid, target.clone(), func2.clone(), true);\n\n        // Verify old dependencies are removed\n        assert!(!grid.get_node(1, 1).dependents.contains(\u0026target));\n        assert!(!grid.get_node(2, 2).dependents.contains(\u0026target));\n\n        // Verify new dependencies are added\n        assert!(grid.get_node(4, 4).dependents.contains(\u0026target));\n        assert!(grid.get_node(5, 5).dependents.contains(\u0026target));\n    }\n\n    #[test]\n    fn test_has_cycle_no_cycle() {\n        let mut grid = create_test_grid(5, 5);\n\n        // Set up a dependency chain: A1 -\u003e B2 -\u003e C3\n        let a1 = Value::Cell(1, 1);\n        let b2 = Value::Cell(2, 2);\n        let c3 = Value::Cell(3, 3);\n\n        grid.get_node(1, 1).add_dep(b2.clone());\n        grid.get_node(2, 2).add_dep(c3.clone());\n\n        // There should be no cycle\n        assert!(!has_cycle(\u0026mut grid, a1.clone()));\n        assert!(!has_cycle(\u0026mut grid, b2.clone()));\n        assert!(!has_cycle(\u0026mut grid, c3.clone()));\n\n        // Verify visited flags were reset\n        assert!(!grid.get_node(1, 1).visited);\n        assert!(!grid.get_node(2, 2).visited);\n        assert!(!grid.get_node(3, 3).visited);\n    }\n\n    #[test]\n    fn test_has_cycle_with_cycle() {\n        let mut grid = create_test_grid(5, 5);\n\n        // Set up a cyclic dependency: A1 -\u003e B2 -\u003e C3 -\u003e A1\n        let a1 = Value::Cell(1, 1);\n        let b2 = Value::Cell(2, 2);\n        let c3 = Value::Cell(3, 3);\n\n        grid.get_node(1, 1).add_dep(b2.clone());\n        grid.get_node(2, 2).add_dep(c3.clone());\n        grid.get_node(3, 3).add_dep(a1.clone());\n\n        // There should be a cycle detected\n        assert!(has_cycle(\u0026mut grid, a1.clone()));\n\n        // Verify visited flags were reset\n        assert!(!grid.get_node(1, 1).visited);\n        assert!(!grid.get_node(2, 2).visited);\n        assert!(!grid.get_node(3, 3).visited);\n    }\n\n    #[test]\n    fn test_reset_visited() {\n        let mut grid = create_test_grid(5, 5);\n\n        // Set up visited flags\n        grid.get_node(1, 1).visited = true;\n        grid.get_node(2, 2).visited = true;\n        grid.get_node(3, 3).visited = true;\n\n        // Set up a dependency chain: A1 -\u003e B2 -\u003e C3\n        let a1 = Value::Cell(1, 1);\n        let b2 = Value::Cell(2, 2);\n        let c3 = Value::Cell(3, 3);\n\n        grid.get_node(1, 1).add_dep(b2.clone());\n        grid.get_node(2, 2).add_dep(c3.clone());\n\n        // Reset visited flags\n        reset_visited(\u0026mut grid, a1.clone());\n\n        // Verify visited flags were reset\n        assert!(!grid.get_node(1, 1).visited);\n        assert!(!grid.get_node(2, 2).visited);\n        assert!(!grid.get_node(3, 3).visited);\n    }\n\n    #[test]\n    fn test_topological_sort() {\n        let mut grid = create_test_grid(5, 5);\n\n        // Set up a dependency chain: A1 -\u003e B2 -\u003e C3\n        let a1 = Value::Cell(1, 1);\n        let b2 = Value::Cell(2, 2);\n        let c3 = Value::Cell(3, 3);\n\n        grid.get_node(1, 1).add_dep(b2.clone());\n        grid.get_node(2, 2).add_dep(c3.clone());\n\n        let mut stack = Vec::new();\n        topological_sort(\u0026mut grid, a1.clone(), \u0026mut stack);\n\n        // The stack should contain a valid topological sort (reverse order of DFS finishing times)\n        // Expected order: [A1, B2, C3]\n        assert_eq!(stack.len(), 3);\n        assert_eq!(stack[2], a1);\n        assert_eq!(stack[1], b2);\n        assert_eq!(stack[0], c3);\n    }\n\n    #[test]\n    fn test_get_sequence() {\n        let mut grid = create_test_grid(5, 5);\n\n        // Set up a dependency graph: A1 -\u003e B2 -\u003e D4, A1 -\u003e C3\n        let a1 = Value::Cell(1, 1);\n        let b2 = Value::Cell(2, 2);\n        let c3 = Value::Cell(3, 3);\n        let d4 = Value::Cell(4, 4);\n\n        grid.get_node(1, 1).add_dep(b2.clone());\n        grid.get_node(1, 1).add_dep(c3.clone());\n        grid.get_node(2, 2).add_dep(d4.clone());\n\n        // Get the topological sequence starting from A1\n        let sequence = get_sequence(\u0026mut grid, a1.clone());\n\n        // The sequence should be in evaluation order (opposite of topological sort output)\n        // One valid order would be: [C3, D4, B2, A1]\n        assert_eq!(sequence.len(), 4);\n\n        // Verify A1 is last in the sequence (must be evaluated last)\n        assert_eq!(sequence[0], a1);\n\n        // B2 must come after D4\n        let b2_pos = sequence.iter().position(|v| v == \u0026b2).unwrap();\n        let d4_pos = sequence.iter().position(|v| v == \u0026d4).unwrap();\n        assert!(b2_pos \u003c d4_pos);\n\n        // Verify visited flags were reset\n        assert!(!grid.get_node(1, 1).visited);\n        assert!(!grid.get_node(2, 2).visited);\n        assert!(!grid.get_node(3, 3).visited);\n        assert!(!grid.get_node(4, 4).visited);\n    }\n\n    #[test]\n    fn test_integration_dependency_management() {\n        let mut grid = create_test_grid(5, 5);\n\n        // Test scenario: C3 initially depends on A1 and B2, then we change it to depend on D4\n        let a1 = Value::Cell(1, 1);\n        let b2 = Value::Cell(2, 2);\n        let c3 = Value::Cell(3, 3);\n        let d4 = Value::Cell(4, 4);\n\n        // Initial formula: C3 = A1 + B2\n        let func1 = Some(Value::Oper(\n            Some(Box::new(a1.clone())),\n            Some(Box::new(b2.clone())),\n            Operation::Add,\n        ));\n\n        // Update C3 to use this formula\n        grid.get_node(3, 3).function = func1.clone();\n        update_edges(\u0026mut grid, c3.clone(), func1.clone(), true);\n\n        // Verify dependencies\n        assert!(grid.get_node(1, 1).dependents.contains(\u0026c3));\n        assert!(grid.get_node(2, 2).dependents.contains(\u0026c3));\n\n        // Check for cycles (should be none)\n        assert!(!has_cycle(\u0026mut grid, c3.clone()));\n\n        // Get evaluation sequence\n        let sequence = get_sequence(\u0026mut grid, c3.clone());\n        assert_eq!(sequence.len(), 1);\n        assert_eq!(sequence[0], c3);\n\n        // Now change formula: C3 = D4 * 5\n        let func2 = Some(Value::Oper(\n            Some(Box::new(d4.clone())),\n            Some(Box::new(Value::Const(5))),\n            Operation::Mul,\n        ));\n\n        // Update C3 with new formula\n        grid.get_node(3, 3).function = func2.clone();\n        update_edges(\u0026mut grid, c3.clone(), func2.clone(), true);\n\n        // Verify old dependencies are removed\n        assert!(grid.get_node(1, 1).dependents.contains(\u0026c3));\n        assert!(grid.get_node(2, 2).dependents.contains(\u0026c3));\n\n        // Verify new dependency is added\n        assert!(grid.get_node(4, 4).dependents.contains(\u0026c3));\n\n        // Check for cycles (should be none)\n        assert!(!has_cycle(\u0026mut grid, c3.clone()));\n\n        // Try to create a cycle: D4 = C3 (should fail)\n        let cycle_func = Some(Value::Oper(\n            Some(Box::new(c3.clone())),\n            Some(Box::new(Value::Const(2))),\n            Operation::Mul,\n        ));\n\n        // Update D4 with formula that would create a cycle\n        grid.get_node(4, 4).function = cycle_func.clone();\n        add_edges(\u0026mut grid, d4.clone(), cycle_func.clone(), true);\n\n        // Verify cycle is detected\n        assert!(has_cycle(\u0026mut grid, d4.clone()));\n\n        // Break the cycle\n        break_edges(\u0026mut grid, d4.clone(), cycle_func.clone(), true);\n\n        // Verify cycle is gone\n        assert!(!has_cycle(\u0026mut grid, d4.clone()));\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","yuvikachaudhary","Desktop","Semester 4","COP290","spreadsheet_rust","tests","graph_terminal.rs"],"content":"use project::terminal::functions::Operation;\nuse project::terminal::graph::Node;\nuse project::terminal::types::Coordinates;\n\n#[test]\nfn test_node_get_value() {\n    let node = Node {\n        dependents: Vec::new(),\n        node_value: 42,\n        value1: Coordinates { row: 0, col: 0 },\n        value2: Coordinates { row: 0, col: 0 },\n        position: Coordinates { row: 1, col: 1 },\n        op: Operation::Add,\n        valid: true,\n        visited: false,\n    };\n\n    assert_eq!(node.get_value(), 42);\n}\n\n#[test]\nfn test_node_set_value() {\n    let mut node = Node {\n        dependents: Vec::new(),\n        node_value: 42,\n        value1: Coordinates { row: 0, col: 0 },\n        value2: Coordinates { row: 0, col: 0 },\n        position: Coordinates { row: 1, col: 1 },\n        op: Operation::Add,\n        valid: true,\n        visited: false,\n    };\n\n    node.set_value(99);\n    assert_eq!(node.node_value, 99);\n    assert_eq!(node.get_value(), 99);\n}\n\n#[test]\nfn test_node_set_position() {\n    let mut node = Node {\n        dependents: Vec::new(),\n        node_value: 42,\n        value1: Coordinates { row: 0, col: 0 },\n        value2: Coordinates { row: 0, col: 0 },\n        position: Coordinates { row: 1, col: 1 },\n        op: Operation::Add,\n        valid: true,\n        visited: false,\n    };\n\n    let new_position = Coordinates { row: 3, col: 4 };\n    node.set_position(new_position);\n\n    assert_eq!(node.position.row, 3);\n    assert_eq!(node.position.col, 4);\n}\n\n#[test]\nfn test_node_set_value1() {\n    let mut node = Node {\n        dependents: Vec::new(),\n        node_value: 42,\n        value1: Coordinates { row: 0, col: 0 },\n        value2: Coordinates { row: 0, col: 0 },\n        position: Coordinates { row: 1, col: 1 },\n        op: Operation::Add,\n        valid: true,\n        visited: false,\n    };\n\n    let new_value1 = Coordinates { row: 5, col: 6 };\n    node.set_value1(new_value1);\n\n    assert_eq!(node.value1.row, 5);\n    assert_eq!(node.value1.col, 6);\n}\n\n#[test]\nfn test_node_set_value2() {\n    let mut node = Node {\n        dependents: Vec::new(),\n        node_value: 42,\n        value1: Coordinates { row: 0, col: 0 },\n        value2: Coordinates { row: 0, col: 0 },\n        position: Coordinates { row: 1, col: 1 },\n        op: Operation::Add,\n        valid: true,\n        visited: false,\n    };\n\n    let new_value2 = Coordinates { row: 7, col: 8 };\n    node.set_value2(new_value2);\n\n    assert_eq!(node.value2.row, 7);\n    assert_eq!(node.value2.col, 8);\n}\n\n#[test]\nfn test_node_get_valid() {\n    let valid_node = Node {\n        dependents: Vec::new(),\n        node_value: 42,\n        value1: Coordinates { row: 0, col: 0 },\n        value2: Coordinates { row: 0, col: 0 },\n        position: Coordinates { row: 1, col: 1 },\n        op: Operation::Add,\n        valid: true,\n        visited: false,\n    };\n\n    let invalid_node = Node {\n        dependents: Vec::new(),\n        node_value: 42,\n        value1: Coordinates { row: 0, col: 0 },\n        value2: Coordinates { row: 0, col: 0 },\n        position: Coordinates { row: 1, col: 1 },\n        op: Operation::Add,\n        valid: false,\n        visited: false,\n    };\n\n    assert!(valid_node.get_valid());\n    assert!(!invalid_node.get_valid());\n}\n\n#[test]\nfn test_node_set_valid() {\n    let mut node = Node {\n        dependents: Vec::new(),\n        node_value: 42,\n        value1: Coordinates { row: 0, col: 0 },\n        value2: Coordinates { row: 0, col: 0 },\n        position: Coordinates { row: 1, col: 1 },\n        op: Operation::Add,\n        valid: true,\n        visited: false,\n    };\n\n    assert!(node.get_valid());\n\n    node.set_valid(false);\n    assert!(!node.get_valid());\n    assert!(!node.valid);\n\n    node.set_valid(true);\n    assert!(node.get_valid());\n    assert!(node.valid);\n}\n\n#[test]\nfn test_node_add_dep() {\n    let mut node = Node {\n        dependents: Vec::new(),\n        node_value: 42,\n        value1: Coordinates { row: 0, col: 0 },\n        value2: Coordinates { row: 0, col: 0 },\n        position: Coordinates { row: 1, col: 1 },\n        op: Operation::Add,\n        valid: true,\n        visited: false,\n    };\n\n    // Add first dependent\n    let dep1 = Coordinates { row: 2, col: 3 };\n    node.add_dep(dep1);\n\n    assert_eq!(node.dependents.len(), 1);\n    assert_eq!(node.dependents[0].row, 2);\n    assert_eq!(node.dependents[0].col, 3);\n\n    // Add second dependent\n    let dep2 = Coordinates { row: 4, col: 5 };\n    node.add_dep(dep2);\n\n    assert_eq!(node.dependents.len(), 2);\n    assert_eq!(node.dependents[1].row, 4);\n    assert_eq!(node.dependents[1].col, 5);\n\n    // Try to add duplicate dependent\n    node.add_dep(dep1);\n\n    // Should still have only 2 dependents (no duplicates)\n    assert_eq!(node.dependents.len(), 2);\n}\n\n#[test]\nfn test_node_remove_dep() {\n    let mut node = Node {\n        dependents: Vec::new(),\n        node_value: 42,\n        value1: Coordinates { row: 0, col: 0 },\n        value2: Coordinates { row: 0, col: 0 },\n        position: Coordinates { row: 1, col: 1 },\n        op: Operation::Add,\n        valid: true,\n        visited: false,\n    };\n\n    // Add dependents\n    let dep1 = Coordinates { row: 2, col: 3 };\n    let dep2 = Coordinates { row: 4, col: 5 };\n    let dep3 = Coordinates { row: 6, col: 7 };\n\n    node.add_dep(dep1);\n    node.add_dep(dep2);\n    node.add_dep(dep3);\n\n    assert_eq!(node.dependents.len(), 3);\n\n    // Remove a dependent\n    node.remove_dep(dep2);\n\n    assert_eq!(node.dependents.len(), 2);\n    assert_eq!(node.dependents[0].row, 2);\n    assert_eq!(node.dependents[0].col, 3);\n    assert_eq!(node.dependents[1].row, 6);\n    assert_eq!(node.dependents[1].col, 7);\n\n    // Try to remove a dependent that doesn't exist\n    let non_existent_dep = Coordinates { row: 8, col: 9 };\n    node.remove_dep(non_existent_dep);\n\n    // Should still have 2 dependents\n    assert_eq!(node.dependents.len(), 2);\n}\n\n#[test]\nfn test_node_get_dependents() {\n    let mut node = Node {\n        dependents: Vec::new(),\n        node_value: 42,\n        value1: Coordinates { row: 0, col: 0 },\n        value2: Coordinates { row: 0, col: 0 },\n        position: Coordinates { row: 1, col: 1 },\n        op: Operation::Add,\n        valid: true,\n        visited: false,\n    };\n\n    // Add dependents\n    let dep1 = Coordinates { row: 2, col: 3 };\n    let dep2 = Coordinates { row: 4, col: 5 };\n\n    node.add_dep(dep1);\n    node.add_dep(dep2);\n\n    let deps = node.get_dependents();\n\n    assert_eq!(deps.len(), 2);\n    assert_eq!(deps[0].row, 2);\n    assert_eq!(deps[0].col, 3);\n    assert_eq!(deps[1].row, 4);\n    assert_eq!(deps[1].col, 5);\n}\n\n#[test]\nfn test_node_set_dependents() {\n    let mut node = Node {\n        dependents: Vec::new(),\n        node_value: 42,\n        value1: Coordinates { row: 0, col: 0 },\n        value2: Coordinates { row: 0, col: 0 },\n        position: Coordinates { row: 1, col: 1 },\n        op: Operation::Add,\n        valid: true,\n        visited: false,\n    };\n\n    // Create a list of dependents\n    let mut deps = Vec::new();\n    deps.push(Coordinates { row: 2, col: 3 });\n    deps.push(Coordinates { row: 4, col: 5 });\n    deps.push(Coordinates { row: 6, col: 7 });\n\n    // Set the dependents\n    node.set_dependents(deps);\n\n    assert_eq!(node.dependents.len(), 3);\n    assert_eq!(node.dependents[0].row, 2);\n    assert_eq!(node.dependents[0].col, 3);\n    assert_eq!(node.dependents[1].row, 4);\n    assert_eq!(node.dependents[1].col, 5);\n    assert_eq!(node.dependents[2].row, 6);\n    assert_eq!(node.dependents[2].col, 7);\n\n    // Override with a new list\n    let mut new_deps = Vec::new();\n    new_deps.push(Coordinates { row: 8, col: 9 });\n\n    node.set_dependents(new_deps);\n\n    assert_eq!(node.dependents.len(), 1);\n    assert_eq!(node.dependents[0].row, 8);\n    assert_eq!(node.dependents[0].col, 9);\n}\n\n// Helper function to create a default Node for testing\nfn create_test_node() -\u003e Node {\n    Node {\n        dependents: Vec::new(),\n        node_value: 0,\n        value1: Coordinates { row: 0, col: 0 },\n        value2: Coordinates { row: 0, col: 0 },\n        position: Coordinates { row: 0, col: 0 },\n        op: Operation::Add,\n        valid: true,\n        visited: false,\n    }\n}\n\n#[test]\nfn test_node_combined_operations() {\n    let mut node = create_test_node();\n\n    // Test multiple operations in sequence\n    node.set_value(42);\n    assert_eq!(node.get_value(), 42);\n\n    node.set_position(Coordinates { row: 1, col: 2 });\n    assert_eq!(node.position.row, 1);\n    assert_eq!(node.position.col, 2);\n\n    node.add_dep(Coordinates { row: 3, col: 4 });\n    node.add_dep(Coordinates { row: 5, col: 6 });\n    assert_eq!(node.dependents.len(), 2);\n\n    node.remove_dep(Coordinates { row: 3, col: 4 });\n    assert_eq!(node.dependents.len(), 1);\n    assert_eq!(node.dependents[0].row, 5);\n    assert_eq!(node.dependents[0].col, 6);\n\n    node.set_valid(false);\n    assert!(!node.get_valid());\n\n    // Test that setting dependents replaces existing ones\n    let mut new_deps = Vec::new();\n    new_deps.push(Coordinates { row: 7, col: 8 });\n    new_deps.push(Coordinates { row: 9, col: 10 });\n\n    node.set_dependents(new_deps);\n    assert_eq!(node.get_dependents().len(), 2);\n    assert_eq!(node.get_dependents()[0].row, 7);\n    assert_eq!(node.get_dependents()[0].col, 8);\n    assert_eq!(node.get_dependents()[1].row, 9);\n    assert_eq!(node.get_dependents()[1].col, 10);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","yuvikachaudhary","Desktop","Semester 4","COP290","spreadsheet_rust","tests","parser_ext.rs"],"content":"use project::extension::common::{Operation, Value};\nuse project::extension::parser::parser;\n\n#[test]\nfn test_validate_cell_assignment() {\n    // Test assigning a constant to a cell\n    let rows = 10;\n    let cols = 10;\n\n    // Test valid cell assignment\n    let result = parser::validate(\"A1=5\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n\n    if let Some((cell, operation)) = result {\n        assert_eq!(cell, Some(Value::Cell(1, 1)));\n        if let Some(Value::Oper(box1, box2, op)) = operation {\n            assert_eq!(*box1.unwrap(), Value::Const(5));\n            assert_eq!(*box2.unwrap(), Value::Const(0));\n            assert!(matches!(op, Operation::Cons));\n        } else {\n            panic!(\"Expected Value::Oper for operation\");\n        }\n    }\n\n    // Test invalid cell (out of range)\n    // let result = parser::validate(\"Z99=5\", \u0026cols, \u0026rows);\n    // assert!(result.is_none());\n}\n\n#[test]\nfn test_validate_arithmetic_operations() {\n    let rows = 10;\n    let cols = 10;\n\n    // Test addition\n    let result = parser::validate(\"B2=A1+5\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n\n    if let Some((cell, operation)) = result {\n        assert_eq!(cell, Some(Value::Cell(2, 2)));\n        if let Some(Value::Oper(box1, box2, op)) = operation {\n            assert_eq!(*box1.unwrap(), Value::Cell(1, 1));\n            assert_eq!(*box2.unwrap(), Value::Const(5));\n            assert!(matches!(op, Operation::Add));\n        }\n    }\n\n    // Test subtraction\n    let result = parser::validate(\"C3=10-D4\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n\n    if let Some((cell, operation)) = result {\n        assert_eq!(cell, Some(Value::Cell(3, 3)));\n        if let Some(Value::Oper(box1, box2, op)) = operation {\n            assert_eq!(*box1.unwrap(), Value::Const(10));\n            assert_eq!(*box2.unwrap(), Value::Cell(4, 4));\n            assert!(matches!(op, Operation::Sub));\n        }\n    }\n\n    // Test multiplication\n    let result = parser::validate(\"E5=F6*G7\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n\n    // Test division\n    let result = parser::validate(\"H8=100/I9\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n}\n\n#[test]\nfn test_validate_range_operations() {\n    let rows = 10;\n    let cols = 10;\n\n    // Test SUM\n    let result = parser::validate(\"D1=SUM(A1:C3)\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n\n    if let Some((cell, operation)) = result {\n        assert_eq!(cell, Some(Value::Cell(1, 4)));\n        if let Some(Value::Oper(box1, box2, op)) = operation {\n            assert_eq!(*box1.unwrap(), Value::Cell(1, 1));\n            assert_eq!(*box2.unwrap(), Value::Cell(3, 3));\n            assert!(matches!(op, Operation::Sum));\n        }\n    }\n\n    // Test AVG\n    let result = parser::validate(\"E1=AVG(A1:C3)\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n\n    if let Some((cell, operation)) = result {\n        assert_eq!(cell, Some(Value::Cell(1, 5)));\n        if let Some(Value::Oper(_box1, _box2, op)) = operation {\n            assert!(matches!(op, Operation::Avg));\n        }\n    }\n\n    // Test MIN\n    let result = parser::validate(\"F1=MIN(A1:C3)\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n\n    if let Some((_cell, operation)) = result {\n        if let Some(Value::Oper(_, _, op)) = operation {\n            assert!(matches!(op, Operation::Min));\n        }\n    }\n\n    // Test MAX\n    let result = parser::validate(\"G1=MAX(A1:C3)\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n\n    if let Some((_cell, operation)) = result {\n        if let Some(Value::Oper(_, _, op)) = operation {\n            assert!(matches!(op, Operation::Max));\n        }\n    }\n\n    // Test STDEV\n    let result = parser::validate(\"H1=STDEV(A1:C3)\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n\n    if let Some((_cell, operation)) = result {\n        if let Some(Value::Oper(_, _, op)) = operation {\n            assert!(matches!(op, Operation::Std));\n        }\n    }\n\n    // Test invalid range (start \u003e end)\n    let result = parser::validate(\"I1=SUM(C3:A1)\", \u0026cols, \u0026rows);\n    assert!(result.is_none());\n}\n\n#[test]\nfn test_validate_special_commands() {\n    let rows = 10;\n    let cols = 10;\n\n    // Test undo command\n    let result = parser::validate(\"undo\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n\n    if let Some((cell, operation)) = result {\n        assert!(cell.is_none());\n        if let Some(Value::Oper(box1, box2, op)) = operation {\n            assert!(box1.is_none());\n            assert!(box2.is_none());\n            assert!(matches!(op, Operation::Undo));\n        }\n    }\n\n    // Test redo command\n    let result = parser::validate(\"redo\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n\n    if let Some((cell, operation)) = result {\n        assert!(cell.is_none());\n        if let Some(Value::Oper(_, _, op)) = operation {\n            assert!(matches!(op, Operation::Redo));\n        }\n    }\n\n    // Test directional commands\n    let result = parser::validate(\"w\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n    if let Some((_, Some(Value::Oper(_, _, op)))) = result {\n        assert!(matches!(op, Operation::Up));\n    }\n\n    let result = parser::validate(\"s\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n    if let Some((_, Some(Value::Oper(_, _, op)))) = result {\n        assert!(matches!(op, Operation::Down));\n    }\n\n    let result = parser::validate(\"a\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n    if let Some((_, Some(Value::Oper(_, _, op)))) = result {\n        assert!(matches!(op, Operation::Left));\n    }\n\n    let result = parser::validate(\"d\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n    if let Some((_, Some(Value::Oper(_, _, op)))) = result {\n        assert!(matches!(op, Operation::Right));\n    }\n\n    // Test quit command\n    let result = parser::validate(\"q\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n    if let Some((_, Some(Value::Oper(_, _, op)))) = result {\n        assert!(matches!(op, Operation::Quit));\n    }\n}\n\n#[test]\nfn test_validate_save_web_commands() {\n    let rows = 10;\n    let cols = 10;\n\n    // Test save command\n    let result = parser::validate(\"save myfile.json\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n\n    if let Some((cell, operation)) = result {\n        assert!(cell.is_none());\n        if let Some(Value::Oper(box1, box2, Operation::Save(filename))) = operation {\n            assert!(box1.is_none());\n            assert!(box2.is_none());\n            assert_eq!(filename, \"myfile.json\");\n        }\n    }\n\n    // Test web command\n    let result = parser::validate(\"web index.html\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n\n    if let Some((cell, operation)) = result {\n        assert!(cell.is_none());\n        if let Some(Value::Oper(box1, box2, Operation::Web(filename))) = operation {\n            assert!(box1.is_none());\n            assert!(box2.is_none());\n            assert_eq!(filename, \"index.html\");\n        }\n    }\n\n    // Test web_start command\n    let result = parser::validate(\"web_start\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n\n    if let Some((_, Some(Value::Oper(_, _, op)))) = result {\n        assert!(matches!(op, Operation::WebStart));\n    }\n}\n\n#[test]\nfn test_validate_scroll_to() {\n    let rows = 10;\n    let cols = 10;\n\n    // Test valid scroll_to command\n    let result = parser::validate(\"scroll_to B5\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n\n    if let Some((cell, operation)) = result {\n        assert_eq!(cell, Some(Value::Cell(5, 2)));\n        if let Some(Value::Oper(_, _, op)) = operation {\n            assert!(matches!(op, Operation::ScrollTo));\n        }\n    }\n\n    // Test invalid scroll_to (out of bounds)\n    let result = parser::validate(\"scroll_to Z99\", \u0026cols, \u0026rows);\n    assert!(result.is_none());\n}\n\n#[test]\nfn test_validate_output_commands() {\n    let rows = 10;\n    let cols = 10;\n\n    // Test enable_output command\n    let result = parser::validate(\"enable_output\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n\n    if let Some((_, Some(Value::Oper(_, _, op)))) = result {\n        assert!(matches!(op, Operation::EnableOutput));\n    }\n\n    // Test disable_output command\n    let result = parser::validate(\"disable_output\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n\n    if let Some((_, Some(Value::Oper(_, _, op)))) = result {\n        assert!(matches!(op, Operation::DisableOutput));\n    }\n}\n\n#[test]\nfn test_validate_invalid_commands() {\n    let rows = 10;\n    let cols = 10;\n\n    // Test completely invalid command\n    let result = parser::validate(\"this is not a valid command\", \u0026cols, \u0026rows);\n    assert!(result.is_none());\n\n    // Test command with missing equals sign\n    let result = parser::validate(\"A1 5\", \u0026cols, \u0026rows);\n    assert!(result.is_none());\n\n    // Test invalid function name\n    let result = parser::validate(\"A1=INVALID(B1:C3)\", \u0026cols, \u0026rows);\n    let expected_value = Some((Some(Value::Cell(1, 1)), None));\n    assert_eq!(result, expected_value);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","yuvikachaudhary","Desktop","Semester 4","COP290","spreadsheet_rust","tests","parser_terminal.rs"],"content":"use project::terminal::functions::Operation;\nuse project::terminal::functions::Value;\nuse project::terminal::parser;\n\n#[test]\nfn test_validate_cell_assignment() {\n    // Test assigning a constant to a cell\n    let rows = 10;\n    let cols = 10;\n\n    // Test valid cell assignment\n    let result = parser::validate(\"A1=5\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n\n    // Test invalid cell (out of range)\n    // let result = parser::validate(\"Z99=5\", \u0026cols, \u0026rows);\n    // assert!(result.is_none());\n}\n\n#[test]\nfn test_validate_arithmetic_operations() {\n    let rows = 10;\n    let cols = 10;\n\n    // Test addition\n    let result = parser::validate(\"B2=A1+5\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n\n    // Test subtraction\n    let result = parser::validate(\"C3=10-D4\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n\n    if let Some((cell, _operation)) = result {\n        assert_eq!(cell, Some(Value::Cell(3, 3)));\n    }\n\n    // Test multiplication\n    let result = parser::validate(\"E5=F6*G7\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n\n    // Test division\n    let result = parser::validate(\"H8=100/I9\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n}\n\n#[test]\nfn test_validate_range_operations() {\n    let rows = 10;\n    let cols = 10;\n\n    // Test SUM\n    let result = parser::validate(\"D1=SUM(A1:C3)\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n\n    if let Some((cell, _operation)) = result {\n        assert_eq!(cell, Some(Value::Cell(4, 1)));\n    }\n\n    // Test AVG\n    let result = parser::validate(\"E1=AVG(A1:C3)\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n\n    if let Some((cell, operation)) = result {\n        assert_eq!(cell, Some(Value::Cell(5, 1)));\n        if let Some(Value::Oper(_box1, _box2, op)) = operation {\n            assert!(matches!(op, Operation::Avg));\n        }\n    }\n\n    // Test MIN\n    let result = parser::validate(\"F1=MIN(A1:C3)\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n\n    if let Some((_cell, operation)) = result {\n        if let Some(Value::Oper(_, _, op)) = operation {\n            assert!(matches!(op, Operation::Min));\n        }\n    }\n\n    // Test MAX\n    let result = parser::validate(\"G1=MAX(A1:C3)\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n\n    if let Some((_cell, operation)) = result {\n        if let Some(Value::Oper(_, _, op)) = operation {\n            assert!(matches!(op, Operation::Max));\n        }\n    }\n\n    // Test STDEV\n    let result = parser::validate(\"H1=STDEV(A1:C3)\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n\n    if let Some((_cell, operation)) = result {\n        if let Some(Value::Oper(_, _, op)) = operation {\n            assert!(matches!(op, Operation::Std));\n        }\n    }\n\n    // Test invalid range (start \u003e end)\n    let result = parser::validate(\"I1=SUM(C3:A1)\", \u0026cols, \u0026rows);\n    assert!(result.is_none());\n}\n\n#[test]\nfn test_validate_scroll_to() {\n    let rows = 10;\n    let cols = 10;\n\n    // Test valid scroll_to command\n    let result = parser::validate(\"scroll_to B5\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n\n    if let Some((cell, operation)) = result {\n        assert_eq!(cell, Some(Value::Cell(2, 5)));\n        if let Some(Value::Oper(_, _, op)) = operation {\n            assert!(matches!(op, Operation::Scrollto));\n        }\n    }\n\n    // Test invalid scroll_to (out of bounds)\n    let result = parser::validate(\"scroll_to Z99\", \u0026cols, \u0026rows);\n    assert!(result.is_none());\n}\n\n#[test]\nfn test_validate_output_commands() {\n    let rows = 10;\n    let cols = 10;\n\n    // Test enable_output command\n    let result = parser::validate(\"enable_output\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n\n    if let Some((_, Some(Value::Oper(_, _, op)))) = result {\n        assert!(matches!(op, Operation::EnableOutput));\n    }\n\n    // Test disable_output command\n    let result = parser::validate(\"disable_output\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n\n    if let Some((_, Some(Value::Oper(_, _, op)))) = result {\n        assert!(matches!(op, Operation::DisableOutput));\n    }\n}\n\n#[test]\nfn test_validate_invalid_commands() {\n    let rows = 10;\n    let cols = 10;\n\n    // Test completely invalid command\n    let result = parser::validate(\"this is not a valid command\", \u0026cols, \u0026rows);\n    assert!(result.is_none());\n\n    // Test command with missing equals sign\n    let result = parser::validate(\"A1 5\", \u0026cols, \u0026rows);\n    assert!(result.is_none());\n\n    // Test invalid function name\n    let result = parser::validate(\"A1=INVALID(B1:C3)\", \u0026cols, \u0026rows);\n    let expected_value = Some((Some(Value::Cell(1, 1)), None));\n    assert_eq!(result, expected_value);\n}\n\n#[test]\nfn test_is_cell() {\n    let rows = 10;\n    let cols = 10;\n\n    // Valid cells\n    assert_eq!(parser::is_cell(\"A1\", \u0026rows, \u0026cols), Some(Value::Cell(1, 1)));\n    assert_eq!(parser::is_cell(\"B5\", \u0026rows, \u0026cols), Some(Value::Cell(2, 5)));\n    assert_eq!(\n        parser::is_cell(\"J10\", \u0026rows, \u0026cols),\n        Some(Value::Cell(10, 10))\n    );\n\n    // Invalid cells\n    assert_eq!(parser::is_cell(\"Z1\", \u0026rows, \u0026cols), None); // Column out of range\n    assert_eq!(parser::is_cell(\"A20\", \u0026rows, \u0026cols), None); // Row out of range\n    assert_eq!(parser::is_cell(\"1A\", \u0026rows, \u0026cols), None); // Invalid format\n    assert_eq!(parser::is_cell(\"AA1\", \u0026rows, \u0026cols), None); // Two-letter column\n}\n\n#[test]\nfn test_is_const() {\n    // Valid integers\n    assert_eq!(parser::is_const(\"0\"), Some(Value::Const(0)));\n    assert_eq!(parser::is_const(\"42\"), Some(Value::Const(42)));\n    assert_eq!(parser::is_const(\"-10\"), Some(Value::Const(-10)));\n\n    // Invalid integers\n    assert_eq!(parser::is_const(\"\"), None); // Empty string\n    assert_eq!(parser::is_const(\"a\"), None); // Non-numeric\n    assert_eq!(parser::is_const(\"3.14\"), None); // Float, not integer\n}\n\n#[test]\nfn test_is_cell_or_const() {\n    let rows = 10;\n    let cols = 10;\n\n    // Test constant values\n    assert_eq!(\n        parser::is_cell_or_const(\"42\", \u0026rows, \u0026cols),\n        Some(Value::Const(42))\n    );\n    assert_eq!(\n        parser::is_cell_or_const(\"-5\", \u0026rows, \u0026cols),\n        Some(Value::Const(-5))\n    );\n\n    // Test cell references\n    assert_eq!(\n        parser::is_cell_or_const(\"A1\", \u0026rows, \u0026cols),\n        Some(Value::Cell(1, 1))\n    );\n    assert_eq!(\n        parser::is_cell_or_const(\"J10\", \u0026rows, \u0026cols),\n        Some(Value::Cell(10, 10))\n    );\n\n    // // Test invalid inputs\n    assert_eq!(parser::is_cell_or_const(\"ZZ99\", \u0026rows, \u0026cols), None);\n    assert_eq!(parser::is_cell_or_const(\"3.14\", \u0026rows, \u0026cols), None);\n}\n\n#[test]\nfn test_validate_complex_arithmetic() {\n    let rows = 10;\n    let cols = 10;\n\n    // Test negative numbers in operations\n    let result = parser::validate(\"A1=-5+B2\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n\n    // Test cell references with cells\n    let result = parser::validate(\"C3=A1+B2\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n\n    // Test multiple digit constants\n    let result = parser::validate(\"D4=123+456\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n\n    // Test all operators with different combinations\n    let operations = [\n        (\"E1=15+25\", Operation::Add),\n        (\"E2=30-10\", Operation::Sub),\n        (\"E3=5*6\", Operation::Mul),\n        (\"E4=20/4\", Operation::Div),\n    ];\n\n    for (cmd, _expected_op) in operations {\n        let result = parser::validate(cmd, \u0026cols, \u0026rows);\n        assert!(result.is_some());\n        if let Some((_, Some(Value::Oper(_, _, op)))) = result {\n            assert!(matches!(op, _expected_op));\n        } else {\n            panic!(\"Expected operation for {}\", cmd);\n        }\n    }\n}\n\n#[test]\nfn test_missing_special_commands() {\n    let rows = 10;\n    let cols = 10;\n\n    // Test all scroll_to variations\n    let result = parser::validate(\"scroll_to A1\", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n    if let Some((cell, Some(Value::Oper(_, _, op)))) = result {\n        assert_eq!(cell, Some(Value::Cell(1, 1)));\n        assert!(matches!(op, Operation::Scrollto));\n    }\n\n    // Test with extra whitespace\n    let result = parser::validate(\"  scroll_to  C3  \", \u0026cols, \u0026rows);\n    assert!(result.is_some());\n\n    // Test invalid cell for scroll_to\n    let result = parser::validate(\"scroll_to Z99\", \u0026cols, \u0026rows);\n    assert!(result.is_none());\n\n    // Test invalid format for scroll_to\n    let result = parser::validate(\"scroll_toA1\", \u0026cols, \u0026rows);\n    assert!(result.is_none());\n}\n\n#[test]\nfn test_command_validation_edge_cases() {\n    let rows = 10;\n    let cols = 10;\n\n    // Test missing closing parenthesis\n    let result = parser::validate(\"A1=SUM(B1:C2\", \u0026cols, \u0026rows);\n    assert!(result.is_none());\n\n    // Test invalid chars in cell names\n    let result = parser::validate(\"A@1=5\", \u0026cols, \u0026rows);\n    if let Some((cell, Some(Value::Oper(_, _, _op)))) = result {\n        assert!(cell.is_none());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","yuvikachaudhary","Desktop","Semester 4","COP290","spreadsheet_rust","tests","spreadsheet_terminal.rs"],"content":"#[allow(unused_imports)]\nuse project::terminal::functions::{Operation, Value};\nuse project::terminal::graph::Node;\nuse project::terminal::spreadsheet::*;\nuse project::terminal::types::Coordinates;\n#[allow(unused_imports)]\nuse std::collections::HashMap;\n#[allow(unused_imports)]\nuse std::io::{self, Write};\n\n// Existing tests\n\n#[test]\nfn test_column_decoder() {\n    // Test single-letter columns\n    assert_eq!(column_decoder(1), \"A\");\n    assert_eq!(column_decoder(26), \"Z\");\n\n    // Test double-letter columns\n    assert_eq!(column_decoder(27), \"AA\");\n    assert_eq!(column_decoder(28), \"AB\");\n    assert_eq!(column_decoder(52), \"AZ\");\n    assert_eq!(column_decoder(53), \"BA\");\n\n    // Test triple-letter columns\n    assert_eq!(column_decoder(703), \"AAA\");\n    assert_eq!(column_decoder(18278), \"ZZZ\"); // MAX_COLUMN\n}\n\n// New edge cases for column_decoder\n#[test]\nfn test_column_decoder_edge_cases() {\n    // Edge cases\n    assert_eq!(column_decoder(702), \"ZZ\");\n    assert_eq!(column_decoder(677), \"ZA\");\n    assert_eq!(column_decoder(676), \"YZ\");\n}\n\n#[test]\nfn test_process_first() {\n    // Valid arguments\n    let args = vec![\n        String::from(\"program_name\"),\n        String::from(\"100\"),\n        String::from(\"100\"),\n    ];\n    let mut is_disabled = false;\n    assert!(process_first(args.len(), \u0026args, \u0026mut is_disabled));\n\n    // Invalid number of arguments\n    let invalid_args = vec![String::from(\"program_name\"), String::from(\"100\")];\n    assert!(!process_first(\n        invalid_args.len(),\n        \u0026invalid_args,\n        \u0026mut is_disabled\n    ));\n\n    // Non-numeric arguments\n    let non_numeric_args = vec![\n        String::from(\"program_name\"),\n        String::from(\"abc\"),\n        String::from(\"100\"),\n    ];\n    assert!(!process_first(\n        non_numeric_args.len(),\n        \u0026non_numeric_args,\n        \u0026mut is_disabled\n    ));\n\n    // Out of range arguments (too large)\n    let large_args = vec![\n        String::from(\"program_name\"),\n        String::from(\"1000\"), // Exceeds MAX_ROW\n        String::from(\"100\"),\n    ];\n    assert!(!process_first(\n        large_args.len(),\n        \u0026large_args,\n        \u0026mut is_disabled\n    ));\n\n    let large_col_args = vec![\n        String::from(\"program_name\"),\n        String::from(\"100\"),\n        String::from(\"18279\"), // Exceeds MAX_COLUMN\n    ];\n    assert!(!process_first(\n        large_col_args.len(),\n        \u0026large_col_args,\n        \u0026mut is_disabled\n    ));\n\n    // Out of range arguments (too small)\n    let zero_args = vec![\n        String::from(\"program_name\"),\n        String::from(\"0\"), // Below valid range\n        String::from(\"100\"),\n    ];\n    assert!(!process_first(\n        zero_args.len(),\n        \u0026zero_args,\n        \u0026mut is_disabled\n    ));\n}\n\n// Additional test for process_first with boundary values\n#[test]\nfn test_process_first_boundary_values() {\n    let mut is_disabled = false;\n\n    // Test with minimum valid values\n    let min_args = vec![\n        String::from(\"program_name\"),\n        String::from(\"1\"),\n        String::from(\"1\"),\n    ];\n    assert!(process_first(min_args.len(), \u0026min_args, \u0026mut is_disabled));\n\n    // Test with maximum valid values\n    let max_args = vec![\n        String::from(\"program_name\"),\n        String::from(\"999\"),   // MAX_ROW\n        String::from(\"18278\"), // MAX_COLUMN\n    ];\n    assert!(process_first(max_args.len(), \u0026max_args, \u0026mut is_disabled));\n\n    // Test with too many arguments\n    let too_many_args = vec![\n        String::from(\"program_name\"),\n        String::from(\"100\"),\n        String::from(\"100\"),\n        String::from(\"extra\"),\n    ];\n    assert!(!process_first(\n        too_many_args.len(),\n        \u0026too_many_args,\n        \u0026mut is_disabled\n    ));\n\n    // Test with empty strings\n    let empty_args = vec![\n        String::from(\"program_name\"),\n        String::from(\"\"),\n        String::from(\"100\"),\n    ];\n    assert!(!process_first(\n        empty_args.len(),\n        \u0026empty_args,\n        \u0026mut is_disabled\n    ));\n}\n\n// Mock creating a grid for testing\nfn create_test_grid(rows: usize, cols: usize) -\u003e Vec\u003cVec\u003cNode\u003e\u003e {\n    let mut grid = Vec::with_capacity(rows + 1);\n    for i in 0..=rows {\n        let mut row = Vec::with_capacity(cols + 1);\n        for j in 0..=cols {\n            let mut node = Node {\n                node_value: 0,\n                valid: false,\n                dependents: Vec::new(),\n                value1: Coordinates { row: 0, col: 0 },\n                value2: Coordinates { row: 0, col: 0 },\n                position: Coordinates {\n                    row: i as i32,\n                    col: j as i32,\n                },\n                op: Operation::Add, // Default operation\n                visited: false,\n            };\n            if i \u003e 0 \u0026\u0026 j \u003e 0 {\n                // Set some example values\n                node.node_value = 0;\n                node.valid = true;\n            }\n            row.push(node);\n        }\n        grid.push(row);\n    }\n\n    // Add some invalid cells for testing\n    if rows \u003e= 5 \u0026\u0026 cols \u003e= 5 {\n        grid[3][3].valid = false;\n    }\n\n    grid\n}\n\n#[test]\nfn test_process_command_navigation() {\n    let rows = 30;\n    let cols = 30;\n    let mut grid = create_test_grid(rows, cols);\n    let mut start_x = 10;\n    let mut start_y = 10;\n    let mut is_disabled = false;\n\n    // Test movement commands\n    assert_eq!(\n        process_command(\n            \"w\",\n            \u0026mut start_x,\n            \u0026mut start_y,\n            rows,\n            cols,\n            \u0026mut is_disabled,\n            \u0026mut grid\n        ),\n        1\n    );\n    assert_eq!(start_x, 1); // Move up 10 rows but not below 1\n\n    start_x = 15;\n    assert_eq!(\n        process_command(\n            \"w\",\n            \u0026mut start_x,\n            \u0026mut start_y,\n            rows,\n            cols,\n            \u0026mut is_disabled,\n            \u0026mut grid\n        ),\n        1\n    );\n    assert_eq!(start_x, 5); // Move up 10 rows\n\n    assert_eq!(\n        process_command(\n            \"s\",\n            \u0026mut start_x,\n            \u0026mut start_y,\n            rows,\n            cols,\n            \u0026mut is_disabled,\n            \u0026mut grid\n        ),\n        1\n    );\n    assert_eq!(start_x, 15); // Move down 10 rows\n\n    assert_eq!(\n        process_command(\n            \"a\",\n            \u0026mut start_x,\n            \u0026mut start_y,\n            rows,\n            cols,\n            \u0026mut is_disabled,\n            \u0026mut grid\n        ),\n        1\n    );\n    assert_eq!(start_y, 1); // Move left 10 columns but not below 1\n\n    start_y = 15;\n    assert_eq!(\n        process_command(\n            \"a\",\n            \u0026mut start_x,\n            \u0026mut start_y,\n            rows,\n            cols,\n            \u0026mut is_disabled,\n            \u0026mut grid\n        ),\n        1\n    );\n    assert_eq!(start_y, 5); // Move left 10 columns\n\n    assert_eq!(\n        process_command(\n            \"d\",\n            \u0026mut start_x,\n            \u0026mut start_y,\n            rows,\n            cols,\n            \u0026mut is_disabled,\n            \u0026mut grid\n        ),\n        1\n    );\n    assert_eq!(start_y, 15); // Move right 10 columns\n\n    // Test output toggle commands\n    // We'll need to simulate a command that would toggle output\n    // Since we don't have direct access to the parser implementation, this is a placeholder\n    // You'll need to update this based on your actual implementation\n    let disable_output_cmd = \"disable_output\"; // Replace with your actual command syntax\n    if let 1 = process_command(\n        disable_output_cmd,\n        \u0026mut start_x,\n        \u0026mut start_y,\n        rows,\n        cols,\n        \u0026mut is_disabled,\n        \u0026mut grid,\n    ) {\n        assert!(is_disabled);\n    }\n\n    let enable_output_cmd = \"enable_output\"; // Replace with your actual command syntax\n    if let 1 = process_command(\n        enable_output_cmd,\n        \u0026mut start_x,\n        \u0026mut start_y,\n        rows,\n        cols,\n        \u0026mut is_disabled,\n        \u0026mut grid,\n    ) {\n        assert!(!is_disabled);\n    }\n\n    // Test quit command\n    assert_eq!(\n        process_command(\n            \"q\",\n            \u0026mut start_x,\n            \u0026mut start_y,\n            rows,\n            cols,\n            \u0026mut is_disabled,\n            \u0026mut grid\n        ),\n        0\n    );\n}\n\n// New test for navigation at grid boundaries\n#[test]\nfn test_navigation_at_grid_boundaries() {\n    let rows = 15;\n    let cols = 15;\n    let mut grid = create_test_grid(rows, cols);\n    let mut is_disabled = false;\n\n    // Test at top boundary\n    let mut start_x = 1;\n    let mut start_y = 8;\n    assert_eq!(\n        process_command(\n            \"w\",\n            \u0026mut start_x,\n            \u0026mut start_y,\n            rows,\n            cols,\n            \u0026mut is_disabled,\n            \u0026mut grid\n        ),\n        1\n    );\n    assert_eq!(start_x, 1); // Should remain at 1, not go below\n\n    // Test at bottom boundary\n    start_x = rows - 8;\n    assert_eq!(\n        process_command(\n            \"s\",\n            \u0026mut start_x,\n            \u0026mut start_y,\n            rows,\n            cols,\n            \u0026mut is_disabled,\n            \u0026mut grid\n        ),\n        1\n    );\n    assert_eq!(start_x, 7);\n\n    // Another move down should be constrained to show the last rows\n    assert_eq!(\n        process_command(\n            \"s\",\n            \u0026mut start_x,\n            \u0026mut start_y,\n            rows,\n            cols,\n            \u0026mut is_disabled,\n            \u0026mut grid\n        ),\n        1\n    );\n    assert_eq!(start_x, rows - 8); // Constrained to show the last 9 rows\n\n    // Test at left boundary\n    start_x = 8;\n    start_y = 1;\n    assert_eq!(\n        process_command(\n            \"a\",\n            \u0026mut start_x,\n            \u0026mut start_y,\n            rows,\n            cols,\n            \u0026mut is_disabled,\n            \u0026mut grid\n        ),\n        1\n    );\n    assert_eq!(start_y, 1); // Should remain at 1, not go below\n\n    // Test at right boundary\n    start_y = cols - 8;\n    assert_eq!(\n        process_command(\n            \"d\",\n            \u0026mut start_x,\n            \u0026mut start_y,\n            rows,\n            cols,\n            \u0026mut is_disabled,\n            \u0026mut grid\n        ),\n        1\n    );\n    assert_eq!(start_y, cols - 8);\n\n    // Another move right should be constrained to show the last columns\n    assert_eq!(\n        process_command(\n            \"d\",\n            \u0026mut start_x,\n            \u0026mut start_y,\n            rows,\n            cols,\n            \u0026mut is_disabled,\n            \u0026mut grid\n        ),\n        1\n    );\n    assert_eq!(start_y, cols - 8); // Constrained to show the last 9 columns\n}\n\n// Test invalid commands\n#[test]\nfn test_invalid_commands() {\n    let rows = 20;\n    let cols = 20;\n    let mut grid = create_test_grid(rows, cols);\n    let mut start_x = 10;\n    let mut start_y = 10;\n    let mut is_disabled = false;\n\n    // Test completely invalid command\n    assert_eq!(\n        process_command(\n            \"invalid_command\",\n            \u0026mut start_x,\n            \u0026mut start_y,\n            rows,\n            cols,\n            \u0026mut is_disabled,\n            \u0026mut grid\n        ),\n        3 // Expected to return code 3 for unrecognized command\n    );\n\n    // Test command with invalid syntax\n    assert_eq!(\n        process_command(\n            \"A1 = invalid_operation(B2, C3)\",\n            \u0026mut start_x,\n            \u0026mut start_y,\n            rows,\n            cols,\n            \u0026mut is_disabled,\n            \u0026mut grid\n        ),\n        3 // Expected to return code 3 for unrecognized command\n    );\n}\n\n// This is a more involved test that requires mocking the parser\n// and getting_things_updated functions\n#[test]\nfn test_process_command_cell_operations() {\n    // This test is more complex and depends on your implementation details\n    // You'll need to expand this based on your actual parser and backend functions\n\n    let rows = 30;\n    let cols = 30;\n    let mut grid = create_test_grid(rows, cols);\n    let mut start_x = 10;\n    let mut start_y = 10;\n    let mut is_disabled = false;\n\n    // Test scrollto operation\n    // Replace with your actual command syntax\n    let scrollto_cmd = \"A5 = scroll_to B2\";\n\n    // For this test to work correctly, you'll need to ensure your parser handles this command\n    // and recognizes it as a scrollto operation\n    let result = process_command(\n        scrollto_cmd,\n        \u0026mut start_x,\n        \u0026mut start_y,\n        rows,\n        cols,\n        \u0026mut is_disabled,\n        \u0026mut grid,\n    );\n\n    // If your parser correctly identifies this as a scrollto operation, it should:\n    // 1. Update start_x to the row value\n    // 2. Update start_y to the column value\n    // 3. Return status code 1\n\n    // This is a placeholder assertion - you'll need to update based on actual behavior\n    if result == 1 {\n        // Check if scrollto was successful (values would be set based on your implementation)\n        // The expected values depend on how your parser interprets the command\n    }\n\n    // Test basic cell operations\n    // These depend heavily on your parser implementation\n    let _basic_op_cmd = \"B2 = C3 + 5\";\n    // This test requires knowing how your parser and getting_things_updated function work\n}\n\n// New test for cell operations based on actual parser examples\n#[test]\nfn test_cell_operations_with_mock() {\n    // This test creates a simulated environment to test cell operations\n    // Assuming the parser syntax is like: \"A1 = add(B2, C3)\"\n    let rows = 30;\n    let cols = 30;\n    let mut grid = create_test_grid(rows, cols);\n    let mut start_x = 5;\n    let mut start_y = 5;\n    let mut is_disabled = false;\n\n    // These commands need to match your actual parser syntax\n    // Modify them based on your implementation\n\n    // Basic arithmetic operations\n    let add_cmd = \"A1 = B2+C3\";\n    let sub_cmd = \"D4 = E5-F6\";\n    let mul_cmd = \"G7 = H8*I9\";\n    let div_cmd = \"J10 = K11/L12\";\n\n    // Process commands and check status codes\n    // The expected return values depend on your implementation\n    let add_result = process_command(\n        add_cmd,\n        \u0026mut start_x,\n        \u0026mut start_y,\n        rows,\n        cols,\n        \u0026mut is_disabled,\n        \u0026mut grid,\n    );\n\n    let sub_result = process_command(\n        sub_cmd,\n        \u0026mut start_x,\n        \u0026mut start_y,\n        rows,\n        cols,\n        \u0026mut is_disabled,\n        \u0026mut grid,\n    );\n\n    let mul_result = process_command(\n        mul_cmd,\n        \u0026mut start_x,\n        \u0026mut start_y,\n        rows,\n        cols,\n        \u0026mut is_disabled,\n        \u0026mut grid,\n    );\n\n    let div_result = process_command(\n        div_cmd,\n        \u0026mut start_x,\n        \u0026mut start_y,\n        rows,\n        cols,\n        \u0026mut is_disabled,\n        \u0026mut grid,\n    );\n\n    // Check status codes based on your expected behavior\n    // This is a basic check to ensure the commands are processed\n    assert!(add_result \u003e= 1 \u0026\u0026 add_result \u003c= 5);\n    assert!(sub_result \u003e= 1 \u0026\u0026 sub_result \u003c= 5);\n    assert!(mul_result \u003e= 1 \u0026\u0026 mul_result \u003c= 5);\n    assert!(div_result \u003e= 1 \u0026\u0026 div_result \u003c= 5);\n}\n\n#[test]\nfn test_display_status() {\n    // This is mainly a visual function that writes to stdout\n    // We can test that it doesn't panic, but testing the actual output\n    // requires capturing stdout which is complex in Rust unit tests\n\n    // Test all status codes\n    display_status(1, 0.25);\n    display_status(2, 0.50);\n    display_status(3, 0.75);\n    display_status(4, 1.00);\n    display_status(5, 1.25);\n    display_status(6, 1.50); // Unknown status code\n\n    // If we reach here without panicking, the test passes\n    assert!(true);\n}\n\n// New test for display_status with extreme values\n#[test]\nfn test_display_status_edge_cases() {\n    // Test with very small time\n    display_status(1, 0.0001);\n\n    // Test with zero time\n    display_status(1, 0.0);\n\n    // Test with large time\n    display_status(1, 99999.9999);\n\n    // Test negative status code (should be handled gracefully)\n    display_status(-1, 1.0);\n\n    // If we reach here without panicking, the test passes\n    assert!(true);\n}\n\n#[test]\nfn test_print_grid() {\n    // Similar to display_status, this mainly outputs to stdout\n    // We can test that it doesn't panic with various inputs\n\n    let rows = 20;\n    let cols = 20;\n    let mut grid = create_test_grid(rows, cols);\n\n    // Test different view windows\n    print_grid(1, 1, rows, cols, \u0026mut grid);\n    print_grid(5, 5, rows, cols, \u0026mut grid);\n    print_grid(rows, cols, rows, cols, \u0026mut grid); // Edge of grid\n\n    // Test with a small grid that's smaller than the view window\n    let small_rows = 5;\n    let small_cols = 5;\n    let mut small_grid = create_test_grid(small_rows, small_cols);\n    print_grid(1, 1, small_rows, small_cols, \u0026mut small_grid);\n\n    // If we reach here without panicking, the test passes\n    assert!(true);\n}\n\n// New test for print_grid with edge cases\n#[test]\nfn test_print_grid_edge_cases() {\n    let rows = 15;\n    let cols = 15;\n    let mut grid = create_test_grid(rows, cols);\n\n    // Test boundary conditions\n    print_grid(rows - 8, cols - 8, rows, cols, \u0026mut grid); // Near the edge\n    print_grid(rows, cols, rows, cols, \u0026mut grid); // At the edge\n\n    // Test with view window that would extend beyond grid boundaries\n    print_grid(rows - 5, cols - 5, rows, cols, \u0026mut grid);\n\n    // Test with single row/column visibility\n    print_grid(rows, 1, rows, cols, \u0026mut grid);\n    print_grid(1, cols, rows, cols, \u0026mut grid);\n\n    // Test with starting position at the exact boundary\n    print_grid(rows + 1, cols + 1, rows, cols, \u0026mut grid);\n\n    // If we reach here without panicking, the test passes\n    assert!(true);\n}\n\n// Test the output toggle functionality\n#[test]\nfn test_output_toggle() {\n    let rows = 20;\n    let cols = 20;\n    let mut grid = create_test_grid(rows, cols);\n    let mut start_x = 10;\n    let mut start_y = 10;\n    let mut is_disabled = false;\n\n    // Test initial state\n    assert!(!is_disabled);\n\n    // Test with your actual disable output command\n    // Replace with your actual syntax\n    let disable_output_cmd = \"output disable\";\n\n    let result = process_command(\n        disable_output_cmd,\n        \u0026mut start_x,\n        \u0026mut start_y,\n        rows,\n        cols,\n        \u0026mut is_disabled,\n        \u0026mut grid,\n    );\n\n    // If command is correctly parsed, check that is_disabled is now true\n    if result == 1 {\n        assert!(is_disabled);\n    }\n\n    // Test with your actual enable output command\n    // Replace with your actual syntax\n    let enable_output_cmd = \"output enable\";\n\n    let result = process_command(\n        enable_output_cmd,\n        \u0026mut start_x,\n        \u0026mut start_y,\n        rows,\n        cols,\n        \u0026mut is_disabled,\n        \u0026mut grid,\n    );\n\n    // If command is correctly parsed, check that is_disabled is now false\n    if result == 1 {\n        assert!(!is_disabled);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","yuvikachaudhary","Desktop","Semester 4","COP290","spreadsheet_rust","tests","types_terminal.rs"],"content":"use project::terminal::types::*;\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_coordinates_creation() {\n        let coord = Coordinates { row: 2, col: 3 };\n        assert_eq!(coord.row, 2);\n        assert_eq!(coord.col, 3);\n    }\n\n    #[test]\n    fn test_coordinates_display() {\n        let coord = Coordinates { row: 5, col: 7 };\n        let output = format!(\"{}\", coord);\n        assert_eq!(output, \"(5, 7)\");\n    }\n\n    #[test]\n    fn test_coordinates_equality() {\n        let coord1 = Coordinates { row: 1, col: 1 };\n        let coord2 = Coordinates { row: 1, col: 1 };\n        let coord3 = Coordinates { row: 0, col: 0 };\n\n        assert_eq!(coord1, coord2);\n        assert_ne!(coord1, coord3);\n    }\n\n    #[test]\n    fn test_coordinates_clone_and_copy() {\n        let coord1 = Coordinates { row: 10, col: 20 };\n        let coord2 = coord1; // Copy trait in action\n        let coord3 = coord1.clone(); // Clone trait\n\n        assert_eq!(coord1, coord2);\n        assert_eq!(coord1, coord3);\n    }\n\n    #[test]\n    fn test_coordinates_default() {\n        let coord = Coordinates::default();\n        assert_eq!(coord.row, 0);\n        assert_eq!(coord.col, 0);\n    }\n}\n","traces":[],"covered":0,"coverable":0}]};
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('pre', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('code', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>